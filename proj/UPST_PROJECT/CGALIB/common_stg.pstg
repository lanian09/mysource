FileName : common_stg.h
/* STC_FileName : LOG_member_Get_func.stc , LOG_member_Set_func.stc , BODY.stc , flow.stc , cilog.stc , cilog_table.stc , log_table.stc , clex.stc , flow_dot.stcI */
STC_FileName : LOG_member_Get_func.stc , LOG_member_Set_func.stc , BODY.stc , flow.stc , cilog.stc , clex.stc , flow_dot.stcI

#include <hasho.h>
#include <hashg.h>
#include <timerN.h>
#include <mems.h>
#include <nifo.h>

#pragma pack(1)

extern int debug_print(int dIndex, char *fmt, ...);

/* TCP Session, HTTP Trans Count */
#if defined(COMMERCIALLOG)

#if defined(RP)
#define CALL_SESS_CNT		350003
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        10007
#define HTTP_TRANS_CNT		50021
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       10007
#define IHTTP_TRANS_CNT		50021
#define INET_HASH_CNT		50021
#endif

#if defined(PI)
#define CALL_SESS_CNT		350003
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        10007
#define HTTP_TRANS_CNT		50021
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       10007
#define IHTTP_TRANS_CNT		50021
#define INET_HASH_CNT		50021
#endif

#if defined(PIOLD)
#define CALL_SESS_CNT		500009
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        50021
#define HTTP_TRANS_CNT		200003
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       25013
#define IHTTP_TRANS_CNT		130003
#define INET_HASH_CNT		130003
#endif

#if !defined(RP) && !defined(PI) && !defined(PIOLD)
#define CALL_SESS_CNT		350003
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        10007
#define HTTP_TRANS_CNT		50021
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       10007
#define IHTTP_TRANS_CNT		50021
#define INET_HASH_CNT		50021
#endif

#endif

#if !defined(COMMERCIALLOG)

#if defined(RP)
#define CALL_SESS_CNT		350003
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        10007
#define HTTP_TRANS_CNT		50021
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       10007
#define IHTTP_TRANS_CNT		50021
#define INET_HASH_CNT		50021
#endif

#if defined(PI)
#define CALL_SESS_CNT		350003
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        10007
#define HTTP_TRANS_CNT		50021
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       10007
#define IHTTP_TRANS_CNT		50021
#define INET_HASH_CNT		50021
#endif

#if defined(PIOLD)
#define CALL_SESS_CNT		500009
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        50021
#define HTTP_TRANS_CNT		200003
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       25013
#define IHTTP_TRANS_CNT		130003
#define INET_HASH_CNT		130003
#endif

#if !defined(RP) && !defined(PI) && !defined(PIOLD)
#define CALL_SESS_CNT		350003
#define VT_SESS_CNT			5003
#define IM_SESS_CNT			5003
#define TCP_SESS_CNT        10007
#define HTTP_TRANS_CNT		50021
#define DNS_SESS_CNT		5003
#define ITCP_SESS_CNT       10007
#define IHTTP_TRANS_CNT		50021
#define INET_HASH_CNT		50021
#endif

#endif

/* TIMER */
#define DEF_TCP_SESSUPDATE      110
#define DEF_CALL_TIMEOUT        250
#define DEF_CLEAR_TIMEOUT		15
#define DEF_MSG_TIMEOUT 		10
#define DEF_VT_TIMEOUT   	    60
#define DEF_IM_TIMEOUT   	    60 
#define DEF_WAIT_TIMEOUT        7
#define DEF_TCP_RSTWAIT     	1
#define DEF_TCP_TIMEOUT     	120
#define DEF_RP_TIMOUT			250
#define DEF_DNS_TIMEOUT			5	
#define DEF_PDSNDORM_TIMEOUT	10800

/* 구조체 멤버들의 길이 */
#define MAX_BROWSERINFO_SIZE			11
#define MAX_BROWSERINFO_LEN				(MAX_BROWSERINFO_SIZE - 1)
#define MAX_MODEL_SIZE					17
#define MAX_MODEL_LEN					(MAX_MODEL_SIZE - 1)
#define MAX_SVCOPTION_SIZE				8
#define MAX_SVCOPTION_LEN				(MAX_SVCOPTION_SIZE - 1)
#define MAX_MIN_SIZE					16
#define MAX_MIN_LEN						(MAX_MIN_SIZE - 1)
#define MAX_HOSTNAME_SIZE				41
#define MAX_HOSTNAME_LEN				(MAX_HOSTNAME_SIZE - 1)
#define MAX_PROTOCOL_SIZE				11
#define MAX_PROTOCOL_LEN				(MAX_HOSTNAME_SIZE - 1)
#define MAX_LOGURL_SIZE					1025
#define MAX_LOGURL_LEN					(MAX_LOGURL_SIZE - 1)
#define MAX_URL_SIZE					556
#define MAX_URL_LEN						(MAX_URL_SIZE - 1)
#define MAX_IURL_SIZE					257
#define MAX_IURL_LEN					(MAX_IURL_SIZE - 1)
#define MAX_CONTENTSTYPE_SIZE			37
#define MAX_CONTENTSTYPE_LEN			(MAX_CONTENTSTYPE_SIZE - 1)
#define MAX_APPFAILCODE_SIZE			6
#define MAX_APPFAILCODE_LEN				(MAX_APPFAILCODE_SIZE - 1)
#define MAX_CPNAME_SIZE					9
#define MAX_CPNAME_LEN					(MAX_CPNAME_SIZE - 1)
#define MAX_SERVICECODE_SIZE			33
#define MAX_SERVICECODE_LEN				(MAX_SERVICECODE_SIZE - 1)
#define MAX_MENUTITLE_SIZE				33
#define MAX_MENUTITLE_LEN				(MAX_MENUTITLE_SIZE - 1)
#define MAX_MENUID_SIZE					11
#define MAX_MENUID_LEN					(MAX_MENUID_SIZE - 1)
#define MAX_SVCACTION_SIZE				16
#define MAX_SVCACTION_LEN				(MAX_SVCACTION_SIZE - 1)
#define MAX_CONTENTID_SIZE				11
#define MAX_CONTENTID_LEN				(MAX_CONTENTID_SIZE - 1)
#define MAX_CATID_SIZE					11
#define MAX_CATID_LEN					(MAX_CATID_SIZE - 1)
#define MAX_APPLICATION_SIZE       		11
#define MAX_APPLICATION_LEN        		(MAX_APPLICATION_SIZE - 1)
#define MAX_EXTVERSION_SIZE          	11
#define MAX_EXTVERSION_LEN         		(MAX_EXTVERSION_SIZE - 1)
#define MAX_BSCID_SIZE               	6
#define MAX_BSCID_LEN              		(MAX_BSCID_SIZE - 1)
#define MAX_BESTPN_SIZE              	6
#define MAX_BESTPN_LEN             		(MAX_BESTPN_SIZE - 1)
#define MAX_MNC_SIZE                 	3
#define MAX_MNC_LEN                		(MAX_MNC_SIZE - 1)
#define MAX_COMPATIBLE_SIZE				1024
#define MAX_COMPATIBLE_LEN				(MAX_COMPATIBLE_SIZE - 1)
#define MAX_CONTENTCODE_SIZE			17
#define MAX_CONTENTCODE_LEN				(MAX_CONTENTCODE_SIZE - 1)
#define MAX_CPCODE_SIZE					9
#define MAX_CPCODE_LEN					(MAX_CPCODE_SIZE - 1)
#define MAX_MSMAN_SIZE					17
#define MAX_MSMAN_LEN					(MAX_MSMAN_SIZE - 1)
#define MAX_VODSESSID_SIZE				25
#define MAX_VODSESSID_LEN				(MAX_VODSESSID_SIZE - 1)
#define MAX_TRANSID_SIZE				33
#define MAX_TRANSID_LEN					(MAX_TRANSID_SIZE - 1)
#define MAX_CLIVER_SIZE					11
#define MAX_CLIVER_LEN					(MAX_CLIVER_SIZE - 1)
#define MAX_SMTPSVR_SIZE				65
#define MAX_SMTPSVR_LEN					(MAX_SMTPSVR_SIZE - 1)
#define MAX_POP3SVR_SIZE				65
#define MAX_POP3SVR_LEN					(MAX_POP3SVR_SIZE - 1)
#define MAX_COMMAND_SIZE                256
#define MAX_COMMAND_LEN                 (MAX_COMMAND_SIZE - 1)
#define MAX_PCODE_SIZE					32	
#define MAX_PCODE_LEN					(MAX_PCODE_SIZE - 1)
#define MAX_MSGTYPE_SIZE				11	
#define MAX_MSGTYPE_LEN					(MAX_MSGTYPE_SIZE - 1)
#define MAX_CHAP_SIZE 					128
#define MAX_CHAP_LEN 					(MAX_CHAP_SIZE - 1)
#define MAX_LCPCONFREQ_SIZE				128
#define MAX_LCPCONFREQ_LEN 				(MAX_CHAP_SIZE - 1)

/* FOR DIAMETER */
#define MAX_SIPURI_SIZE					64
#define MAX_SIPURI_LEN					(MAX_SIPURI_SIZE - 1)
#define MAX_HOST_REALM_SIZE 			64
#define MAX_HOST_REALM_LEN 				(MAX_HOST_REALM_SIZE - 1)
#define MAX_SESSIONID_SIZE 				128
#define MAX_SESSIONID_LEN 				(MAX_SESSIONID_SIZE - 1)

#define MAX_AUTHUSERNAME_LEN			32
#define MAX_USERNAME_LEN				64



#define STG_OVER_INC(OP1, COMPARE, TO) { if(OP1 == COMPARE) (*TO)++; }

/* 구조체 번호 */
<TAG_DEFINE_START:CALL_INPUT>
#define CAP_HEADER_NUM				1
#define ETH_DATA_NUM				2
#define INFO_ETH_NUM				3
#define TCP_DATA_NUM				4
#define HTTP_REQ_HDR_NUM			5
#define HTTP_REQ_BODY_NUM			6
#define HTTP_RES_HDR_NUM			7
#define HTTP_RES_BODY_NUM			8
#define SCTP_DATA_NUM				9
#define RADIUS_DATA_NUM 			10 		
#define CLEAR_CALL_NUM 				11 		
#define START_CALL_NUM				12 		/* A11 Regi Request Start */
#define STOP_CALL_NUM				13 		/* A11 Regi Request Stop */
#define RADIUS_START_NUM			14  	/* RADIUS ACCOUNTING REQ START SIGNAL */
#define LOG_PISIGNAL_DEF_NUM		15 		/* RADIUS 트랜잭션 로그 */
#define START_SERVICE_DEF_NUM		16
#define TIMER_STOP_CALL_NUM			17
#define SI_DB_DEF_NUM				50
#define WATCHMSG_DEF_NUM			51
#define SVCMONMSG_DEF_NUM			52 
#define START_PI_DATA_RECALL_NUM	60 		/* PI TCP DATA에 의해 생성되는 시그널 */
#define START_RP_DATA_RECALL_NUM	61 		/* RP GRE DATA에 의해 생성되는 시그널 */
#define START_PI_SIG_RECALL_NUM		62 		/* PI Accounting Request 에 의해 생성되는 시그널 */
#define START_RP_SIG_RECALL_NUM		63 		/* RP A11 Regi Request 에 의해 생성되는 시그널 */
#define STOP_PI_RECALL_NUM			64 		/* PI 호 종료 로직에 의해 생성되는 시그널 */
#define STOP_RP_RECALL_NUM			65 		/* PI 호 종료 로직에 의해 생성되는 시그널 */
<TAG_DEFINE_END:CALL_INPUT>

/* 프로토콜 정의 */
#define DEF_PROTOCOL_TCP			6
#define DEF_PROTOCOL_UDP			17 
#define DEF_PROTOCOL_A11			120
#define DEF_PROTOCOL_RADIUS			121
#define DEF_PROTOCOL_DIAMETER		122
#define DEF_PROTOCOL_SCTP			132
#define DEF_PROTOCOL_GRE			47
#define DEF_PROTOCOL_L2TP			115

/* 프로토콜 PORT 정의 */
#define DEF_PROTOCOL_DNS_PORT		53

/* 메세지 타입 */
#define DEF_MSG_ACCESS 				0
#define DEF_MSG_ACCREQ_START 		1
#define DEF_MSG_ACCREQ_STOP 		2
#define DEF_MSG_ACCREQ_INTERIM 		3
#define DEF_MSG_ACCREQ_LINKSTART 	12
#define DEF_MSG_ACCREQ_LINKSTOP 	13

#define DEF_BSMSD_LENGTH        	13

/* L2TP SIGNAL MESSSAGE DEFINITION */
#define MSG_L2TP_TUNNEL_START 		1
#define MSG_L2TP_TUNNEL_STOP 		4
#define MSG_L2TP_TUNNEL_INTERIM 	6
#define MSG_L2TP_CALL_START 		10
#define MSG_L2TP_CALL_STOP 			14

#define ROAM_NASIP_BASE				30

/**
 * @brief LOG_COMMON : LOG TABLE에 들어가는 COMMON KEY 값
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_COMMON typedef struct _stg_log_common {
	STIME 		uiCallTime:STG_Equal(pLOG_COMMON->uiCallTime):FIRST;
	MTIME		uiCallMTime:STG_Equal(pLOG_COMMON->uiCallMTime):FIRST;
	STIME 		uiAccStartTime:STG_Equal(pLOG_COMMON->uiAccStartTime):FIRST;
	MTIME		uiAccStartMTime:STG_Equal(pLOG_COMMON->uiAccStartMTime):FIRST;

	STRING		szModel[MAX_MODEL_SIZE]: STG_Equal( pLOG_COMMON->szModel): FIRST;	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<USER_AGENT>{STR}:^^:Get_Detailed_User_Agent# 
				ALTERNATIVE_RULE		#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<PHONEMODEL>{STR}#

	IP4			uiNASName: STG_Equal(pLOG_COMMON->uiNASName): FIRST;
	U8			ucFA_ID: STG_Equal(pLOG_COMMON->ucFA_ID): FIRST;
	U8			ucSECTOR: STG_Equal(pLOG_COMMON->ucSECTOR): FIRST;
	U8			ucSYSID: STG_Equal(pLOG_COMMON->ucSYSID): FIRST;
	U8			ucBSCID: STG_Equal(pLOG_COMMON->ucBSCID): FIRST;
	U16			ucBTSID: STG_Equal(pLOG_COMMON->ucBTSID): FIRST;
	STRING		szBSMSC[DEF_BSMSD_LENGTH]: STG_Equal(pLOG_COMMON->szBSMSC): FIRST;

	STRING		szMIN[MAX_MIN_SIZE]: STG_Equal( pLOG_COMMON->szMIN): FIRST;		#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<USER_AGENT>{STR}:^^:Get_Detailed_User_Agent# @CHECKING_VALUE:01@
				ALTERNATIVE_RULE		#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<FROM>{VALUE11}:^^:PARSING_MIN_Change1#
				ALTERNATIVE_RULE		#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<MIN>{VALUE11}:^^:PARSING_MIN_Change1#
				ALTERNATIVE_RULE		#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<PHONENUMBER>{VALUE11}:^^:PARSING_MIN_Change1#
	STRING		szNetOption[MAX_SVCOPTION_SIZE]: STG_Equal( pLOG_COMMON->szNetOption): FIRST;	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<USER_AGENT>{STR}:^^:Get_Detailed_User_Agent#	
	STRING		szBrowserInfo[MAX_BROWSERINFO_SIZE]: STG_Equal( pLOG_COMMON->szBrowserInfo): FIRST;	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<USER_AGENT>{STR}:^^:Get_Detailed_User_Agent# 
<TAG_KEY>
	IP4 		uiClientIP:STG_Equal(pLOG_COMMON->uiClientIP):FIRST;		@CHECKING_VALUE:10. , 61.@
</TAG_KEY>
	STRING		szIMSI[MAX_MIN_SIZE]: STG_Equal( pLOG_COMMON->szIMSI): FIRST;
	U16			usServiceType: STG_Equal(pLOG_COMMON->usServiceType): FIRST;	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<USER_AGENT>{STR}:^^:Get_Detailed_User_Agent#
	STRING		szHostName[MAX_HOSTNAME_SIZE]: STG_Equal(pLOG_COMMON->szHostName): FIRST;	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<HOST>{ID}#	
	IP4			uiPCFIP: STG_Equal(pLOG_COMMON->uiPCFIP): FIRST;
	U8 			ucBranchID: STG_Equal(pLOG_COMMON->ucBranchID): FIRST;
} LOG_COMMON;

#define MAX_STRING_SIZE     256


/* OFFSET 보정 */
#define	YES									1
#define	NO									0
#define	MAX_SEQUENCE						0xffffffff
#define	MAX_VALID_OFFSET					((unsigned int) (MAX_SEQUENCE / 2))
#define	OFFSET_SEQ(VALID_SEQ, NOW_SEQ)		((VALID_SEQ <= NOW_SEQ) ? (NOW_SEQ - VALID_SEQ) : (MAX_SEQUENCE + 1 + NOW_SEQ - VALID_SEQ))
#define	NEXT_SEQ(SEQ, offset)				((SEQ+offset) % (MAX_SEQUENCE+1))
#define	IS_VALID_SEQ(VALID_SEQ, NOW_SEQ)	((OFFSET_SEQ(VALID_SEQ, NOW_SEQ) < MAX_VALID_OFFSET) ? YES : NO)

/**
 *	PRE_A, A_HTTP에서 서비스를 구분하기 위한 Filter 정보를 관리 하기 위함
 *
 *	######################################################################################################
 *	- PRE_A Hash Key, Value 설명
 *		2개의 Hash를 구성
 *		1) Hash Key: Server IP, Server Port
 *		   Hash Data: L4Code, AppCode
 *		2) Hash Key: Server IP
 *		   Hash Data: L4Code, AppCode
 *
 *		1)번 Hash를 체크한 후에 없는 경우에 2)번 Hash를 체크한다.
 *
 *		configure file format
 *			ServerIP		ServerPort	L4Code					AppCode
 * 		EX)	192.168.1.2		8080		VODSTREAMMING:11		A_VOD:3		<= 1)번 Hash 구성
 *			192.168.1.2		0			VODDOWN:13				A_DOWN:4	<= 2)번 Hash 구성 (Port = 0)
 *		=> Port = 0 인 경우를 2)번 Hash로 구성한다.
 *
 *	######################################################################################################
 *	- A_HTTP Hash Key, Value 설명
 *		4개의 Hash를 구성
 *		1) Hash Key: Method
 *		   Hash Data: L7Code, AppCode
 *		2) Hash Key: Host Name, Contents-type, Redirect_Protocol
 *		   Hash Data: L7Code, AppCode
 *		3) Hash Key: Host Name, Contents-type
 *		   Hash Data: L7Code, AppCode
 *		4) Hash Key: Host Name
 *		   Hash Data: L7Code, AppCode
 *
 *		Hash 체크 순서는 Hahs 순서와 동일 하며, 순위가 낮은 곳에서 찾는 경우 다음 Hash를 체크 하지 않는다.
 *
 *		=> Redirect_Protocol은 VOD DOWN, STREAMMING을 구분하기 위한 Body의 URL Protocol값 (예외처리)
 *		
 *		configure file format
 *			Method	Host Name				Contents-type		Redirect_Protocol	L7Code				AppCode
 *		EX)	*		m.dosirak.com			audio/k3g			HTTP				DOSIRAKDOWN:21		A_DSR:5
 *			*		m.dosirak.com			audio/k3g			RTSP				DOSIRAKSTREAM:22	A_DSR:5
 *			*		ktfwipidc.magicn.com	*					*					WIPI_MENU_DOWN:23	A_WIPI:11
 *			*		kt68dddsvr.magicn.com	*					*					BREW_MENU_DOWN:23	A_BREW:11
 *			*		me_kun.magicn.com		application/ndwn	*					ME_KUN_NDWN:23		A_MEKUN:11
 *			*		me_kun.magicn.com		html/text			*					ME_KUN_MENU:23		A_MEKUN:11
 *			CONNECT	*						*					*					SSL:100				A_SSL:40
 *			RESULT	*						*					*					SSL:100				A_SSL:40
 *			
 *		=> * 표시는 Hash Key에 포함되지 않음
 *  #####################################################################################################
 *
 *
 **/

<TAG_AUTO_STRING_DEFINE_START:SVCACTION(400)> $CASE_IGNORE$
getfile				SVCACTION_GETFILE
1310				SVCACTION_1310		(1310)
1330				SVCACTION_1330		(1330)   
1300				SVCACTION_1300		(1300)   
1600				SVCACTION_1600		(1600)   
1610				SVCACTION_1610		(1610)   
1640				SVCACTION_1640		(1640)   
3300				SVCACTION_3300		(3300)   
<TAG_AUTO_STRING_DEFINE_END:SVCACTION>

<TAG_AUTO_STRING_DEFINE_START :METHOD(1)>
GET				METHOD_GET				
POST			METHOD_POST			
HEAD			METHOD_HEAD
PUT 			METHOD_PUT
OPTIONS 		METHOD_OPTIONS
DELETE 			METHOD_DELETE
TRACE 			METHOD_TRACE
CONNECT 		METHOD_CONNECT
RESULT 			METHOD_RESULT
DESCRIBE 		METHOD_DESCRIBE
SETUP 			METHOD_SETUP
PLAY 			METHOD_PLAY
PAUSE 			METHOD_PAUSE
ANNOUNCE 		METHOD_ANNOUNCE
GET_PARAMETER 	METHOD_GET_PARAMETER
RECORD 			METHOD_RECORD
REDIRECT 		METHOD_REDIRECT
SET_PARAMETER 	METHOD_SET_PARAMETER
TEARDOWN 		METHOD_TEARDOWN
<TAG_AUTO_STRING_DEFINE_END:METHOD>

<TAG_AUTO_DEFINE_START:REDIRECT(200)>
REDIRECT_HTTP
REDIRECT_RTSP
<TAG_AUTO_DEFINE_END:REDIRECT>

<TAG_AUTO_DEFINE_START :RPPIFLAG(500)>
RP_FLAG
PI_FLAG
<TAG_AUTO_DEFINE_END:RPPIFLAG>

<TAG_AUTO_DEFINE_START :SYSTYPE(600)>
TYPE_PCF 				(5)
TYPE_PDSN
TYPE_AAA
TYPE_HSS
TYPE_LNS
TYPE_SVC 				(10)
TYPE_CSCF
TYPE_MNIP
TYPE_LAC
TYPE_CRX
TYPE_PDIF
<TAG_AUTO_DEFINE_END:SYSTYPE>

<TAG_AUTO_DEFINE_START :DIRECTION(0)>
DIR_UP					(1)
DIR_DOWN
<TAG_AUTO_DEFINE_END:DIRECTION>

<TAG_AUTO_DEFINE_START :L4CODE(400)>
L4_UNKNOWN				(0)
L4_WAP20				(1100)
L4_TODAY				(1200)
L4_WIPI					(2100)
L4_WIPI_ONLINE			(2200)
L4_DN_2G				(3100)
L4_DN_2G_NODN			(3101)
L4_DN_JAVA				(3200)
L4_DN_VOD				(3300)
L4_DN_VOD_NODN			(3301)
L4_OMA_DN				(3400)
L4_OMA_DN_2G			(3500)
L4_OMA_DN_VOD			(3600)
L4_OMA_DN_WIPI			(3700)
L4_VOD_STREAM			(4100)
L4_RTS_FB				(4200)
L4_RTS_WB				(4300)
L4_MMS_UP				(5100)
L4_MMS_UP_NODN			(5101)
L4_MMS_DN				(5200)
L4_MMS_DN_NODN			(5201)
L4_MMS_NEW				(5300)
L4_JNC					(6100)
L4_FB					(7100)
L4_IV					(8100)
L4_EMS					(9100)
L4_P_EMS				(9101)
L4_EMS_NO				(9102)
L4_FV_FB				(10100)
L4_FV_EMS				(10200)
L4_FV_IV				(10300)
L4_SIP_MS				(11100)
L4_SIP_VENDOR			(11101)
L4_SIP_CSCF				(11102)
L4_MSRP_MS				(11200)
L4_MSRP_VENDOR			(11201)
L4_XCAP					(11300)
L4_MBOX					(12100)
L4_BANKON				(12200)
L4_VMBANK				(12300)
L4_WIDGET				(13100)
L4_WIDGET_NODN			(13101)
L4_VT					(14100)
L4_PHONE				(15000)
L4_PHONE_ETC			(15100)
L4_FTP                  (15200)
L4_DNS					(15300)
L4_CORP 				(16000)
L4_INET_TCP_USER 		(60100)
L4_INET_HTTP_USER		(60200)
L4_INET_TCP 			(60300)
L4_INET_TCP_RECV 		(60400)
L4_INET_HTTP 			(60500)
L4_INET_HTTP_RECV 		(60600)
<TAG_AUTO_DEFINE_END:L4CODE>

<TAG_AUTO_DEFINE_START :L7CODE(1)>
APP_UNKNOWN				(0)
APP_MENU
APP_DOWN
APP_STREAM
APP_MMS
APP_JNC
APP_ONLINE
APP_ETC					(9)
APP_FV_DOC
APP_FV_PAGE
APP_FV_SAVE
APP_EMS_SRVADD
APP_EMS_SRVMOD
APP_EMS_SRVDEL
APP_EMS_SPAMADD
APP_EMS_SPAMDEL
APP_EMS_RCVTIME
APP_EMS_NEWMAIL			(19)
APP_EMS_BODY
APP_EMS_SEND
APP_EMS_ACK
APP_EMS_SYNC
APP_IM_UP
APP_IM_DN
APP_WIDGET_UTI			(30)
APP_WIDGET_SSD
APP_WIDGET_PID
APP_WIDGET_SWD
APP_WIDGET_DWD
APP_WIDGET_WSC
APP_WIDGET_WAC
APP_WIDGET_WMU
APP_WIDGET_WCD
APP_WIDGET_WDL
APP_WIDGET_WIN
APP_PHONE
APP_FTP
APP_DNS
<TAG_AUTO_DEFINE_END:L7CODE>

<TAG_AUTO_DEFINE_START :MSGQKEY(14000)>
<TAG_AUTO_DEFINE_END:MSGQKEY>

<TAG_AUTO_DEFINE_START :SEQ_PROC(0)>
<TAG_AUTO_DEFINE_END:SEQ_PROC>

<TAG_AUTO_DEFINE_START :SSHMKEY(15000)>
<TAG_AUTO_DEFINE_END:SSHMKEY>

<TAG_AUTO_DEFINE_START :SEMAKEY(11000)>
<TAG_AUTO_DEFINE_END:SEMAKEY>

/*******************************************************
 * 구간 정보
 *******************************************************/
<TAG_AUTO_DEFINE_START :RANGE(10)>
RANGE_AS
RANGE_CSCF
RANGE_INET
<TAG_AUTO_DEFINE_END:RANGE>

/* TAG_AUTO_STRING_DEFINE 에서 뽑아내야 할 값들 
   ==> define TYPE_DESC      101     
   ... 등의 define된 값들
   Print_ContentsType(101) -> print the "application/vnd.oma.dd" string
   Get_Define_ContentsType(char *s); ==> return TYPE_DESC;
 */
<TAG_AUTO_STRING_DEFINE_START:ContentsType(400)>			 $CASE_IGNORE$ 
application/vnd.oma.dd                  CTYPE_DESC          /* ?? */
text/html                               CTYPE_HTML
text/x-html                             CTYPE_HTML
text/xml                                CTYPE_XML
text/vnd.wap.wml                        CTYPE_WML
application/xhtml+xml                   CTYPE_WML
text/css                                CTYPE_STYLE
text/plain                              CTYPE_LMSG
image/sis                               CTYPE_SIS
map/sis                                 CTYPE_SIS
application/ndwn                        CTYPE_NDWN
application/vnd-qualcomm.qis.pkg        CTYPE_BREWDOWN
application/x-msdownload                CTYPE_WIPIDOWN
audio/ma2                               CTYPE_MA2
audio/ma3                               CTYPE_MA3
audio/ma5                               CTYPE_MA5
audio/k3g                               CTYPE_VOD
video/k3g                               CTYPE_VOD
audio/ak3g                              CTYPE_VOD
video/ak3g                              CTYPE_VOD
application/x-skt-lbs                   CTYPE_SOUND
application/x-smaf                      CTYPE_SOUND
application/vnd.smaf                    CTYPE_SOUND
application/sdp                    		CTYPE_SDP
multipart/                              CTYPE_MMSG
application/                            CTYPE_APPLICATION
text/                                   CTYPE_TEXT
image/                                  CTYPE_IMAGE
audio/                                  CTYPE_SOUND
multipart/								CTYPE_MULTI
application/x-shockwave-flash			CTYPE_FLASH
application/javascript					CTYPE_JS
application/x-javascript				CTYPE_JS
<TAG_AUTO_STRING_DEFINE_END:ContentsType>

#define CONF_CNT			211
#define CONF_PREA_CNT		1601

/**
 * @brief L4_MNIP : IP 로 유효한 단말인지 판단 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_CONF_MN {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:MN			\([ \t]*MN
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
    IP4     CIP;          #PARSING_RULE:^^:GRASP:^^:<MN>IP={VALUE}#
	DEF		<TAG_DEFINE:RANGE>range;			#PARSING_RULE:^^:GRASP:^^:<MN>RANGE={VALUE}#	
</TAG_KEY>

    U32     NetMask;        #PARSING_RULE:^^:GRASP:^^:<MN>Mask={VALUE}#
} MN_CONF;


/**
 * @brief LPREA_CODE_KEY : IP, PORT로 서비스 구분을 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_LPREACode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LPREA		\([ \t]*LPREA
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
    IP4     SIP;          #PARSING_RULE:^^:GRASP:^^:<LPREA>ServerIP={VALUE}#
    U32     SPort;        #PARSING_RULE:^^:GRASP:^^:<LPREA>ServerPort={VALUE}#
	DEF     <TAG_DEFINE:RPPIFLAG>RpPiFlag;          #PARSING_RULE:^^:GRASP:^^:<LPREA>RpPiFlag={VALUE}#
</TAG_KEY>

    DEF     <TAG_DEFINE:L4CODE>L4Code;             	#PARSING_RULE:^^:GRASP:^^:<LPREA>L4Code={VALUE}#
    DEF     <TAG_DEFINE:MSGQKEY>AppCode;    		#PARSING_RULE:^^:GRASP:^^:<LPREA>AppCode={VALUE}#
    DEF     <TAG_DEFINE:L7CODE>L7Code;             	#PARSING_RULE:^^:GRASP:^^:<LPREA>L7Code={VALUE}#
	DEF		<TAG_DEFINE:SYSTYPE>SysType;			#PARSING_RULE:^^:GRASP:^^:<LPREA>SysType={VALUE}#
    U32     NetMask;        #PARSING_RULE:^^:GRASP:^^:<LPREA>Mask={VALUE}#
} LPREA_CONF;

STG_LOG_TEXT_PARSING typedef struct _st_LPREASCTPCode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE               GRASP:^^:LPREA      \([ \t]*LPREA
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
    IP4     SIP;          #PARSING_RULE:^^:GRASP:^^:<LPREA>ServerIP={VALUE}#
</TAG_KEY>

    DEF     <TAG_DEFINE:SYSTYPE>SysType;            #PARSING_RULE:^^:GRASP:^^:<LPREA>SysType={VALUE}#
    DEF     <TAG_DEFINE:DIRECTION>Direction;        #PARSING_RULE:^^:GRASP:^^:<LPREA>Direction={VALUE}#
    U16     GroupID;        #PARSING_RULE:^^:GRASP:^^:<LPREA>GroupID={VALUE}#
} LPREA_SCTP;

typedef struct _st_Dns_Sess {
	DEF             <TAG_DEFINE:PLATFORMTYPE>usPlatformType;        /**< usSvcL4Type / 1000 * 1000 */
    DEF             <TAG_DEFINE:L4CODE>usSvcL4Type;                 /**< IP, PORT로 판단한 Service type */
    DEF             <TAG_DEFINE:L7CODE>usSvcL7Type;                 /**< URL, HostName으로 판단한 Service type */

	U64		timerNID;

	U16		usIdentification;
	U8		ucErrorCode;

	STIME	dRequestTime;
	MTIME	dRequestMTime;
	STIME	dResponseTime;
	MTIME	dResponseMTime;

	U16		usRequestCnt;
	U16		usResponseCnt;

	U32		uiRequestSize;
	U32		uiResponseSize;

	U32		uiTotLength;
	U32		uiCurLength;

	OFFSET	offset_Prev;	
} DNS_SESS;

typedef struct _st_Dns_Sess_Key {
	IP4     SIP;
    IP4     DIP;
    U16     usSPort;
    U16     usDPort;
} DNS_SESS_KEY;	
	

/**
 * @brief LHTTPHOST_CODE_KEY : HOST, Content-Type, Redirect Protocol, METHOD로 서비스 구분을 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_LHTTPHOSTCode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LHTTPHOST			\([ \t]*LHTTPHOST
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
	STRING			szHost[MAX_HOSTNAME_SIZE];		/**< Host Name */ #PARSING_RULE:^^:GRASP:^^:<LHTTPHOST>Host={VALUE}#
</TAG_KEY>
	DEF				<TAG_DEFINE:L4CODE>NewL4Code;		#PARSING_RULE:^^:GRASP:^^:<LHTTPHOST>NEWL4Code={VALUE}#
	DEF				<TAG_DEFINE:MSGQKEY>AppCode;					/**< 처리 프로세스 ID */ #PARSING_RULE:^^:GRASP:^^:<LHTTPHOST>AppCode={VALUE}#
} LHTTPHOST_CONF;

/**
 * @brief LHTTPMETHOD_CODE_KEY : HOST, Content-Type, Redirect Protocol, METHOD로 서비스 구분을 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_LHTTPMETHODCode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LHTTPMETHOD			\([ \t]*LHTTPMETHOD
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
	DEF		<TAG_DEFINE:METHOD>Method;			#PARSING_RULE:^^:GRASP:^^:<LHTTPMETHOD>Method={VALUE}#
</TAG_KEY>
	DEF				<TAG_DEFINE:L7CODE>L7Code;		#PARSING_RULE:^^:GRASP:^^:<LHTTPMETHOD>L7Code={VALUE}#
	DEF				<TAG_DEFINE:MSGQKEY>AppCode;					/**< 처리 프로세스 ID */ #PARSING_RULE:^^:GRASP:^^:<LHTTPMETHOD>AppCode={VALUE}#
} LHTTPMETHOD_CONF;
/**
 * @brief LMEKUN : Contents_Type로 서비스 구분을 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_LMEKUN_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LMEKUN		\([ \t]*LMEKUN
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
	DEF				<TAG_DEFINE:ContentsType>ContentType;					/**< Content Type 추후 정의 */ #PARSING_RULE:^^:GRASP:^^:<LMEKUN>Contents_Type={VALUE}#
</TAG_KEY>

    DEF     <TAG_DEFINE:L7CODE>L7Code;             #PARSING_RULE:^^:GRASP:^^:<LMEKUN>L7Code={VALUE}#
    DEF     <TAG_DEFINE:MSGQKEY>AppCode;    #PARSING_RULE:^^:GRASP:^^:<LMEKUN>AppCode={VALUE}#
} LMEKUN_CONF;

STG_LOG_TEXT_PARSING typedef struct _st_LVODCode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LVOD			\([ \t]*LVOD
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
	DEF				<TAG_DEFINE:ContentsType>uiContentType;					/**< Content Type 추후 정의 */ #PARSING_RULE:^^:GRASP:^^:<LVOD>Contents_Type={VALUE}#
	DEF				<TAG_DEFINE:REDIRECT>Redirect_Protocol;	/**< Redirect Protocol */ #PARSING_RULE:^^:GRASP:^^:<LVOD>Redirect_Protocol={VALUE}#
</TAG_KEY>
	DEF				<TAG_DEFINE:L7CODE>L7Code;		#PARSING_RULE:^^:GRASP:^^:<LVOD>L7Code={VALUE}#
	DEF				<TAG_DEFINE:MSGQKEY>AppCode;					/**< 처리 프로세스 ID */ #PARSING_RULE:^^:GRASP:^^:<LVOD>AppCode={VALUE}#
} LVOD_CONF;

STG_LOG_TEXT_PARSING typedef struct _st_LBREWCode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LBREW			\([ \t]*LBREW
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
	DEF				<TAG_DEFINE:SVCACTION>URL;					/**< Content Type 추후 정의 */ #PARSING_RULE:^^:GRASP:^^:<LBREW>URL={VALUE}#
</TAG_KEY>
	DEF				<TAG_DEFINE:L7CODE>L7Code;		#PARSING_RULE:^^:GRASP:^^:<LBREW>L7Code={VALUE}#
	DEF				<TAG_DEFINE:MSGQKEY>AppCode;					/**< 처리 프로세스 ID */ #PARSING_RULE:^^:GRASP:^^:<LBREW>AppCode={VALUE}#
} LBREW_CONF;

STG_LOG_TEXT_PARSING typedef struct _st_LWIPICode_Key {
    LINEFEED            [ \t]*(\)\r\n)
    FORMFEED            [ \t]*\)
    STATE				GRASP:^^:LWIPI			\([ \t]*LWIPI
    TOKEN   ID                  [^<> \t\r\n]+
    TOKEN   VALUE               [^=&: \t\r\n]+
    TOKEN   DIGIT               [ \t]*[0-9]+

<TAG_KEY>
	DEF				<TAG_DEFINE:SVCACTION>URL;					/**< Content Type 추후 정의 */ #PARSING_RULE:^^:GRASP:^^:<LWIPI>URL={VALUE}#
</TAG_KEY>
	DEF				<TAG_DEFINE:L7CODE>L7Code;		#PARSING_RULE:^^:GRASP:^^:<LWIPI>L7Code={VALUE}#
	DEF				<TAG_DEFINE:MSGQKEY>AppCode;					/**< 처리 프로세스 ID */ #PARSING_RULE:^^:GRASP:^^:<LWIPI>AppCode={VALUE}#
} LWIPI_CONF;

/**
 *
 *		TCP
 *
 */

/**
 * @brief TCP_SESS_KEY : TCP 세션 관리를 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
typedef struct _st_TCP_SESS_KEY {
	IP4				uiSIP;				/**< Source IP */
	IP4				uiDIP;				/**< Destination IP */
	U16				usSPort;			/**< Source Port */
	U16				usDPort;			/**< Destination Port */
} TCP_SESS_KEY;

<TAG_DEFINE_START:RTX>
#define DEF_FROM_NONE		0
#define DEF_FROM_CLIENT     1			/**< UP : From Client */
#define DEF_FROM_SERVER     2			/**< DOWN : From Server */
<TAG_DEFINE_END:RTX>	

#define DEF_ARRAY_RTX		3

<TAG_DEFINE_START:STATUS>
#define DEF_STATUS_SYN		1
#define DEF_STATUS_SYNACK	2
#define DEF_STATUS_DATA		3
#define DEF_STATUS_ACK		4
<TAG_DEFINE_END:STATUS>

<TAG_DEFINE_START:FINSTATUS>
#define DEF_FIN_0			0			/**< FIN 이 없는 경우 */
#define DEF_FIN_1			1			/**< 첫번째 FIN 을 받은 경우 */
#define DEF_FIN_2			2			/**< 두번째 FIN 을 받은 경우 */
#define DEF_FIN_3			3			/**< 두번째 FIN 에 대한 ACK를 받은 경우 */
<TAG_DEFINE_END:FINSTATUS>

<TAG_DEFINE_START:ENDSTATUS>
#define DEF_END_NORMAL		1
#define DEF_END_ABNORMAL	2
#define DEF_END_LONGLAST	3
#define DEF_END_RST			4
<TAG_DEFINE_END:ENDSTATUS>

<TAG_DEFINE_START:L4FAILCODE>
#define TCP_SUCCESS						0
#define TCP_NOERR_FIN_E1				1
#define TCP_NOERR_FIN_E2				2
#define ABNORMAL_TRANS					15
#define LONGLAST_SYN_TRANS				31
#define LONGLAST_SYNACK_TRANS			32
#define LONGLAST_NOFIN_TRANS			33
#define LONGLAST_FIN_E1					34
#define LONGLAST_FIN_E2					35
#define TCP_ERR_RST_E1_SYN				41
#define TCP_ERR_RST_E1_SYNACK			42
#define TCP_ERR_RST_E1_NOFIN			43
#define TCP_ERR_RST_E1_FIN_E1			44
#define TCP_ERR_RST_E1_FIN_E2			45
#define TCP_ERR_RST_E2_SYN				51
#define TCP_ERR_RST_E2_SYNACK			52
#define TCP_ERR_RST_E2_NOFIN			53
#define TCP_ERR_RST_E2_FIN_E1			54
#define TCP_ERR_RST_E2_FIN_E2			55
<TAG_DEFINE_END:L4FAILCODE>

<TAG_DEFINE_START:SYN_RCV_FLAG>
#define SYN_RCV_OFF						0
#define SYN_RCV_ON						1
<TAG_DEFINE_END:SYN_RCV_FLAG>
 


/**
 * @brief TCP_SESS : TCP 세션 관리를 위한 구조체
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
typedef struct _st_TCP_SESS {
	STIME	uiLastUpdateTime;	/**< 초기값 생성시간, 이후 패킷받은 시간 */
	MTIME	uiLastUpdateMTime;	/**< 초기값 생성시간, 이후 패킷받은 시간 */
	STIME	uiSessCreateTime;	/**< 세션 생성 시간 */
	MTIME	uiSessCreateMTime;	/**< 세션 생성 시간 */

	STIME	uiLastSessUpdateTime;		/**< 마지막으로 A_CALL에 세션이 살아 있음을 알리는 메시지 보낸 시간 */

	U8		<TAG_DEFINE:STATUS>ucStatus;	/**< 세션 상태  */ 
	U8		<TAG_DEFINE:FINSTATUS>ucFinStatus; /**< 세션 종료 상태 */
	U8		<TAG_DEFINE:ENDSTATUS>ucEndStatus;	/**< 어떤 조건에 의해서 종료 되었는가? */
	U8		<TAG_DEFINE:RTX>ucSynRtx;			/**< Syn의 방향 */
	U8		<TAG_DEFINE:RTX>ucFinRtx;			/**< 첫번째 Fin의 방향 */
	U8		<TAG_DEFINE:RTX>ucRstRtx;			/**< Rst의 방향 */
	U8		<TAG_DEFINE:SYN_RCV_FLAG>ucRcvSyn;

	U32		uiSynSeq;		/**< TCP SYN SEQ No. */
	U32		uiSynAckSeq;	/**< TCP SYNACK SEQ No. */
	U32		uiSynAckAck;	/**< TCP SYNACK ACK No. */

	OFFSET 	offset_LOG;

	U32		uiReqCount;		/**< Request Packet Count */
	OFFSET	offset_ReqData;		/**< Request Packet First Node */

	U32		uiResCount;		/**< Response Packet Count */
	OFFSET	offset_ResData;		/**< Response Packet First Node */

	S32		dSndMsgQ;		/**< 보내야 할 서비스블럭의 메시지큐아이디...가 아니고, 보내야 할 블럭의 Sequence ID를 넣기로 한다. */
	U32		uiFinChkSeq[DEF_ARRAY_RTX];		/**< FIN PACKET의 재전송을 체크하기 위함 : Index = 0 은 사용하지 않음 */
	U32		uiFinChkAck[DEF_ARRAY_RTX];		/**< FIN PACKET에 대한 ACK PACKET 번호 : Index = 0 은 사용하지 않음 */

	U32		uiLastReqSeq;	/**< 마지막에 처리한 SEQ 번호 : REQ */
	U32		uiLastResSeq;	/**< 마지막에 처리한 SEQ 번호 : RES */

	U32		uiNextReqSeq;
	U32		uiNextResSeq;

	U32		uiRcvReqAck;
	U32		uiRcvResAck;

	STIME	uiRcvReqAckTime;
	MTIME	uiRcvReqAckMTime;

	STIME	uiRcvResAckTime;
	MTIME	uiRcvResAckMTime;

	U16		usL4Code;
	U16		usL7Code;
	U16		usAppCode;
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;

	U64		timerNID;

	U8		ucTcpClientStatus;
	U8		ucTcpServerStatus;

	U32		uiIPDataUpPktCnt;		/**< MN => Server, 데이터 전송 단계에서 패킷 개수 (전송후 Reset) */
	U32		uiIPDataDnPktCnt;		/**< Server => MN, 데이터 전송 단계에서 패킷 개수 (전송후 Reset) */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 (전송후 Reset) */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 (전송후 Reset) */
	U32		uiIPDataUpRetransCnt;	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPDataDnRetransCnt;	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPDataUpPktSize;		/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataDnPktSize;		/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataUpRetransSize;	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataDnRetransSize;	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 (전송후 Reset) */
} TCP_SESS;

<TAG_DEFINE_START:CLI>
#define DEF_CLI_SUCCESS			0
#define DEF_CLI_ETC				99
#define DEF_CLI_SYN				11
#define DEF_CLI_ACK				12
#define DEF_CLI_DATA			23
#define DEF_CLI_RST				34
#define DEF_CLI_FIN				35
#define DEF_CLI_FINACK			36
<TAG_DEFINE_END:CLI>
<TAG_DEFINE_START:SVR>
#define DEF_SVR_SUCCESS			0
#define DEF_SVR_ETC				99
#define DEF_SVR_SYNACK			11
#define DEF_SVR_DATA			22
#define DEF_SVR_RST				33
#define DEF_SVR_FIN				34
#define DEF_SVR_FINACK			35
<TAG_DEFINE_END:SVR>
<TAG_DEFINE_START:PLATFORMTYPE>
#define DEF_PLATFORM_MENU 		1000
#define DEF_PLATFORM_DN 		2000
#define DEF_PLATFORM_STREAM 	3000
#define DEF_PLATFORM_MMS 		4000
#define DEF_PLATFORM_WIDGET 	5000
#define DEF_PLATFORM_PHONE 		6000
#define DEF_PLATFORM_EMS 		7000
#define DEF_PLATFORM_BANK 		8000
#define DEF_PLATFORM_FV 		9000
#define DEF_PLATFORM_IM 		10000
#define DEF_PLATFORM_VT 		11000
#define DEF_PLATFORM_ETC 		12000
#define DEF_PLATFORM_CORP 	 	13000
#define DEF_PLATFORM_INET 	 	14000
<TAG_DEFINE_END:PLATFORMTYPE>

/**
 * @brief TCP_SESS_LOG : TCP 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_Tcp_Sess_Log {
	<STG_COMMON:LOG_COMMON>

	DEF		<TAG_DEFINE:PLATFORMTYPE>usPlatformType;	/**< PlatformType usSvcL4Type / 1000 * 1000 */
	DEF		<TAG_DEFINE:L4CODE>usSvcL4Type;				/**< Server IP, PORT로 판단한 Service type */
	U8		ucSubSysNo;					/**< Sub System No. */
	U16		usClientPort;				/**< 단말 Port */
	IP4		uiServerIP;					/**< Server IP */
	U16		usServerPort;				/**< Server Port */
	STIME	uiTcpSynTime;				/**< Tcp Syn Time */
	MTIME	uiTcpSynMTime;				/**< Tcp Syn Micro Time */
	STIME	uiTcpSynAckTime;			/**< Tcp SynAck Time */
	MTIME	uiTcpSynAckMTime;			/**< Tcp SynAck Micro Time */
	STIME	uiTcpSynAckAckTime;			/**< Syn => SynAck => Ack의 Ack Time */
	MTIME	uiTcpSynAckAckMTime;		/**< Syn => SynAck => Ack의 Ack Micro Time */
	S64		llConnSetupGapTime;			/**< TcpConnEndTime - CallTime */
	STIME	uiTcpFinTime;				/**< 첫번째 Tcp Fin, RST Time */
	MTIME	uiTcpFinMTime;				/**< 첫번째 Tcp Fin, RST Micro Time */
	STIME	uiTcpFinAckTime;			/**< 마지막 Tcp Fin Ack Time */
	MTIME	uiTcpFinAckMTime;			/**< 마지막 Tcp Fin Ack Micro Time */
	STIME	uiTcpUpLastPktTime;			/**< MN => Server, Last Packet Time */
	MTIME	uiTcpUpLastPktMTime;		/**< MN => Server, Last Packet Micro Time */
	STIME	uiTcpDnLastPktTime;			/**< Server => MN, Last Packet Time */
	MTIME	uiTcpDnLastPktMTime;		/**< Server => MN, Last Packet Micro Time */
	STIME	uiTcpLastPktTime;			/**< Last Packet Time */
	MTIME	uiTcpLastPktMTime;			/**< Last Packet Micro Time */
	S64		llTcpSessGapTime;			/**< Last Packet Time - CallTime */
	DEF		<TAG_DEFINE:CLI>ucTcpClientStatus;			/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>ucTcpServerStatus;			/**< 서버 상태 */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;		/**< TCP Fail Code */
	U8		ucTcpSynCnt;				/**< Syn Count */
	U8		ucTcpSynAckCnt;				/**< SynAck Count */
	U8		ucTcpUpFinCnt;				/**< MN => Server, Fin Count */
	U8		ucTcpDnFinCnt;				/**< Server => MN, Fin Count */
	U8		ucTcpUpRstCnt;				/**< MN => Server, Rst Count */
	U8		ucTcpDnRstCnt;				/**< Server => MN, Rst Count */
	U32		uiIPDataUpPktCnt;			/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPDataDnPktCnt;			/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPTotUpPktCnt;			/**< MN => Server, 전구간에서 패킷 개수 */
	U32		uiIPTotDnPktCnt;			/**< Server => MN, 전구간에서 패킷 개수 */
	U32		uiIPDataUpRetransCnt;		/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPDataDnRetransCnt;		/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPTotUpRetransCnt;		/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		uiIPTotDnRetransCnt;		/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		uiIPDataUpPktSize;			/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPDataDnPktSize;			/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPTotUpPktSize;			/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		uiIPTotDnPktSize;			/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		uiIPDataUpRetransSize;		/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPDataDnRetransSize;		/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPTotUpRetransSize;		/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		uiIPTotDnRetransSize;		/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		uiTcpUpBodySize;			/**< MN => Server, Tcp Payload 사이즈 */
	U32		uiTcpDnBodySize;			/**< Server => MN, Tcp Payload 사이즈 */
	U32		uiTcpUpRetransBodySize;		/**< MN => Server, Tcp Payload 사이즈, 재전송 포함 */
	U32		uiTcpDnRetransBodySize;		/**< Server => MN, Tcp Payload 사이즈, 재전송 포함 */
	U16		usTcpUpMSS;					/**< MN => Server, Syn의 MSS */
	U16		usTcpDnMSS;					/**< Server => MN, SynAck의 MSS */
	U16		usTcpUpFirstWindowSize;		/**< MN => Server, 최초 패킷의 Window Size */
	U16		usTcpDnFirstWindowSize;		/**< Server => MN, 최초 패킷의 Window Size */
	STIME	uiOpStartTime;				/**< 분석 시작 Time */
	MTIME	uiOpStartMTime;				/**< 분석 시작 Micro Time */
	STIME	uiOpEndTime;				/**< 마지막 처리 Time */
	MTIME	uiOpEndMTime;				/**< 마지막 처리 Micro Time */
} LOG_TCP_SESS;

/*  DEFINE LOG_DIAMETER_TRANS */
#define DIAMETER_CMDCODE_SIZE           128
#define DIAMETER_CMDCODE_LEN            (DIAMETER_CMDCODE_SIZE -1)
#define AVP_VALUES_SIZE                 128
#define AVP_VALUES_LEN                  (AVP_VALUES_SIZE -1)

/* Cx Interface */
#define USER_AUTHORIZATION_TRANS        300
#define SERVER_ASSIGNMENT_TRANS         301
#define LOCATION_INFO_TRANS             302
#define MULTIMEDIA_AUTH_TRANS           303
#define REGISTRATION_TERMINATION_TRANS  304
#define PUSH_PROFILE_TRANS              305 
/* Sh Interface */
#define USER_DATA_TRANS                 306
#define PROFILE_UPDATE_TRANS            307
#define SUBSCRIBE_NOTIFICATIONS_TRANS   308
#define PUSH_NOTIFICATION_TRANS         309 
#define BOOSTRAPPING_INFO_TRANS         310
#define MESSAGE_PROCES_TRANS            311 
/* Rf Interface */
#define ACCOUNTING_REQUEST_TRANS 		271
#define DEVICE_WATCHDOG_TRANS 	        280

#define DIAMETER_DEVICE_WATCH_REQUEST 					280
#define DIAMETER_DEVICE_WATCH_RESPONSE 					290

#define DIAMETER_USER_AUTHORIZATION_REQUEST 			300
#define DIAMETER_USER_AUTHORIZATION_ANSWER 				310
#define DIAMETER_SERVER_ASSIGNMENT_REQUEST 				301
#define DIAMETER_SERVER_ASSIGNMENT_ANSWER 				311
#define DIAMETER_LOCATION_INFO_REQUEST 					302
#define DIAMETER_LOCATION_INFO_ANSWER 					312
#define DIAMETER_MULTIMEDIA_AUTH_REQUEST 				303
#define DIAMETER_MULTIMEDIA_AUTH_ANSWER 				313
#define DIAMETER_REGISTRATION_TERMINATION_REQUEST 		304
#define DIAMETER_REGISTRATION_TERMINATION_ANSWER 		314
#define DIAMETER_PUSH_PROFILE_REQUEST 					305
#define DIAMETER_PUSH_PROFILE_ANSWER 					315

#define DIAMETER_USER_DATA_REQUEST 						306
#define DIAMETER_USER_DATA_RESPONSE 					316
#define DIAMETER_PROFILE_UPDATE_REQUEST 				307
#define DIAMETER_PROFILE_UPDATE_RESPONSE				317
#define DIAMETER_SUBSCRIBE_NOTIFICATIONS_REQUEST 		308
#define DIAMETER_SUBSCRIBE_NOTIFICATIONS_RESPONSE 		318 
#define DIAMETER_PUSH_NOTIFICATION_REQEUST 				309
#define DIAMETER_PUSH_NOTIFICATION_RESPONSE				319

#define DIAMETER_ACCOUNTING_REQUEST 					271
#define DIAMETER_ACCOUNTING_ANSWER 						281
/**
 * @brief LOG_DIAMETER_TRANS : DIAMETER Transaciton DB Log
 *
 *
 * @see common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */

TABLE_LOG typedef struct _st_DIAMETER_Trans_Log {
	<STG_COMMON:LOG_COMMON>

	U16         SrcPort;
	U16         DestPort;
	STRING      CmdCode[DIAMETER_CMDCODE_SIZE];         /**<  Command Code **/                          
	U32         ApplicationId;
	U32         HHID;                                   /**<  Hop-by-Hop Identifier **/                 
	U32         EEID;                                   /**<  End-to-End Identifier **/                 
	U32         LastEEID;                               /**<  End-to-End Identifier **/
	STRING      SessionId[AVP_VALUES_SIZE];             /**<  Session ID **/                            
	STRING      OriginHost[AVP_VALUES_SIZE];                                                            
	STRING      OriginRealm[AVP_VALUES_SIZE];
	STRING      DestHost[AVP_VALUES_SIZE];                                                              
	STRING      DestRealm[AVP_VALUES_SIZE];
	STRING      PublicId[AVP_VALUES_SIZE];
	STRING      ServerName[AVP_VALUES_SIZE];
	U32         VendorId;
	U32         AuthApplicationId;
	U32         AuthSessionState;
	U32         ResultCode;                             /**<  SUCCESS or FAILED **/                     
	U32         TotReqCnt;                                                                              
	U32         TotResCnt;                                                                              
	U32         ReqDataSize;                            /**<  Payload Size **/                          
	U32         ResDataSize;                                                                            
	U16         RetransReqCnt;                          /**<  Retransmission Count **/                  
	STIME       FirstRetransReqTime;                    /**<  First Restransmission PacketTime **/      
	MTIME       FirstRetransReqMTime;                   /**<  First Restransmission PacketTime **/      
	U32         RetransGapTime;                         /**<  FirstRetransReqTime - CreateTime **/      
	U32         LastUserErrCode;                        

	STIME       OpStartTime;                            /**<  분석 시작 Time */                         
	MTIME       OpStartMTime;                           /**<  분석 시작 Micro Time */                   
	STIME       OpEndTime;                              /**<  마지막 처리 Time */                       
	MTIME       OpEndMTime;                             /**<  마지막 처리 Micro Time */                 

} LOG_DIAMETER;


/**
 * @brief LOG_SIGNAL : RADIUS AND DIAMEER SIGNAL LOG
 *
 * @see common_stg.h
 *
 * @note   LOG_COMMON의 szMIN은 RADIUS Calling Station id
 *
 * @todo   nothing
 */

TABLE_LOG typedef struct _st_SIGNAL_Log {
	<STG_COMMON:LOG_COMMON>

	U32 		uiProtoType;					/* RADIUS: 121, DIAMETER: 122, L2TP: 115 */
	U32 		uiMsgType;						/* uiCommandCode */

	STIME		uiSessStartTime;
	MTIME		uiSessStartMTime;
	STIME		uiSessEndTime;
	MTIME		uiSessEndMTime;
	U32			uiSessDuration;					/* uiSessEndTime - uiSessStartTime */

	IP4         uiSrcIP;						/* PDSN, AAA, I-CSCF, S-CSCF, HSS */
	IP4         uiDestIP;
	U32         uiRespCode;
	U32			uiGREKey;

	STRING		szAuthUserName[MAX_AUTHUSERNAME_LEN];
	U32			uiSvcOption;
	U32			uiFMux;
	U32			uiRMux;
	U8			ucErrorCode;
	U16			usUpdateReason;
	U8			ucAirLink;
	U16			usLiftTime;
	U8			ucAppType;
	U8			ucAlwaysOnFlag;
	STRING      szMDN[MAX_MIN_SIZE];
	U8			ucAcctType;
	U64         ulAcctSessionID;                /* RADIUS Account-Session-id */
	U64         ulCorrelationID;                /* RADIUS Correlation-id */
	U16			usInterimTime;
	U16			usTC;
	STIME		uiEventTime;
	U8			ucStopFlag;
	U32			uiUpGREPkts;
	U32			uiDnGREPkts;
	U32			uiUpGREBytes;
	U32			uiDnGREBytes;
	U8			ucPPPReqCnt;
	U8			ucPPPNakCnt;
	U8			ucPPPRejCnt;
	STIME		uiPPPResponseTime;
	MTIME		uiPPPResponseMTime;
	U32         uiCommandCode;                  /* DIAMETER Command Code */
	U32         uiApplicationId;
    U32         uiHopByHopID;
    U32         uiEndToEndID;
    U32         uiLastEndToEndID;
	STRING      szSessionID[MAX_SESSIONID_SIZE];
    STRING      szOrgHost[MAX_HOST_REALM_SIZE];
    STRING      szOrgRealm[MAX_HOST_REALM_SIZE];
    STRING      szDestHost[MAX_HOST_REALM_SIZE];
    STRING      szDestRealm[MAX_HOST_REALM_SIZE];
    STRING      szPublicID[MAX_SIPURI_SIZE];
	U32         uiResultCode;
    U32         uiExpResultCode;
    U32         uiAuthApplicationId;
    U32         uiAuthSessionState;
	U32         uiLastUserErrCode;	


	STRING		szUserName[MAX_USERNAME_LEN];
	IP4			uiNasIP;
	U16			usActiveTime;	
	U32			uiAcctInOctets;
	U32			uiAcctOutOctets;

	STIME		uiL2TPReqTime;					/* SCCRQ, ICRQ Time */
	MTIME		uiL2TPReqMTime;						
	STIME       uiL2TPRepTime;					/* SCCRP, ICRP Time */
    MTIME       uiL2TPRepMTime;
	STIME       uiL2TPConTime;					/* SCCCN, ICCN Time */
    MTIME       uiL2TPConMTime;
	U32			uiUpL2TPPkts;					/* LAC -> LNS Packet Count */
	U32			uiDnL2TPPkts;					/* LNS -> LAC Packet Count */
	U32			uiUpL2TPBytes;					/* LAC -> LNS Packet Size */
	U32			uiDnL2TPBytes;					/* LNS -> LAC Packet Size */
	U16			usReqTunnelID;					/* LAC Tunnel ID */
	U16			usRepTunnelID;					/* LNS Tunnel ID */
	U16			usReqSessID;					/* LAC Session ID */
	U16			usRepSessID;					/* LNS Session ID */
	U16			usResultCode;					/* CDN, StopCCN Result Code */
	U16			usErrorCode;					/* CDN, StopCCN Error Code */

	U8 			ucEquipType; 	
	
} LOG_SIGNAL;

/**
 *
 *		HTTP
 *
 */

<TAG_DEFINE_START:TCPFLAG>
#define DEF_TCP_START		1
#define DEF_TCP_DATA		2
#define DEF_TCP_END			3
#define DEF_TCP_UPDATE		4
<TAG_DEFINE_END:TCPFLAG>

<TAG_DEFINE_START:RETRANS>
#define DEF_RETRANS_OFF		0
#define DEF_RETRANS_ON		1
<TAG_DEFINE_END:RETRANS>

#define DEF_DELETE_OFF      0
#define DEF_DELETE_ON       1

/**
 * @brief st_TcpInfo : TCP Session 정보를 HTTP에 전달하기 위한 structure이다.
 *
 *
 * @see aqua.h
 *
 * @note   현재는 NTAS structure를 그대로 사용하지만 2차 개발시에 변경 가능.
 *
 * @todo   2차 개발시에 TCP Ack를 확인하는 구조로 변경 요망.
 */

/*
 * st_HttpPkt => st_TcpInfo 
 */
typedef struct _st_TcpInfo {
	U32		uiDataSize;		/**< TCP Payload Size */
	U32		uiSrvIP;		/**< Server IP Address */

	U32		uiCliIP;		/**< 단말 IP Address */
	U16		usSrvPort;		/**< Server Port */
	U16		usCliPort;		/**< 단말 Port */

	U32		uiSeqNum;		/**< Packet Seq No. */
	U32		uiAckNum;		/**< Ack Packet의 Ack No. */

	OFFSET	uiSOffset;

    STIME	uiCapTime;		/**< 캡쳐된 시간 */
    MTIME	uiCapMTime;		/**< 캡쳐된 Micro 시간 */
    STIME	uiAckTime;		/**< Ack Packet을 받은 시간 */
    MTIME	uiAckMTime;		/**< Ack Packet을 받은 Micro 시간 */

	U16		usAppCode;
	U16		usL4Code;		/**< L4Code */
	U16		usL7Code;		/**< L7Code */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;	/**< L4 Error Code */
	U8		<TAG_DEFINE:RTX>ucRtx;		/**< UP/Down 방향 1: UP, 2: Down */
	S8		<TAG_DEFINE:TCPFLAG>cTcpFlag;	/**< [O] TCP State */
	S8		<TAG_DEFINE:RETRANS>cRetrans;		/**< [O] 재전송 Flag */
	U8		ucProtocol;		/**< [O] 현재 사용되는 곳 없음, 향후 기능 확장에서 사용될 가능성 있음 */

	U8		ucTcpClientStatus;
	U8		ucTcpServerStatus;

	U32		uiIPDataUpPktCnt;		/**< MN => Server, 데이터 전송 단계에서 패킷 개수 (전송후 Reset) */
	U32		uiIPDataDnPktCnt;		/**< Server => MN, 데이터 전송 단계에서 패킷 개수 (전송후 Reset) */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 (전송후 Reset) */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 (전송후 Reset) */
	U32		uiIPDataUpRetransCnt;	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPDataDnRetransCnt;	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPDataUpPktSize;		/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataDnPktSize;		/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataUpRetransSize;	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataDnRetransSize;	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 (전송후 Reset) */
} TCP_INFO;

#define MAX_K3G_SIZE		1024
#define MAX_MMS_SIZE		1024
#define MAX_STREAM_SIZE		(1024 * 10)
#define MAX_EMS_SIZE		(1024 * 10)
/**
 * @brief st_MSG_INFO : A_HTTP에서 임시로 데이터 처리 하기 위한 구조체
 *
 *
 * @see aqua.h
 *
 * @note   현재는 NTAS structure를 그대로 사용하지만 2차 개발시에 변경 가능.
 *
 * @todo   2차 개발시에 TCP Ack를 확인하는 구조로 변경 요망.
 */
#define MAX_MULTIPART_SIZE			161
#define MAX_MULTIPART_LEN			(MAX_MULTIPART_SIZE - 1)
#define MAX_TEMP_CONTENT_SIZE		(MAX_CONTENTSTYPE_LEN + MAX_MULTIPART_LEN + 1)
#define MAX_TEMP_CONTENT_LEN		(MAX_TEMP_CONTENT_SIZE - 1)
typedef struct _st_MultiKey {
	S32			len;
	S32			state;
	STRING		key[MAX_MULTIPART_SIZE];
} MULTI_KEY;

#define DEF_ZIP_GZIP				1
#define DEF_ZIP_DEFLATE				2

typedef struct _st_msg_info {
	U32			uiLastSeq;
	U32			uiNextSeq;			/**< 다음에 받을 것으로 예상되는 Seq No. */
	STIME		uiStartTime;
	MTIME		uiStartMTime;
	STIME		uiLastUpdateTime;
	MTIME		uiLastUpdateMTime;
	STIME		uiAckTime;
	MTIME		uiAckMTime;
	U32			uiHdrLen;
	U32			uiBodyLen;
	U32			uiLimitLen;
	U8			ucLenType;
	U32			uiLen;
	U32			uiMaxLen;
	U8			<TAG_DEFINE:BUFFERING>ucIsBuffering;	/**< Buffering 여부를 결정 */
	U8			<TAG_DEFINE:HDR_BODY>ucStatus;			/**< 현재 HDR/BODY 상태를 표시 */
	U8			<TAG_DEFINE:END_STATE>ucEndStatus;		/**< pReqData의 상태 값 */
	OFFSET		offset_HDR;
	OFFSET		offset_CurHDR;							/**< REQ 현재 Active 상태에 있는 Node */
	OFFSET		offset_BODY;							/**< REQ END_STATE_0D0A0D0A 찾기 전까지 임시 보관 (Node Header) */
	OFFSET		offset_CurBODY;
	S32			dZip;
	S32			dChunked;
	MULTI_KEY	MULTIKEY;
} st_MSG_INFO;

#define MSG_INFO_CNT		2

/**
 * @brief st_TcpHashKey : A_HTTP에서 TCP Session 관리를 Hash Key 구조체
 *
 *
 * @see aqua.h
 *
 * @note   현재는 NTAS structure를 그대로 사용하지만 2차 개발시에 변경 가능.
 *
 * @todo   2차 개발시에 TCP Ack를 확인하는 구조로 변경 요망.
 */
typedef struct _st_Http_TSess_Key {
	U32				uiCliIP;				/**< 단말 IP Address */
	U16				usCliPort;				/**< 단말 Port */
	U16				usReserved;				/**< 0x00으로 초기화 할 것 */
} HTTP_TSESS_KEY;

#define METHOD_RESPONSE				100

<TAG_DEFINE_START:URL_TYPE>
#define URL_TYPE_HOST_PORT			1
#define URL_TYPE_HOST_NOPORT		2
#define URL_TYPE_NOHOST_NOPORT		3
#define URL_TYPE_CONNECT			4
<TAG_DEFINE_END:URL_TYPE>

<TAG_DEFINE_START:END_STATE>
#define END_STATE_EMPTY				0
#define END_STATE_0D				1
#define END_STATE_0D0A				2
#define END_STATE_0D0A0D			3
#define END_STATE_0D0A0D0A			4
#define END_STATE_30				5
<TAG_DEFINE_END:END_STATE>
<TAG_DEFINE_START:HDR_BODY>
#define TSESS_STATUS_HDRWAIT		0
#define TSESS_STATUS_HDRDOING		1
#define TSESS_STATUS_BODYWAIT		2
#define TSESS_STATUS_BODYDOING		3
<TAG_DEFINE_END:HDR_BODY>
<TAG_DEFINE_START:BUFFERING>
#define TSESS_BUFFERING_ON			0
#define TSESS_BUFFERING_OFF			1
<TAG_DEFINE_END:BUFFERING>
<TAG_DEFINE_START:LENTYPE>
#define LEN_TYPE_CONTENTLENGTH		1
#define LEN_TYPE_CHUNKED			2
#define LEN_TYPE_MULTIPART			3
#define LEN_TYPE_PACKETCOUNTER		4
<TAG_DEFINE_END:LENTYPE>
<TAG_DEFINE_START:SSL>
#define SSL_OFF						0
#define SSL_ON						1
<TAG_DEFINE_END:SSL>
/**
 * @brief st_TcpHashData : A_HTTP에서 TCP Session 관리를 Hash Data 구조체
 *
 *
 * @see aqua.h
 *
 * @note   현재는 NTAS structure를 그대로 사용하지만 2차 개발시에 변경 가능.
 *
 * @todo   2차 개발시에 TCP Ack를 확인하는 구조로 변경 요망.
 */
typedef struct _st_Http_TSess {
	U32		uiSrvIP;				/**< 서버 IP Address */
	U16		usSrvPort;    			/**< 서버 Port */
	STIME	uiTcpSynTime;			/**< TCP Session 시작 시간 */
	MTIME	uiTcpSynMTime;			/**< TCP Session 시작 시간 */
	U16		usNextTransID;			/**< 할당될 Http Transaction ID */
	U16		usFirstTransID;			/**< HASH에 있는 첫번째 Http Transaction ID */
	U16		usLastTransID;			/**< HASH에 있는 마지막 Http Transaction ID */
	U16		usCurTransCnt;			/**< 현재 갖고 있는 Http Transaction 개수 */
	U16		usTotTransCnt;			/**< 처리한 Http Transaction 개수 */
	U8		ucSynRtx;				/**< SYN UP/Down 방향 1: UP, 2: Down */

	DEF     <TAG_DEFINE:L4FAILCODE>usL4FailCode;
	U16		usAppCode;
	U16		usL4Code;
	U16		usL7Code;

	U8		<TAG_DEFINE:SSL>ucSSL;
	U8		<TAG_DEFINE:METHOD>ucMethod;			/**< Http Request Method Type  */
	U32		usResCode;
	U16		hostNameLen;
	STRING	szHostName[MAX_HOSTNAME_SIZE];
	U16		<TAG_DEFINE:URL_TYPE>urlType;
	U16		usUrlSize;				/**< URL size */
	STRING	szUrl[MAX_LOGURL_SIZE];	/**< URL */
	U16		usContentsType;			/**< Content-Type */
	U16		usContentsTypeSize;		/**< Content-Type Size */
	STRING	szContentsType[MAX_CONTENTSTYPE_SIZE]; 	/**< Content-Type String */

	U8		ucTcpClientStatus;
	U8		ucTcpServerStatus;

	st_MSG_INFO	MSGINFO[MSG_INFO_CNT];

	U32		uiIPDataUpPktCnt;		/**< MN => Server, 데이터 전송 단계에서 패킷 개수 (전송후 Reset) */
	U32		uiIPDataDnPktCnt;		/**< Server => MN, 데이터 전송 단계에서 패킷 개수 (전송후 Reset) */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 (전송후 Reset) */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 (전송후 Reset) */
	U32		uiIPDataUpRetransCnt;	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPDataDnRetransCnt;	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 (전송후 Reset) */
	U32		uiIPDataUpPktSize;		/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataDnPktSize;		/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataUpRetransSize;	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPDataDnRetransSize;	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 (전송후 Reset) */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 (전송후 Reset) */
} HTTP_TSESS;

/**
 * @brief st_HttpHashKey : A_HTTP에서 HTTP Transaction 관리를 Hash Key 구조체
 *
 *
 * @see aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
typedef struct _st_Http_Trans_Key {
	U32				uiCliIP;		/**< 단말 IP Address */
	U16				usCliPort;		/**< 단말 Port */
	U16				usHttpTransID;	/**< HTTP Transaction ID */
} HTTP_TRANS_KEY;

<TAG_DEFINE_START:HTTP_TRANS_STATUS>
#define HTTP_TRANS_STATUS_NULL				0
#define	HTTP_TRANS_STATUS_REQHDRING			11
#define HTTP_TRANS_STATUS_REQHDR				12	/* REQ HDR를 다 받은 상태 */
#define	HTTP_TRANS_STATUS_REQBODYING			13
#define	HTTP_TRANS_STATUS_REQBODY				14	/* REQ BODY를 다 받은 상태 */
#define HTTP_TRANS_STATUS_RESHDRING			21
#define HTTP_TRANS_STATUS_RESHDR				22	/* RES HDR를 다 받은 상태 */
#define HTTP_TRANS_STATUS_RESBODYING			23
#define HTTP_TRANS_STATUS_RESBODY				24	/* RES BODY를 다 받은 상태 */
#define HTTP_TRANS_STATUS_ACKHDRING			31
#define HTTP_TRANS_STATUS_ACKHDR				32
#define HTTP_TRANS_STATUS_ACKBODYING			33
#define HTTP_TRANS_STATUS_ACKBODY				34
<TAG_DEFINE_END:HTTP_TRANS_STATUS>

/* 
 * 우선 순위는 왼쪽에 위치한 것이 높다. 두개의 에러가 발생할 경우 왼쪽의 값을 세팅한다.
 * 970 > 911 > 941 > 910 > 920 > 930 > 940 > 950 > 960 > 900
 */
<TAG_DEFINE_START:USER_ERROR>
#define HTTP_UERR_EMPTY	0
#define HTTP_UERR_900	900 /* 서버로부터 오류를 나타내는 응답 코드가 온 경우 (응답 코드 400 이상) */
#define HTTP_UERR_910	910 /* Req 메시지가 완료되지 않고 Transaction이 종료된 경우 */
#define HTTP_UERR_911	911 /* Req 메시지가 예정된 크기보다 작게 전송된 후 그 다음 Req메시지가 전송된 경우 */
#define HTTP_UERR_920	920 /* 완료된 Req 메시지에 대해 서버 측의 ACK가 전송되지 않은 경우 */
#define HTTP_UERR_930	930 /* 서버 측의 ACK가 전송되었으나 응답메시지의 전송이 시작되지 않은 경우 */
#define HTTP_UERR_940	940	/* 응답메시지가 시작된 후 응답메시지 전송이 완료되지 않고 Transaction이 종료된 경우 */
#define HTTP_UERR_941	941 /* Res 메시지가 예정된 크기보다 작게 전송된 후 그 다음 Res 메시지가 전송된 경우 */
#define HTTP_UERR_950	950 /* 응답메시지가 완료되었지만 MN에서 ACK가 전송되지 않고 트랜잭션이 종료된 경우 */
#define HTTP_UERR_960	960 /* Req 메시지에서 잘못된 Method 또는 알수 없는 Method가 있는 경우 */
#define HTTP_UERR_970	970	/* Seq 번호가 맞지 않아서 정리된 경우 */
#define HTTP_UERR_980	980	/* Application 오류가 발생한 경우 */
<TAG_DEFINE_END:USER_ERROR>
/**
 * @brief st_HttpHashData : A_HTTP에서 HTTTP Transaction 관리를 Hash Data 구조체
 *
 *
 * @see aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
typedef struct _st_Http_Trans {
	U16					usL4FailCode;			/**< L4 Error Code */
	U16					usL7FailCode;

	U16					usL4Code;				/**< L4Code L4(IP, Port)로 판단한 Service Code */
	U16					usL7Code;				/**< L7Code L7(URL)로 판단한 Service Code */
	U16					usAppCode;				/**< 해당 메시지 처리 프로세스 코드 */

	U8					<TAG_DEFINE:HTTP_TRANS_STATUS>ucStatus;		/**< Http Transaction 상태 값 */

	S32					dSndMsgQ;		/**< 보내야 할 서비스블럭의 메시지큐아이디 */

#define HTTP_MSGTYPE_REQHDR			0
#define HTTP_MSGTYPE_REQBODY		1
#define HTTP_MSGTYPE_RESHDR			2
#define HTTP_MSGTYPE_RESBODY		3
#define HTTP_MSGTYPE_ACKHDR			4
#define HTTP_MSGTYPE_ACKBODY		5
#define HTTP_MSGTYPE_CNT			6

	OFFSET				offset_Node[HTTP_MSGTYPE_CNT];				/**< Ack Header 버퍼링 메모리 주소 */
	OFFSET				offset_LOG;
} HTTP_TRANS;

<TAG_DEFINE_START:LOG_HTTP_STATUS>
#define LOG_HTTP_REQ_DOING			11		/* REQUEST 상태 */
#define LOG_HTTP_REQ_DONE			21		/* REQUEST 전송 완료 상태 */	
#define LOG_HTTP_REQ_ACK			31		/* REQUEST 전송 완료 후 서버 ACK 상태 */
#define LOG_HTTP_RES_DOING			41		/* RESPONSE 상태 */
#define LOG_HTTP_RES_DONE			51		/* RESPONSE 전송 완료 상태 */
#define LOG_HTTP_RES_ACK			61		/* RESPONSE 전송 완료 후 단말 ACK 상태 */
#define LOG_HTTP_STATUS_UNKNOWN		91		/* 기타 상태 */
<TAG_DEFINE_END:LOG_HTTP_STATUS>


/**
 * @brief HTTP_LOG : HTTP 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_Http_Log {
	LINEFEED			[ \t]*(\r\n)
	FORMFEED			[ \t]*(\r\n\r\n)
	STATE	WIPI_REQ_HDR:^^:METHOD				^[ \t]*GET[ \t]+
	STATE	WIPI_REQ_HDR:^^:METHOD				^[ \t]*POST[ \t]+
	STATE	WIPI_REQ_HDR:^^:HOST				Host[ \t]*:[ \t]*

	STATE	WIPI_REQ_HDR:^^:HTTP_PHONE_SYSTEM_PARAMETER		HTTP_PHONE_SYSTEM_PARAMETER[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:COUNTER				COUNTER[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:USER_AGENT					User-Agent[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:HTTP_CHANNEL_INFO		CHANNEL_INFO[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:HTTP_PHONE_NUMBER				HTTP_PHONE_NUMBER[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:CDU				CDU[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:CSEQ			CSeq[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:COOKIE			Cookie[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:FROM			FROM[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:MIN				MIN[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:PHONENUMBER		PHONENUMBER[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:PHONEMODEL		PHONEMODEL[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:MSGTYPE			Message-Type[ \t]*:[ \t]*
	STATE	WIPI_REQ_HDR:^^:WIDGETID		Widget-ID[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:HTTP			^[ \t]*HTTP[/.0-9]+[ \t]*
	STATE	WIPI_RESP_HDR:^^:CONTENT_LENGTH			Content-Length[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:CONTENT_TYPE			Content-Type[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:CPDATA					CPdata[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:LOCATION				Location[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:BILLINFO				BILL_INFO[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:ERRORCODE				Error-Code[ \t]*:[ \t]*
	STATE	WIPI_RESP_HDR:^^:RESULTCODE				Result-Code[ \t]*:[ \t]*
	TOKEN	STR 				[^\r\n]+
	TOKEN	ID 					[^<> \t\r\n]+
	TOKEN	VALUE 				[^=&;: \t\r\n]+
	TOKEN	VALUE11 			[^@ \t\r\n]+
	TOKEN	DIGIT 				[ \t]*[0-9]+


	<STG_COMMON:LOG_COMMON>

	U16		usClientPort;			/**< 단말 Port */
	IP4		uiServerIP;				/**< Server IP */
	U16		usServerPort;			/**< Server Port */
	STIME	uiTcpSynTime;			/**< Tcp Syn Time */
	MTIME	uiTcpSynMTime;			/**< Tcp Syn Micro Time */
	U16		usTransID;				/**< HTTP Transaction ID */
	U32		uiPageID;				/**< PAGE ID */
	DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;			/**< usSvcL4Type / 1000 * 1000 */
	DEF		<TAG_DEFINE:L4CODE>usSvcL4Type;			/**< IP, PORT로 판단한 Service type */
	DEF		<TAG_DEFINE:L7CODE>usSvcL7Type;			/**< URL, HostName으로 판단한 Service type */
	U8		ucSubSysNo;				/**< Sub System No. */
	DEF		<TAG_DEFINE:ContentsType>usContentsType; @CILOG_HIDDEN@	/**< Content-Type Define Type */	/* HTTP level */ #PARSING_RULE:^^:WIPI_RESP_HDR:^^:<CONTENT_TYPE>{VALUE}:^^:Parse_Set_szContentsType#
	STRING	szContentsType[MAX_CONTENTSTYPE_SIZE]; 	/**< Content-Type String */	/* HTTP level */ 
	DEF		<TAG_DEFINE:METHOD>ucMethod;		/**< Method Code 값 */			/* HTTP level */
	STIME	uiReqStartTime;			/**< GET/POST Request Start Time */
	MTIME	uiReqStartMTime;		/**< GET/POST Request Start Micro Time */
	STIME	uiReqEndTime;			/**< GET/POST Request End Time */
	MTIME	uiReqEndMTime;			/**< GET/POST Request End Micro Time */
	STIME	uiReqAckTime;			/**< Request에 대한 서버 측의 Ack Time */
	MTIME	uiReqAckMTime;			/**< Request에 대한 서버 측의 Ack Micro Time */
	STIME	uiResStartTime;			/**< Response Start Time */
	MTIME	uiResStartMTime;		/**< Response Start Micro Time */
	STIME	uiResEndTime;			/**< Response End Time */
	MTIME	uiResEndMTime;			/**< Response End Micro Time */
	STIME	uiMNAckTime;			/**< 단말 Ack Time */
	MTIME	uiMNAckMTime;			/**< 단말 Ack Micro Time */
	STIME	uiLastPktTime;			/**< Last Packet Time */
	MTIME	uiLastPktMTime;			/**< Last Packet Micro Time */
	S64		llTransGapTime;			/**< LastPktTime - ReqStartTime */
	U32		usResCode;				/**< HTTP Response Code */		#PARSING_RULE:^^:WIPI_RESP_HDR:^^:<HTTP>{DIGIT}#
	DEF		<TAG_DEFINE:CLI>ucTcpClientStatus;			/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>ucTcpServerStatus;			/**< 서버 상태 */
	DEF		<TAG_DEFINE:LOG_HTTP_STATUS>ucStatus;	/**< HTTP 서비스 상태 */
	U32		usUserErrorCode;		/**< NTAS Error Code */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;	/**< TCP Fail Code */
	U16		usL7FailCode;			/**< HTTP Fail Code */
	STRING	szAppFailCode[MAX_APPFAILCODE_SIZE];	/**< MARS Application Fail Code */
	U16		usLOGURLSize;			/**< LOG URL Size */			/* HTTP level */
	STRING	szLOGURL[MAX_LOGURL_SIZE];	@CHECKING_VALUE:http@ 	/**< LOG URL */	
	U16		usURLSize;				 @CILOG_HIDDEN@  /**< URL Size */ 
	STRING	szURL[MAX_URL_SIZE];	 @CILOG_HIDDEN@  /**< URL */	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<METHOD>{STR}:^^:Get_Detailed_URL#
	STRING	Location[MAX_URL_SIZE];	/**< URL */						/* HTTP level */ /*< 추후 삭제요망 */ #PARSING_RULE:^^:WIPI_RESP_HDR:^^:<LOCATION>{STR}# 
	U32		uiIPDataUpPktCnt;		/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPDataDnPktCnt;		/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 */
	U32		uiIPDataUpRetransCnt;	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPDataDnRetransCnt;	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		uiIPDataUpPktSize;		/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPDataDnPktSize;		/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		uiIPDataUpRetransSize;	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPDataDnRetransSize;	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		uiTcpUpBodySize;		/**< MN => Server, TCP Payload Size */
	U32		uiTcpDnBodySize;		/**< Server => MN, TCP Payload Size */
	U32		uiUpHeaderSize;			/**< MN => Server, HTTP Header Size */
	U32		uiDnHeaderSize;			/**< Server => MN, HTTP Header Size */
	U32		uiUpBodySize;			/**< MN => Server, HTTP Body Size */
	U32		uiDnBodySize;			/**< Server => MN, HTTP Body Size */
	U32		uiContentLength;		/**< HTTP Response Header의 ContentLength 필드 값 */  	/* HTTP Level */ #PARSING_RULE:^^:WIPI_RESP_HDR:^^:<CONTENT_LENGTH>{DIGIT}#
	STRING	szMenuTitle[MAX_MENUTITLE_SIZE];	/**< 메뉴명 */			/* 추후 : will be implementing */ #PARSING_RULE:^^:WIPI_REQ_HDR:^^:<WIDGETID>{STR}#
	STRING	MenuID[MAX_MENUID_SIZE];	/* 아래 URL_ANALYSIS참조 */
												/**< VOD/Dosirak => Menu ID 
											 	BREW ADS/PAS-BREW => :Application ID
											 	WIPI MARS => Application ID */			/* will be implementing */
	STRING	SvcAction[MAX_SVCACTION_SIZE];		/* 아래 URL_ANALYSIS참조 */
												/**< VOD/Dosirak => SvcType 
												 BREW ADS/PAS-BREW => getFile
												 WIPI MARS => 요청 코드 */			/* will be implementing */
	STRING	ContentID[MAX_CONTENTID_SIZE];	/* 아래 URL_ANALYSIS참조 */
												/**< VOD/Dosirak Download인 경우 Contents ID */ 
	STRING	CATID[MAX_CATID_SIZE];		#PARSING_RULE:^^:WIPI_RESP_HDR:^^:<BILLINFO>PGID={VALUE}#
											/* 아래 URL_ANALYSIS참조 */		
												/**< VOD/Dosirak Download 인 경우 CATID
												BREW ADS/PAS-BREW Type 인 경우 PKGID
												WIPI MARS인 경우 product ID */
	STIME	uiOpStartTime;			/** 분석 시작 Time */
	MTIME	uiOpStartMTime;			/** 분석 시작 Micro Time */
	STIME	uiOpEndTime;			/** 마지막 처리 Time */
	MTIME	uiOpEndMTime;			/** 마지막 처리 Micro Time */
	U32		isCDU;	/**< isCDU */ 	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<CDU>{VALUE}:^^:Get_Is_CDU#
	U32		link_cnt;	@CILOG_HIDDEN@  /**< Link CNT : HTTP안에 포함되는 LINK수  */
	U32		href_cnt;	@CILOG_HIDDEN@  /**< Link CNT : HTTP안에 포함되는 LINK수  */
	STRING	szTransactionID[MAX_TRANSID_SIZE];
	U16		usClientType;
	U16		usClientPlatform;
	STRING	szClientVersion[MAX_CLIVER_SIZE];
	U16		usCommand;
	STRING	szSmtpServer[MAX_SMTPSVR_SIZE];
	STRING	szPop3Server[MAX_POP3SVR_SIZE];
	U16		usSmtpSsl;
	U16		usPop3Ssl;
	U32		uiPeriodTime;
	U16		usParam;
	U16		usImageRecv;

	S32		dChunked;		@CILOG_HIDDEN@

	S32		dReqZip;		@CILOG_HIDDEN@
	S32		dReqMultiLen;	@CILOG_HIDDEN@
	STRING	szReqMulti[MAX_MULTIPART_SIZE];	@CILOG_HIDDEN@
	
	S32		dResZip;		@CILOG_HIDDEN@
	S32		dResMultiLen;	@CILOG_HIDDEN@
	STRING	szResMulti[MAX_MULTIPART_SIZE];	@CILOG_HIDDEN@
	STRING	szMSGTYPE[MAX_MSGTYPE_SIZE];	 @CILOG_HIDDEN@  /**< WIDGET MSGTYPE */	#PARSING_RULE:^^:WIPI_REQ_HDR:^^:<MSGTYPE>{STR}#
	U32		uiLimitDataSize;		/**< Server => MN, TCP Payload Size 10초 이내 */
} LOG_HTTP_TRANS;				$PARSING_CASE_IGNORE$

STG_LOG_TEXT_PARSING typedef struct _st_url_analysis {
	LINEFEED			[ \t]*(\r\n)
	FORMFEED			[ \t]*(\r\n\r\n)
	STATE	URL_S:^^:URL_T		[?]+
	TOKEN	VALUE 				[^?=&;: \t\r\n]+

	STRING	MenuID[MAX_MENUID_SIZE];	#PARSING_RULE:^^:URL_S:^^:<URL_T>menuid={VALUE}# 
		ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>appid={VALUE}#
		ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>applicationid={VALUE}#
		ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>itemID={VALUE}#
			/**< VOD/Dosirak => Menu ID 
			  BREW ADS/PAS-BREW => :Application ID
			  WIPI MARS => Application ID */			/* will be implementing */
	STRING	szSvcAction[MAX_SVCACTION_SIZE];	#PARSING_RULE:^^:URL_S:^^:<URL_T>svctype={VALUE}# 
		ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>action={VALUE}#
		ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>c={VALUE}#
			/**< VOD/Dosirak => SvcType 
			  BREW ADS/PAS-BREW => getFile
			  WIPI MARS => 요청 코드 */			/* will be implementing */
	STRING	ContentID[MAX_CONTENTID_SIZE];	#PARSING_RULE:^^:URL_S:^^:<URL_T>id={VALUE}# 
							/**< VOD/Dosirak Download인 경우 Contents ID : return BODY안의 URL안에 */ 
	STRING	CATID[MAX_CATID_SIZE];		#PARSING_RULE:^^:URL_S:^^:<URL_T>pkgid={VALUE}# 
		ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>productid={VALUE}#
			/**< VOD/Dosirak Download 인 경우 CATID : resp hdr BILL_INFO
			  BREW ADS/PAS-BREW Type 인 경우 PKGID pkgID=
			  WIPI MARS인 경우 product ID : productid= */
	STRING	szURLMIN[MAX_MIN_SIZE]; #PARSING_RULE:^^:URL_S:^^:<URL_T>phone={VALUE}:^^:PARSING_MIN_Change#
				ALTERNATIVE_RULE		#PARSING_RULE:^^:URL_S:^^:<URL_T>CTN={VALUE}:^^:PARSING_MIN_Change#	
	STRING	szCPName[MAX_CPNAME_SIZE]; #PARSING_RULE:^^:URL_S:^^:<URL_T>cpname={VALUE}#
	STRING	szServiceCode[MAX_SERVICECODE_SIZE]; #PARSING_RULE:^^:URL_S:^^:<URL_T>svccode={VALUE}#
} URL_ANALYSIS;				$PARSING_CASE_IGNORE$

/**
 * @brief RTSP_TRANS_LOG : RTSP 정보를 DB Log
 *
 *
 * @see aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_Rtsp_Log {

	<STG_COMMON:LOG_COMMON>

	U16     usClientPort;           /**< 단말 Port */
	IP4     uiServerIP;             /**< Server IP */
	U16     usServerPort;           /**< Server Port */
	STIME   uiTcpSynTime;           /**< Tcp Syn Time */
	MTIME   uiTcpSynMTime;          /**< Tcp Syn Micro Time */
	U16     usTransID;              /**< HTTP Transaction ID */
	U32     uiPageID;               /**< PAGE ID */
	DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;         /**< usSvcL4Type / 1000 * 1000 */
	DEF     <TAG_DEFINE:L4CODE>usSvcL4Type; /**< IP, PORT로 판단한 Service type */
	DEF     <TAG_DEFINE:L7CODE>usSvcL7Type; /**< URL, HostName으로 판단한 Service type */
	U8      ucSubSysNo;             /**< Sub System No. */
	DEF     <TAG_DEFINE:ContentsType>usContentsType;  @CILOG_HIDDEN@  /**< Content-Type *//* HTTP level */
	STRING  szContentsType[MAX_CONTENTSTYPE_SIZE];    /**< Content-Type *//* HTTP level */
	DEF     <TAG_DEFINE:METHOD>ucMethod;        /**< Method Code 값 *//* HTTP level */
	STIME   uiReqStartTime;         /**< GET/POST Request Start Time */
	MTIME   uiReqStartMTime;        /**< GET/POST Request Start Micro Time */
	STIME   uiReqEndTime;           /**< GET/POST Request End Time */
	MTIME   uiReqEndMTime;          /**< GET/POST Request End Micro Time */
	STIME   uiReqAckTime;           /**< Request에 대한 서버 측의 Ack Time */
	MTIME   uiReqAckMTime;          /**< Request에 대한 서버 측의 Ack Micro Time */
	STIME   uiResStartTime;         /**< Response Start Time */
	MTIME   uiResStartMTime;        /**< Response Start Micro Time */
	STIME   uiResEndTime;           /**< Response End Time */
	MTIME   uiResEndMTime;          /**< Response End Micro Time */
	STIME   uiMNAckTime;            /**< 단말 Ack Time */
	MTIME   uiMNAckMTime;           /**< 단말 Ack Micro Time */
	STIME   uiLastPktTime;          /**< Last Packet Time */
	MTIME   uiLastPktMTime;         /**< Last Packet Micro Time */
	S64     llTransGapTime;         /**< LastPktTime - ReqStartTime */
	U32     usResCode;              /**< HTTP Response Code */
	DEF      <TAG_DEFINE:CLI>ucTcpClientStatus;          /**< 단말 상태 */
	DEF      <TAG_DEFINE:SVR>ucTcpServerStatus;          /**< 서버 상태 */
	DEF      <TAG_DEFINE:LOG_HTTP_STATUS>ucStatus;   /**< HTTP 서비스 상태 */
	U32     usUserErrorCode;        /**< NTAS Error Code */
	DEF     <TAG_DEFINE:L4FAILCODE>usL4FailCode;    /**< TCP Fail Code */
	U16     usL7FailCode;           /**< HTTP Fail Code */
	U16     usURLSize;              /**< URL Size */            /* HTTP level */
	STRING     szURL[MAX_LOGURL_SIZE];    /**< URL */                 /* HTTP level */				@CHECKING_VALUE:rtsp@
	STRING     Location[MAX_URL_SIZE]; /**< URL */                 /* HTTP level */
	U32     uiIPDataUpPktCnt;       /**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32     uiIPDataDnPktCnt;       /**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32     uiIPTotUpPktCnt;        /**< MN => Server, 전구간에서 패킷 개수 */
	U32     uiIPTotDnPktCnt;        /**< Server => MN, 전구간에서 패킷 개수 */
	U32     uiIPDataUpRetransCnt;   /**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32     uiIPDataDnRetransCnt;   /**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32     uiIPTotUpRetransCnt;    /**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32     uiIPTotDnRetransCnt;    /**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32     uiIPDataUpPktSize;      /**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32     uiIPDataDnPktSize;      /**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32     uiIPTotUpPktSize;       /**< MN => Server, 전구간에서 데이터 사이즈 */
	U32     uiIPTotDnPktSize;       /**< Server => MN, 전구간에서 데이터 사이즈 */
	U32     uiIPDataUpRetransSize;  /**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32     uiIPDataDnRetransSize;  /**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32     uiIPTotUpRetransSize;   /**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32     uiIPTotDnRetransSize;   /**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32     uiTcpUpBodySize;        /**< MN => Server, TCP Payload Size */
	U32     uiTcpDnBodySize;        /**< Server => MN, TCP Payload Size */
	U32     uiUpHeaderSize;         /**< MN => Server, HTTP Header Size */
	U32     uiDnHeaderSize;         /**< Server => MN, HTTP Header Size */
	U32     uiUpBodySize;           /**< MN => Server, HTTP Body Size */
	U32     uiDnBodySize;           /**< Server => MN, HTTP Body Size */
	STRING     szMenuTitle[MAX_MENUTITLE_SIZE];    /**< 메뉴명 */          /* 추후 : will be implementing */
	STRING     CATID[MAX_CATID_SIZE];
	STIME   uiOpStartTime;          /** 분석 시작 Time */
	MTIME   uiOpStartMTime;         /** 분석 시작 Micro Time */
	STIME   uiOpEndTime;            /** 마지막 처리 Time */
	MTIME   uiOpEndMTime;           /** 마지막 처리 Micro Time */
} LOG_RTSP_TRANS;

/**
 * @brief PAGE_SESS_LOG : PAGE 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_ASSOCIATION typedef struct _st_Page_Log {
	<STG_COMMON:LOG_COMMON>

    IP4     uiServerIP;             												/**< First Server IP */

	STIME	FirstTcpSynTime:STG_Equal(pLOG_HTTP_TRANS->uiTcpSynTime):FIRST;			/**< First Tcp Syn Time */
	MTIME	FirstTcpSynMTime:STG_Equal(pLOG_HTTP_TRANS->uiTcpSynMTime):FIRST;		/**< First Tcp Syn Micro Time */
	U32		PageID;				/**< PAGE ID */
	DEF		<TAG_DEFINE:PLATFORMTYPE>LastPlatformType:STG_Equal(pLOG_HTTP_TRANS->usPlatformType):LAST;/**< Last usSvcL4Type / 1000 * 1000 */
	DEF     <TAG_DEFINE:L4CODE>LastSvcL4Type:STG_Equal(pLOG_HTTP_TRANS->usSvcL4Type):LAST;		/**< Last IP, PORT로 판단한 Service type */
	DEF     <TAG_DEFINE:L7CODE>LastSvcL7Type:STG_Equal(pLOG_HTTP_TRANS->usSvcL7Type):LAST;		/**< Last URL, HostName으로 판단한 Service type */
	U8		SubSysNo:STG_Equal(pLOG_HTTP_TRANS->ucSubSysNo):FIRST;				/**< Sub System No. */
	U16		FirstTransID:STG_Equal(pLOG_HTTP_TRANS->usTransID):FIRST;	/**< First HTTP Transaction ID */
	U16		PredictReqCnt;												/**< PAGE의 예상 req수 : body안의 link수 FLOW에서 처리 */
	U16		TrialReqCnt:STG_Equal(pLOG_HTTP_TRANS->link_cnt):FIRST;		/**< PAGE안에 포함된 LINK수 */
	U16		ExecuteReqCnt;												/**< PAGE의 Body Link가 실행된 수 : FLOW에서 처리 */
	U16		NotMatchCnt;			 			@CILOG_HIDDEN@  /**< Not Match Count */ 
	DEF		<TAG_DEFINE:METHOD>FirstMethod:STG_Equal(pLOG_HTTP_TRANS->ucMethod):FIRST;	/**< First Method Code 값 */
	U16		MenuURLSize:STG_Equal(pLOG_HTTP_TRANS->usURLSize):FIRST;		/**< MENU URL Size */
	STRING	MenuURL[MAX_URL_SIZE]:STG_Equal(pLOG_HTTP_TRANS->szURL):FIRST;	/**< MENU URL */
	DEF		<TAG_DEFINE:ContentsType>FirstContentsType:STG_Equal(pLOG_HTTP_TRANS->usContentsType):FIRST; @CILOG_HIDDEN@	/**< First Content-Type */
	STRING	szFirstContentsType[MAX_CONTENTSTYPE_SIZE]:STG_Equal(pLOG_HTTP_TRANS->szContentsType):FIRST;  /**< First Content-Type */
	STIME	FirstL7ReqStartTime:STG_Equal(pLOG_HTTP_TRANS->uiReqStartTime):FIRST;			/**< First GET/POST Request Start Time */
	MTIME	FirstL7ReqStartMTime:STG_Equal(pLOG_HTTP_TRANS->uiReqStartMTime):FIRST;		/**< First GET/POST Request Start Micro Time */
	STIME	LastL7MNAckTime:STG_Equal(pLOG_HTTP_TRANS->uiMNAckTime):LAST;			/**< 마지막 L7 Transaction의 MN Ack Time */
	MTIME	LastL7MNAckMTime:STG_Equal(pLOG_HTTP_TRANS->uiMNAckMTime):LAST;			/**< 마지막 L7 Transaction의 MN Ack Micro Time */
	STIME	LastL7LastPktTime:STG_Equal(pLOG_HTTP_TRANS->uiLastPktTime):LAST;			/**< 마지막 L7 Transaction의 Last Packet Time */
	MTIME	LastL7LastPktMTime:STG_Equal(pLOG_HTTP_TRANS->uiLastPktMTime):LAST;			/**< 마지막 L7 Transaction의 Last Packet Micro Time */
	STIME	FirstNotRedirectReqTime;		/**< 응답이 Redirection인 Req에서 응답이 Redirection이 아닌 요청이 나올 때까지 걸리는 시간의 합(micro 단위) Delay = FirstNotRedirectREqTime ? FirstL7ReqStartTime */
	MTIME	FirstNotRedirectReqMTime;		/**< 응답이 Redirection인 Req 시간 */
	U32		IPDataUpPktCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataUpPktCnt):LAST;				/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		IPDataDnPktCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataDnPktCnt):LAST;				/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		IPTotUpPktCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotUpPktCnt):LAST;				/**< MN => Server, 전구간에서 패킷 개수 */
	U32		IPTotDnPktCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotDnPktCnt):LAST;				/**< Server => MN, 전구간에서 패킷 개수 */
	U32		IPDataUpRetransCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataUpRetransCnt):LAST;			/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		IPDataDnRetransCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataDnRetransCnt):LAST;			/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		IPTotUpRetransCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotUpRetransCnt):LAST;			/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		IPTotDnRetransCnt:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotDnRetransCnt):LAST;			/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		IPDataUpPktSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataUpPktSize):LAST;			/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		IPDataDnPktSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataDnPktSize):LAST;			/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		IPTotUpPktSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotUpPktSize):LAST;				/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		IPTotDnPktSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotDnPktSize):LAST;				/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		IPDataUpRetransSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataUpRetransSize):LAST;		/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		IPDataDnRetransSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPDataDnRetransSize):LAST;		/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		IPTotUpRetransSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotUpRetransSize):LAST;			/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		IPTotDnRetransSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiIPTotDnRetransSize):LAST;			/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		RTPUpPktCnt;				/**< UDP 총 패킷수 (단말 -> 서버) */
	U32		RTPDnPktCnt;				/**< UDP 총 패킷수 (서버 -> 단말) */
	U32		RTPIPUpPktSize;				/**< IP 패킷 크기 (단말 -> 서버) */
	U32		RTPIPDnPktSize;				/**< IP 패킷 크기 (단말 <- 서버) */
	U32		RTPUDPUpBodySize;			/**< UDP 패킷 크기 (단말 -> 서버) */
	U32		RTPUDPDnBodySize;			/**< UDP 패킷 크기 (단말 <- 서버) */
	U32		TcpUpBodySize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiTcpUpBodySize):LAST;				/**< MN => Server, TCP Payload Size */
	U32		TcpDnBodySize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiTcpDnBodySize):LAST;				/**< Server => MN, TCP Payload Size */
	U32		L7UpHeaderSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiUpHeaderSize):LAST;				/**< MN => Server, HTTP/RTSP Header Size */
	U32		L7DnHeaderSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiDnHeaderSize):LAST;				/**< Server => MN, HTTP/RTSP Header Size */
	U32		L7UpBodySize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiUpBodySize):LAST;				/**< MN => Server, HTTP/RTSP Body Size */
	U32		L7DnBodySize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiDnBodySize):LAST;				/**< Server => MN, HTTP/RTSP Body Size */
	DEF		<TAG_DEFINE:CLI>TcpClientStatus:STG_Equal(pLOG_HTTP_TRANS->ucTcpClientStatus):LAST;		/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>TcpServerStatus:STG_Equal(pLOG_HTTP_TRANS->ucTcpServerStatus):LAST;		/**< 서버 상태 */
	DEF		<TAG_DEFINE:LOG_HTTP_STATUS>LastL7Status:STG_Equal(pLOG_HTTP_TRANS->ucStatus):LAST;		/**< HTTP 서비스 상태 */
	U16		PageStatus;					/**< Page Status - 1: Redirection Status  2: Redirect 가 아닌 것 */
	U32		LastUserErrorCode;			/**< NTAS Error Code : HTTP가 올때마다 PAGE에서 처리 */
	DEF		<TAG_DEFINE:L4FAILCODE>LastL4FailCode:STG_Equal(pLOG_HTTP_TRANS->usL4FailCode):LAST;	/**< TCP Fail Code */
	U32		LastL7FailCode:STG_Equal(pLOG_HTTP_TRANS->usUserErrorCode):LAST;					/**< HTTP Fail Code */
	STRING	LastAppFailCode[MAX_APPFAILCODE_SIZE]:STG_Equal(pLOG_HTTP_TRANS->szAppFailCode):LAST;	/**< Last MARS Application Fail Code */
	U16		LastResCode:STG_Equal(pLOG_HTTP_TRANS->usResCode):LAST;				/**< HTTP Response Code */
	U16		RedirectCnt;				/**< RedirectTransaction의 개수 (응답코드 3XX를 Redirect로 간주) */
	U16 	TransCnt:STG_INC(pLOG_HTTP_TRANS):LAST;								/**< 이 페이지를 구성하는 전체 트랜젝션 수 */
	U16 	TransSuccCnt:STG_OVER_INC(pLOG_HTTP_TRANS->usUserErrorCode, 0):LAST;/**< 이 페이지를 구성하는 전체 성공 트랜젝션 수 */
	STRING	FirstMenuID[MAX_MENUID_SIZE]:STG_Equal(pLOG_HTTP_TRANS->MenuID):FIRST;	
											/**< VOD/Dosirak => Menu ID 
											 BREW ADS/PAS-BREW => :Application ID
											 WIPI MARS => Application ID */
	STRING	FirstSvcAction[MAX_SVCACTION_SIZE]:STG_Equal(pLOG_HTTP_TRANS->SvcAction):FIRST;	
												/**< VOD/Dosirak => SvcType 
												 BREW ADS/PAS-BREW => getFile
												 WIPI MARS => 요청 코드 */
	STRING	FirstContentID[MAX_CONTENTID_SIZE]:STG_Equal(pLOG_HTTP_TRANS->ContentID):FIRST;	/**< VOD/Dosirak Download인 경우 Contents ID */
	STRING	FirstCATID[MAX_CATID_SIZE]:STG_Equal(pLOG_HTTP_TRANS->CATID):FIRST;		
												/**< VOD/Dosirak Download 인 경우 CATID
												BREW ADS/PAS-BREW Type 인 경우 PKGID
												WIPI MARS인 경우 product ID */
	S64		PageGapTime:STG_DiffTIME64(pthis->LastL7LastPktTime,pthis->LastL7LastPktMTime,pthis->FirstL7ReqStartTime,pthis->FirstL7ReqStartMTime):LAST;				/**< LastL7LastPktTime - FirstL7ReqStartTime */
	S64		MaidenGapTime:STG_DiffTIME64(pthis->LastL7LastPktTime,pthis->LastL7LastPktMTime,pthis->FirstTcpSynTime,pthis->FirstTcpSynMTime):LAST;				/**< 초기접속화면사용시간을 위한 값 (LastL7LastPktTime - TcpSynTime) */
	STIME	OpStartTime;			/** 분석 시작 Time */
	MTIME	OpStartMTime;			/** 분석 시작 Micro Time */
	STIME	OpEndTime;			/** 마지막 처리 Time */
	MTIME	OpEndMTime;			/** 마지막 처리 Micro Time */
	U32		isCDU:STG_Equal(pLOG_HTTP_TRANS->isCDU):LAST;	/**< isCDU */
} LOG_PAGE_TRANS;

/**
 * @brief CALL_SESS_LOG : CALL 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_ASSOCIATION typedef struct _st_Call_Log {
	<STG_COMMON:LOG_COMMON>

	STIME	LastPktTime:STG_Equal(pLOG_TCP_SESS->uiTcpLastPktTime):LAST;			/**< Last Packet Time : 호 종료시간 */
	MTIME	LastPktMTime:STG_Equal(pLOG_TCP_SESS->uiTcpLastPktMTime):LAST;			/**< Last Packet Micro Time : 호 종료시간 */
	DEF		<TAG_DEFINE:PLATFORMTYPE>TCPPlatformType:STG_Equal(pLOG_TCP_SESS->usPlatformType):FIRST; @CILOG_HIDDEN@ /**< First PlatformType of TCP */
	DEF     <TAG_DEFINE:L4CODE>TCPSvcL4Type:STG_Equal(pLOG_TCP_SESS->usSvcL4Type):FIRST; @CILOG_HIDDEN@	/**< First SvcL4Type of TCP */
	DEF		<TAG_DEFINE:PLATFORMTYPE>FirstPlatformType:STG_Equal(pLOG_HTTP_TRANS->usPlatformType):FIRST;			/**< First usSvcL4Type / 1000 * 1000 */
	DEF     <TAG_DEFINE:L4CODE>FirstSvcL4Type:STG_Equal(pLOG_HTTP_TRANS->usSvcL4Type):FIRST;		/**< First IP, PORT로 판단한 Service type */
	DEF     <TAG_DEFINE:L7CODE>FirstSvcL7Type:STG_Equal(pLOG_HTTP_TRANS->usSvcL7Type):FIRST;	/**< First URL, HostName으로 판단한 Service type */
	DEF		<TAG_DEFINE:PLATFORMTYPE>LastPlatformType:STG_Equal(pLOG_HTTP_TRANS->usPlatformType):LAST;						/**< Last usSvcL4Type / 1000 * 1000 */
	DEF     <TAG_DEFINE:L4CODE>LastSvcL4Type:STG_Equal(pLOG_HTTP_TRANS->usSvcL4Type):LAST;		/**< Last IP, PORT로 판단한 Service type */
	DEF     <TAG_DEFINE:L7CODE>LastSvcL7Type:STG_Equal(pLOG_HTTP_TRANS->usSvcL7Type):LAST;		/**< Last URL, HostName으로 판단한 Service type */
	U8		SubSysNo:STG_Equal(pLOG_TCP_SESS->ucSubSysNo):FIRST;								/**< Sub System No. */
	U32		IPDataUpPktCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataUpPktCnt):LAST;				/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		IPDataDnPktCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataDnPktCnt):LAST;				/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		IPTotUpPktCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotUpPktCnt):LAST;				/**< MN => Server, 전구간에서 패킷 개수 */
	U32		IPTotDnPktCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotDnPktCnt):LAST;				/**< Server => MN, 전구간에서 패킷 개수 */
	U32		IPDataUpRetransCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataUpRetransCnt):LAST;			/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		IPDataDnRetransCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataDnRetransCnt):LAST;			/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		IPTotUpRetransCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotUpRetransCnt):LAST;			/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		IPTotDnRetransCnt:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotDnRetransCnt):LAST;			/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		IPDataUpPktSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataUpPktSize):LAST;			/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		IPDataDnPktSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataDnPktSize):LAST;			/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		IPTotUpPktSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotUpPktSize):LAST;				/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		IPTotDnPktSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotDnPktSize):LAST;				/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		IPDataUpRetransSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataUpRetransSize):LAST;		/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		IPDataDnRetransSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPDataDnRetransSize):LAST;		/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		IPTotUpRetransSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotUpRetransSize):LAST;			/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		IPTotDnRetransSize:STG_ACCUMULATE(pLOG_TCP_SESS->uiIPTotDnRetransSize):LAST;			/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		RTPUpPktCnt;				/**< UDP 총 패킷수 (단말 -> 서버) */
	U32		RTPDnPktCnt;				/**< UDP 총 패킷수 (서버 -> 단말) */
	U32		RTPIPUpPktSize;				/**< IP 패킷 크기 (단말 -> 서버) */
	U32		RTPIPDnPktSize;				/**< IP 패킷 크기 (단말 <- 서버) */
	U32		RTPUDPUpBodySize;			/**< UDP 패킷 크기 (단말 -> 서버) */
	U32		RTPUDPDnBodySize;			/**< UDP 패킷 크기 (단말 <- 서버) */
	U32		TcpUpBodySize:STG_ACCUMULATE(pLOG_TCP_SESS->uiTcpUpBodySize):LAST;				/**< MN => Server, TCP Payload Size */
	U32		TcpDnBodySize:STG_ACCUMULATE(pLOG_TCP_SESS->uiTcpDnBodySize):LAST;				/**< Server => MN, TCP Payload Size */
	U32		L7UpHeaderSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiUpHeaderSize):LAST;				/**< MN => Server, HTTP/RTSP Header Size */
	U32		L7DnHeaderSize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiDnHeaderSize):LAST;				/**< Server => MN, HTTP/RTSP Header Size */
	U32		L7UpBodySize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiUpBodySize):LAST;				/**< MN => Server, HTTP/RTSP Body Size */
	U32		L7DnBodySize:STG_ACCUMULATE(pLOG_HTTP_TRANS->uiDnBodySize):LAST;				/**< Server => MN, HTTP/RTSP Body Size */
	DEF		<TAG_DEFINE:CLI>TcpClientStatus:STG_Equal(pLOG_TCP_SESS->ucTcpClientStatus):LAST;		/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>TcpServerStatus:STG_Equal(pLOG_TCP_SESS->ucTcpServerStatus):LAST;		/**< 서버 상태 */
	DEF		<TAG_DEFINE:LOG_HTTP_STATUS>LastL7Status:STG_Equal(pLOG_HTTP_TRANS->ucStatus):LAST;		/**< HTTP 서비스 상태 */
	U16		LastPageStatus;					/**< Last Page Status - 1: Redirection Status  2: Redirect 가 아닌 것 */
	DEF		<TAG_DEFINE:L4FAILCODE>LastL4FailCode:STG_Equal(pLOG_TCP_SESS->usL4FailCode):LAST;	/**< TCP Fail Code */
	U32		LastL7FailCode:STG_Equal(pLOG_HTTP_TRANS->usL7FailCode):LAST;					/**< HTTP Fail Code */
	U32		LastUserErrorCode:STG_Equal(pLOG_HTTP_TRANS->usUserErrorCode):LAST;			/**< NTAS Error Code */
	S64		CallGapTime:STG_DiffTIME64(pthis->LastPktTime,pthis->LastPktMTime,pthis->uiCallTime,pthis->uiCallMTime):LAST;	/**< LastPktTime - CallTime */
	STIME	OpStartTime;			/**< 분석 시작 Time */
	MTIME	OpStartMTime;			/**< 분석 시작 Micro Time */
	STIME	OpEndTime;			/**< 마지막 처리 Time */
	MTIME	OpEndMTime;			/**< 마지막 처리 Micro Time */
} LOG_CALL_TRANS;

/*
 * @brief LOG_DIALUP_SESS: 
 *
 * @see common_stg.h
 * @note   nothing
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_Dialup_Access_Log {
    <STG_COMMON:LOG_COMMON>

	DEF         	<TAG_DEFINE:PLATFORMTYPE>usPlatformType;
    DEF         	<TAG_DEFINE:L4CODE>usSvcL4Type;
    DEF         	<TAG_DEFINE:L7CODE>usSvcL7Type;

	
    STIME			SessStartTime; 		@CILOG_HIDDEN@
    MTIME			SessStartMTime; 	@CILOG_HIDDEN@
    STIME			LastPktTime;
    MTIME			LastPktMTime;
    STIME			SessEndTime;
    MTIME			SessEndMTime;
    U32				SessDuration;

	U32				UpPktCnt;										/**< 총 패킷 수 (단말 -> 서버) */
	U32				DnPktCnt;										/**< 총 패킷 수 (서버 -> 단말) */
	U32				UpPktSize;										/**< 총 패킷 크기 (단말 -> 서버) */
	U32				DnPktSize;										/**< 총 패킷 크기 (단말 <- 서버) */
	U32				UpDataSize;										/**< 데이타 패킷 크기 (단말 -> 서버) */
	U32				DnDataSize;										/**< 데이타 패킷 크기 (단말 <- 서버) */

	STIME       	OpStartTime;									/**<  분석 시작 Time */
    MTIME       	OpStartMTime;									/**<  분석 시작 Micro Time */
    STIME       	OpEndTime;										/**<  마지막 처리 Time */
    MTIME       	OpEndMTime;										/**<  마지막 처리 Micro Time */
} LOG_DIALUP_SESS;


<TAG_AUTO_DEFINE_START :PAGE_STATE(500)>
STS_INIT
STS_NEW_PAGE
STS_NOTMODFIED
STS_REDIRECT
STS_RED_NOTMODIFIED
STS_RED_MATCH
STS_OK
STS_MENU
STS_TEXT
STS_TEXT_COM
STS_TEXT_BODY_COM
STS_TEXT_COM_RES
STS_TEXT_RES_NOTMODI
STS_DOWNLOAD
STS_CHECK_FB
STS_ABNORMAL_OTHER
STS_CHECK_RES_FB
<TAG_AUTO_DEFINE_END:PAGE_STATE>

<TAG_AUTO_DEFINE_START :L7CTYPE(200)>
L7CTYPE_VOD_STREAMING
L7CTYPE_NDWN
L7CTYPE_DOSIRAK_VOD_DN
L7CTYPE_HTML
L7CTYPE_SIS
<TAG_AUTO_DEFINE_END:L7CTYPE>

typedef struct _st_CALL_CLEAR_KEY {
	U32 		uiSrcIP;
	U32 		uiReserved;
} CALL_KEY;

#define     MAX_BODY_STR_SIZE       MAX_URL_SIZE
#define     MAX_BODY_STR_LEN       	MAX_BODY_STR_SIZE-1
#define     MAX_URL_CNT             28

#define		DEF_MENUTITLE_TIMEOUT	3600

typedef struct _st_MENUTITLE_KEY {
	U16		href_len;
	STRING  href[MAX_BODY_STR_SIZE];
} MENU_TITLE_KEY;

typedef struct _st_MENUTITLE_DATA {
	U64		timerNID; 			/**< TIMERNID */
	U16		menutitle_len;
	STRING  menutitle[MAX_MENUTITLE_SIZE];
} MENU_TITLE_DATA;

typedef struct _st_BODY_STR {
	U16     type;   
	U16     len;    
	STRING     str[MAX_BODY_STR_SIZE];
} STR_LIST;

typedef struct _st_List {
	U32         listcnt;
	STR_LIST    strlist[MAX_URL_CNT];
} st_LIST;

typedef struct _st_Body {
	U16			<TAG_DEFINE:REDIRECT>redirect_url_type;		/**< 꼭 필요한 값인가....		**/
	U16			redirect_url_len;							/**< aURLList를 사용하면 안되나....??? **/
	STRING		redirect_url[MAX_BODY_STR_SIZE];			/**< aURLList를 사용하면 안되나... ???? **/
	U32			link_cnt;									/**< 첫페이지에 따라오는 link수 **/
	U32			href_cnt;									/**< href link count **/
	st_LIST		aLIST;
} BODY;

#define		GET_BODY_SIZE(body, size)																	\
			{ 																							\
				size = BODY_SIZE - STR_LIST_SIZE * (MAX_URL_CNT - body->aLIST.listcnt);					\
			}

typedef struct _st_page_data {
	OFFSET 		offset_BODY;
	BODY 		*pBODY;			/**< PAGE 정보에 가지고 있는 BODY 정보 ????? **/
	OFFSET 		offset_InBODY;
	BODY		*pInBODY;		/**< 이번 LOG_HTTP_TRANS에 같이 넘어온 데이터 BODY : 꼭 필요하네요. **/
	U16			szLastURLLen;		/**< FIMM DOWNLOAD에서 사용되는 Last URL Len **/
	STRING		szLastURL[MAX_URL_SIZE]; /**< FIMM DOWNLOAD에서 사용되는 Last URL **/
	U16			LocationLen;		/**< FIMM DOWNLOAD에서 사용되는 Last URL Len **/
	STRING		Location[MAX_URL_SIZE]; /**< FIMM DOWNLOAD에서 사용되는 Last URL **/
} PAGE_DATA;

/* TAG_FLOW_START에서 사용할 structure에는 
이름 PAGE (여기서는 PAGE사용)
이름_STATE 라는 변수가 꼭 사용되어져야 한다. */
typedef struct _st_call_session_hash_DATA {
	U64					timerNID; 			/**< TIMERNID */
	DEF					<TAG_DEFINE:PAGE_STATUS>PAGE_STATE;
	DEF					<TAG_DEFINE:PAGE_STATUS>PAGE_OLD_STATE;
	U32					PAGE_ID;
	U32					IV_PAGE_ID;
	stMEMSINFO 			*pMEMSINFO;
	stHASHOINFO 		*pHASHOINFO;
	stTIMERNINFO 		*pTIMERNINFO;
	LOG_COMMON			aLOG_COMMON;
	OFFSET 				offset_CALL;
	LOG_CALL_TRANS		*pLOG_CALL_TRANS;
	OFFSET 				offset_PAGE;
	LOG_PAGE_TRANS		*pLOG_PAGE_TRANS;
	OFFSET 				offset_DIALUP;
	LOG_DIALUP_SESS		*pLOG_DIALUP_SESS;
	PAGE_DATA			aPAGE_DATA;
	S32 				(*func1)(void *);			/* Send_Page_Session_LOG */
	S32					isMatch;
	S32					isServiceFlag;				/* Send Service Start Signal */
	S32					isStopFlag;					/* Accounting Request Stop Signal */
	S32 				isSuccDNSFlag;				/* DNS Status Flag */
	S32 				isCallType;					/* 호타입 착신/발신 */
	S32					uiPDSNIP;
	STIME				LastPktTime;
	MTIME				LastPktMTime;
} CALL_SESSION_HASH_DATA;

typedef struct _st_call_dup_hash_DATA {
	S32				CurrCallSessF;					/* Current Session Flag */
	S32				NextCallSessF;					/* Next Session Flag */
	S32 			CurrCallWaitF;					/* Wait Accounting Request Start Message */
	S32 			NextCallWaitF;					
	STIME			CurrCallTime;
	STIME			NextCallTime;
	STIME			CurrLastPktTime;
	STIME			NextLastPktTime;
	OFFSET 			CallDupList[2];					/* Current Session, Next Session */
} CALL_DUP_HASH_DATA;

<TAG_FLOW_START:PAGE(pTHIS-CALL_SESSION_HASH_DATA,pINPUT-LOG_HTTP_TRANS)>
%STS_INIT  :OTHERMSG:(D)1:(Y)1:STS_NEW_PAGE%  #{
	FPRINTF(LOG_LEVEL, "%s :  INIT pINPUT=%p" , (char *)__FUNCTION__, pINPUT);
    // Update Call Log (Update해야 하는 값으로는 LastPageStatus 값만 존재함.)
	pTHIS->pLOG_CALL_TRANS->LastPageStatus = pTHIS->PAGE_OLD_STATE;
	pTHIS->pLOG_PAGE_TRANS->PageStatus = pTHIS->PAGE_OLD_STATE;
	}#
%STS_NEW_PAGE   :CONTINUE:(D)pINPUT->usResCode/100:(Y)3:STS_NOTMODFIED%  ##
%STS_NEW_PAGE   :CONTINUE:(D)pINPUT->usResCode/100:(N)0:STS_OK%  #{
	FPRINTF(LOG_LEVEL, "%s : new_page default" , (char *)__FUNCTION__);
    if(pTHIS->pLOG_PAGE_TRANS != NULL) {
/* debugging code for KTF (case respcode 302)
		if(pTHIS->pLOG_PAGE_TRANS->LastResCode == 302){
			FPRINTF(LOG_BUG,"IP %d.%d.%d.%d ,URL %.*s"
				, HIPADDR(pINPUT->uiClientIP)  
				,MAX_URL_SIZE,pINPUT->szURL 
				);
			FPRINTF(LOG_BUG,"Res %d, MIN %.*s"
				, pINPUT->usResCode 
				, MAX_MIN_SIZE,pINPUT->szMIN 
				);
			FPRINTF(LOG_BUG,"L4FC %d, STATE %ld , PAGEID %d, LastURL %.*s"
				,pTHIS->pLOG_PAGE_TRANS->LastL4FailCode 
				,pTHIS->PAGE_STATE 
				, pTHIS->PAGE_ID 
				,MAX_URL_SIZE, pTHIS->aPAGE_DATA.szLastURL
				);
			FPRINTF(LOG_BUG,"L7FC %d, OLD %d, Location %.*s"
				,pTHIS->pLOG_PAGE_TRANS->LastL7FailCode
				, pTHIS->PAGE_OLD_STATE 
				,MAX_URL_SIZE, pTHIS->aPAGE_DATA.Location
				);
		}
*/
		// Send Page Log 
		// Send_Page_Session_LOG(pTHIS);
		pTHIS->func1(pTHIS);
    }
    }#
%STS_NOTMODFIED :CONTINUE:(D)pINPUT->usResCode:(Y)304:STS_OK%  ##
%STS_NOTMODFIED :CONTINUE:(D)pINPUT->usResCode:(N)0:STS_REDIRECT% #{
	FPRINTF(LOG_LEVEL, "%s : pINPUT [RESCODE:%d]", (char *)__FUNCTION__, pINPUT->usResCode); 
	}#
%STS_REDIRECT   :OTHERMSG:(D)pINPUT->usResCode/100:(Y)3:STS_RED_NOTMODIFIED%  ##
%STS_REDIRECT   :OTHERMSG:(D)pINPUT->usResCode/100:(N)0:STS_RED_MATCH%  #{
	 FPRINTF(LOG_LEVEL, "%s : redirect 1 check: [%d] URL[%.*s]", 
	 	(char *)__FUNCTION__, pINPUT->usResCode, MAX_URL_SIZE, pINPUT->szURL);
	// pTHIS->aPAGE_DATA.Location[MAX_URL_LEN] = 0;
	// pINPUT->Location[MAX_URL_LEN] = 0;
	//  memcpy(pTHIS->aPAGE_DATA.Location,pINPUT->Location,MAX_URL_SIZE);
	pTHIS->pLOG_CALL_TRANS->LastPageStatus = pTHIS->PAGE_OLD_STATE;
	pTHIS->pLOG_PAGE_TRANS->PageStatus = pTHIS->PAGE_OLD_STATE;
	pTHIS->pLOG_PAGE_TRANS->RedirectCnt++;
	{
		U32 dRet;
		U16 usURLSize = strlen(pINPUT->szURL);
		U16 usLocSize = strlen(pINPUT->Location);
		// Remove URL Port 
	 	dRet = Remake_URL_Buf(
					usURLSize, pINPUT->szURL, &pTHIS->aPAGE_DATA.szLastURLLen, pTHIS->aPAGE_DATA.szLastURL);
		if(dRet < 0) {
			FPRINTF(LOG_LEVEL, "%s REMAKE_URL_BUF STS_REDIRECT Err[%d]", (char *)__FUNCTION__, dRet);
			pTHIS->aPAGE_DATA.LocationLen = 0;
			pTHIS->aPAGE_DATA.Location[0] = 0x00;
		} else {

			if((pINPUT->szURL[usURLSize-1] == '/') && (pTHIS->aPAGE_DATA.szLastURLLen < MAX_URL_LEN - 1)) {
				pTHIS->aPAGE_DATA.szLastURL[pTHIS->aPAGE_DATA.szLastURLLen] = '/';  
				pTHIS->aPAGE_DATA.szLastURLLen++;                                   
				pTHIS->aPAGE_DATA.szLastURL[pTHIS->aPAGE_DATA.szLastURLLen] = 0x00;
			}

			dRet = Make_Absolute_URL_Buf(pTHIS->aPAGE_DATA.szLastURLLen, pTHIS->aPAGE_DATA.szLastURL, 
						usLocSize, pINPUT->Location, &pTHIS->aPAGE_DATA.LocationLen, pTHIS->aPAGE_DATA.Location);
			if(dRet < 0) {
				FPRINTF(LOG_LEVEL, "%s MAKE_ABSO_URL_BUF Err[%d]", (char *)__FUNCTION__, dRet);
				pTHIS->aPAGE_DATA.LocationLen = 0;
				pTHIS->aPAGE_DATA.Location[0] = 0x00;
			} else {
				FPRINTF(LOG_LEVEL, "%s MAKE_ABSO_URL_BUF ORG[%d][%.*s]", (char *)__FUNCTION__, dRet, 
					MAX_URL_SIZE, pINPUT->Location);
				FPRINTF(LOG_LEVEL, "%s MAKE_ABSO_URL_BUF DST[%d][%.*s]", (char *)__FUNCTION__, dRet, 
					MAX_URL_SIZE, pTHIS->aPAGE_DATA.Location);
			}
		}
	}
	}#
%STS_RED_NOTMODIFIED :CONTINUE:(D)pINPUT->usResCode:(Y)304:STS_RED_MATCH%  ##
%STS_RED_NOTMODIFIED :CONTINUE:(D)pINPUT->usResCode:(N)0:STS_REDIRECT%  #{
	FPRINTF(LOG_LEVEL, "%s : STS_RED_NOTMODIFIED pINPUT->usResCode[%d]", (char *)__FUNCTION__, pINPUT->usResCode);
	}#
%STS_RED_MATCH  :CONTINUE:(S)pTHIS->aPAGE_DATA.Location:(Y)pTHIS->aPAGE_DATA.szLastURL:STS_OK%  ##
%STS_RED_MATCH  :CONTINUE:(S)pTHIS->aPAGE_DATA.Location:(N)pTHIS->aPAGE_DATA.szLastURL:STS_NEW_PAGE%  #{
	FPRINTF(LOG_LEVEL, "%s : red_match : [%.*s] check [%.*s]", (char *)__FUNCTION__, MAX_URL_SIZE,pINPUT->szURL, MAX_URL_SIZE,pTHIS->aPAGE_DATA.Location);
	{
		U32 dRet;
		U16 usSize = strlen(pINPUT->szURL);
		// Remove URL Port 
	 	dRet = Remake_URL_Buf(
					usSize, pINPUT->szURL, &pTHIS->aPAGE_DATA.szLastURLLen, pTHIS->aPAGE_DATA.szLastURL);
		if(dRet < 0) {
			FPRINTF(LOG_LEVEL, "%s REMAKE_URL_BUF Err[%d]", (char *)__FUNCTION__, dRet);
			pTHIS->aPAGE_DATA.szLastURLLen = 0;
			pTHIS->aPAGE_DATA.szLastURL[0] = 0x00;
		}
	}
	}#
%STS_OK     :CONTINUE:(D)pINPUT->usSvcL7Type:(Y)APP_MENU:STS_MENU%  ##
%STS_OK     :CONTINUE:(D)pINPUT->usSvcL7Type:(Y)APP_DOWN:STS_DOWNLOAD%  ##
%STS_OK     :CONTINUE:(D)pINPUT->usSvcL7Type:(N)0:STS_INIT%  #{
	// Redirection이 아닌 Request Packet
	pTHIS->pLOG_PAGE_TRANS->FirstNotRedirectReqTime = pINPUT->uiReqStartTime;
	pTHIS->pLOG_PAGE_TRANS->FirstNotRedirectReqMTime = pINPUT->uiReqStartMTime;
	FPRINTF(LOG_LEVEL, "%s : ok - l7code = %ld",(char *)__FUNCTION__, pINPUT->usSvcL7Type); 
	}#
%STS_MENU   :CONTINUE:(D)pINPUT->usContentsType:(Y)CTYPE_HTML:STS_TEXT%  ##
%STS_MENU   :CONTINUE:(D)pINPUT->usContentsType:(Y)CTYPE_WML:STS_TEXT%  ##
%STS_MENU   :CONTINUE:(D)pINPUT->usContentsType:(Y)CTYPE_MULTI:STS_TEXT%  ##
%STS_MENU   :CONTINUE:(D)pINPUT->usContentsType:(N)0:STS_CHECK_FB%  #{
	FPRINTF(LOG_LEVEL, "%s : MENU : cType=[%ld]", (char *)__FUNCTION__, pINPUT->usContentsType); 
	}#
%STS_TEXT   :CONTINUE:(C)pTHIS->aPAGE_DATA.pBODY:(Y)0:STS_CHECK_FB%  ##
%STS_TEXT   :CONTINUE:(C)pTHIS->aPAGE_DATA.pBODY:(N)0:STS_TEXT_COM%  #{
	FPRINTF(LOG_LEVEL, "%s : A: pBODY[%p] pINPUT=%p", (char *)__FUNCTION__, pTHIS->aPAGE_DATA.pBODY, pINPUT);
	
	if(pTHIS->aPAGE_DATA.pBODY != NULL){
		FPRINTF(LOG_LEVEL,"STS_TEXT %s : ERROR",(char *)__FUNCTION__);
		//		pTHIS->aPAGE_DATA.pBODY 메모리 해제
		U8 *__pNODE;
		__pNODE = (U8 *) nifo_ptr(pTHIS->pMEMSINFO, nifo_get_offset_node(pTHIS->pMEMSINFO, (U8 *) pTHIS->aPAGE_DATA.pBODY));
		nifo_node_delete(pTHIS->pMEMSINFO, __pNODE);
	}

	pTHIS->aPAGE_DATA.pBODY = pTHIS->aPAGE_DATA.pInBODY;		// PAGE 정보에 BODY정보 Assign
	pTHIS->aPAGE_DATA.offset_BODY = pTHIS->aPAGE_DATA.offset_InBODY;
	pTHIS->aPAGE_DATA.pInBODY = NULL; 
	pTHIS->aPAGE_DATA.offset_InBODY = 0;
	FPRINTF(LOG_LEVEL, "%s : B: pBODY[%p]", (char *)__FUNCTION__, pTHIS->aPAGE_DATA.pBODY);

	}#
%STS_TEXT_COM   :OTHERMSG:(C)pTHIS->aPAGE_DATA.pBODY:(Y)0:STS_NEW_PAGE%  #{
%STS_TEXT_COM   :OTHERMSG:(C)pTHIS->aPAGE_DATA.pBODY:(N)0:STS_TEXT_BODY_COM%  ##
	OFFSET	offset;
	U8      *pROOTNODE, *pDATANODE, *pNEXTNODE, *pHEADNODE;
	BODY	*pPRINTBODY;

	// 여기서는 pBODY는 꼭  존재함.
	pTHIS->pLOG_CALL_TRANS->LastPageStatus = pTHIS->PAGE_OLD_STATE;
	pTHIS->pLOG_PAGE_TRANS->PageStatus = pTHIS->PAGE_OLD_STATE;
	if(pTHIS->pLOG_PAGE_TRANS->PredictReqCnt == 0) {		// 첫번째 들어왔을 경우에만 수행
		pROOTNODE = (U8 *)nifo_ptr(pTHIS->pMEMSINFO, nifo_get_offset_node(pTHIS->pMEMSINFO, (U8 *)pTHIS->aPAGE_DATA.pBODY));
		pDATANODE = pROOTNODE;
		pNEXTNODE = (U8 *)nifo_entry(nifo_ptr(pTHIS->pMEMSINFO, ((NIFO *)pDATANODE)->cont.offset_next), NIFO, cont);

		if(pDATANODE == pNEXTNODE) {
			pTHIS->pLOG_PAGE_TRANS->PredictReqCnt = pTHIS->aPAGE_DATA.pBODY->aLIST.listcnt;
		}
		else {
			while(pDATANODE != NULL) {
				offset = nifo_offset(pTHIS->pMEMSINFO, pDATANODE);
				pPRINTBODY = (BODY *)nifo_get_value(pTHIS->pMEMSINFO, BODY_DEF_NUM, offset);

				pTHIS->pLOG_PAGE_TRANS->PredictReqCnt += pPRINTBODY->aLIST.listcnt;
	
				pNEXTNODE = (U8 *)nifo_entry(nifo_ptr(pTHIS->pMEMSINFO, ((NIFO *)pDATANODE)->cont.offset_next), NIFO, cont);
				if(pROOTNODE == pNEXTNODE) pNEXTNODE = NULL;
				pDATANODE = pNEXTNODE;
			}
		}
	}
	else {												// BODY에 있는 URL인 경우 Count
		pTHIS->pLOG_PAGE_TRANS->ExecuteReqCnt++;


		if(pTHIS->aPAGE_DATA.pInBODY != NULL) {
			pROOTNODE = (U8 *)nifo_ptr(pTHIS->pMEMSINFO, nifo_get_offset_node(pTHIS->pMEMSINFO, (U8 *)pTHIS->aPAGE_DATA.pInBODY));
			pDATANODE = pROOTNODE;
			pNEXTNODE = (U8 *)nifo_entry(nifo_ptr(pTHIS->pMEMSINFO, ((NIFO *)pDATANODE)->cont.offset_next), NIFO, cont);

			if(pDATANODE == pNEXTNODE) {
				pTHIS->pLOG_PAGE_TRANS->PredictReqCnt += pTHIS->aPAGE_DATA.pInBODY->aLIST.listcnt;
			}
			else {
				while(pDATANODE != NULL) {
					offset = nifo_offset(pTHIS->pMEMSINFO, pDATANODE);
					pPRINTBODY = (BODY *)nifo_get_value(pTHIS->pMEMSINFO, BODY_DEF_NUM, offset);

					pTHIS->pLOG_PAGE_TRANS->PredictReqCnt += pPRINTBODY->aLIST.listcnt;
	
					pNEXTNODE = (U8 *)nifo_entry(nifo_ptr(pTHIS->pMEMSINFO, ((NIFO *)pDATANODE)->cont.offset_next), NIFO, cont);
					if(pROOTNODE == pNEXTNODE) pNEXTNODE = NULL;
					pDATANODE = pNEXTNODE;
				}
			}

			pHEADNODE = (U8 *)nifo_ptr(pTHIS->pMEMSINFO, nifo_get_offset_node(pTHIS->pMEMSINFO, (U8 *)pTHIS->aPAGE_DATA.pBODY));	
			nifo_splice_cont(pTHIS->pMEMSINFO, pROOTNODE, pHEADNODE);
			pTHIS->aPAGE_DATA.pInBODY = NULL;
			pTHIS->aPAGE_DATA.offset_InBODY = 0;
		}
	}
	FPRINTF(LOG_LEVEL, "%s : text : Body Url Count[%d] pINPUT=%p",(char *)__FUNCTION__, pTHIS->aPAGE_DATA.pBODY->aLIST.listcnt, pINPUT);
	}#
%STS_TEXT_BODY_COM	:CONTINUE:(D)pTHIS->isMatch:(Y)1:STS_TEXT_COM_RES%  ##
%STS_TEXT_BODY_COM	:CONTINUE:(D)pTHIS->isMatch:(N)1:STS_NEW_PAGE%  #{
	{
		U32 dRet;
		U16 usSize = strlen(pINPUT->szURL);
		// Remove URL Port 
	 	dRet = Remake_URL_Buf(
					usSize, pINPUT->szURL, &pTHIS->aPAGE_DATA.szLastURLLen, pTHIS->aPAGE_DATA.szLastURL);
		if(dRet < 0) {
			FPRINTF(LOG_LEVEL, "%s STS_TEXT_BODY_COM REMAKE_URL_BUF Err[%d]", (char *)__FUNCTION__, dRet);
			pTHIS->aPAGE_DATA.szLastURLLen = 0;
			pTHIS->aPAGE_DATA.szLastURL[0] = 0x00;
		}

		pTHIS->isMatch = 0;

		S32			i;
		OFFSET		offset;
		U8      	*pROOTNODE, *pDATANODE, *pNEXTNODE;
		BODY		*pPRINTBODY;
		STR_LIST	*pLIST;

		pROOTNODE = (U8 *)nifo_ptr(pTHIS->pMEMSINFO, nifo_get_offset_node(pTHIS->pMEMSINFO, (U8 *)pTHIS->aPAGE_DATA.pBODY));
		pDATANODE = pROOTNODE;
		pNEXTNODE = (U8 *)nifo_entry(nifo_ptr(pTHIS->pMEMSINFO, ((NIFO *)pDATANODE)->cont.offset_next), NIFO, cont);

		if(pDATANODE == pNEXTNODE) {
			for(i = 0; i < pTHIS->aPAGE_DATA.pBODY->aLIST.listcnt; i++) {
				pLIST = &pTHIS->aPAGE_DATA.pBODY->aLIST.strlist[i];
				if((pTHIS->aPAGE_DATA.szLastURLLen == pLIST->len) && (memcmp(pLIST->str, pTHIS->aPAGE_DATA.szLastURL, pLIST->len) == 0)) {
					pTHIS->isMatch = 1;
					break;
				}
			}
		}
		else {
			while(pDATANODE != NULL) {
				offset = nifo_offset(pTHIS->pMEMSINFO, pDATANODE);
				pPRINTBODY = (BODY *)nifo_get_value(pTHIS->pMEMSINFO, BODY_DEF_NUM, offset);

				for(i = 0; i < pPRINTBODY->aLIST.listcnt; i++) {
					pLIST = &pPRINTBODY->aLIST.strlist[i];
					if((pTHIS->aPAGE_DATA.szLastURLLen == pLIST->len) && (memcmp(pLIST->str, pTHIS->aPAGE_DATA.szLastURL, pLIST->len) == 0)) {
						pTHIS->isMatch = 1;
						break;
					}
				}
	
				if(pTHIS->isMatch > 0) break;
				pNEXTNODE = (U8 *)nifo_entry(nifo_ptr(pTHIS->pMEMSINFO, ((NIFO *)pDATANODE)->cont.offset_next), NIFO, cont);
				if(pROOTNODE == pNEXTNODE) pNEXTNODE = NULL;
				pDATANODE = pNEXTNODE;
			}
		}

		/* Full Browser 예외 처리 */
//		if((pTHIS->isMatch == 0) && (pINPUT->usSvcL4Type == L4_FB)) {
		if(pTHIS->isMatch == 0) {
			switch(pINPUT->usContentsType)
			{
			case CTYPE_IMAGE:
			case CTYPE_SOUND:
			case CTYPE_FLASH:
			case CTYPE_JS:
			case CTYPE_STYLE:
				pTHIS->isMatch = 1;
				pTHIS->pLOG_PAGE_TRANS->NotMatchCnt++;
				break;
			default:
				break;
			}

/* LGT 요청으로 인한 원복 : 20080801 (full browser 사용 시간이 너무 많이 나오는 문제)
			if(pTHIS->isMatch == 0) {
				if((pTHIS->aPAGE_DATA.pInBODY == NULL) || (pTHIS->aPAGE_DATA.pInBODY->aLIST.listcnt == 0))
				{
					pTHIS->isMatch = 1;
					pTHIS->pLOG_PAGE_TRANS->NotMatchCnt++;
				}
			}
*/

			/* amsv2.daum.net */
//			if(pTHIS->isMatch == 0) {
			if((pTHIS->isMatch == 0) && (pINPUT->usSvcL4Type == L4_FB)) {
				char szTmpDaum[BUFSIZ] = "http://amsv2.daum.net/cgi-bin/";
				int	dTmpDaumLen = strlen(szTmpDaum);
				if((pTHIS->aPAGE_DATA.szLastURLLen > dTmpDaumLen) && (memcmp(pTHIS->aPAGE_DATA.szLastURL, szTmpDaum, dTmpDaumLen) == 0))
				{
					pTHIS->isMatch = 1;
					pTHIS->pLOG_PAGE_TRANS->NotMatchCnt++;
				}
			}

			if(pTHIS->isMatch == 1) {
				pTHIS->LastPktTime = pTHIS->pLOG_PAGE_TRANS->LastL7LastPktTime;
				pTHIS->LastPktMTime = pTHIS->pLOG_PAGE_TRANS->LastL7LastPktMTime;
			}
		}
	}
	FPRINTF(LOG_LEVEL, "%s : STS_TEXT_BODY_COM REMAKE URL[%.*s] to URL[%.*s]", 
		(char *)__FUNCTION__, MAX_URL_SIZE, pINPUT->szURL, MAX_URL_SIZE, pTHIS->aPAGE_DATA.szLastURL);
	}#
%STS_TEXT_COM_RES   :CONTINUE:(D)pINPUT->usResCode/100:(Y)3:STS_TEXT_RES_NOTMODI%  ##
%STS_TEXT_COM_RES   :CONTINUE:(D)pINPUT->usResCode/100:(Y)2:STS_TEXT_COM%  ##
%STS_TEXT_COM_RES   :CONTINUE:(D)pINPUT->usResCode/100:(N)0:STS_CHECK_RES_FB%  #{
	FPRINTF(LOG_LEVEL, "%s : TEXT_RES CHECK: pINPUT->usResCode=[%d]", (char *)__FUNCTION__, pINPUT->usResCode);
	}#
%STS_TEXT_RES_NOTMODI :CONTINUE:(D)pINPUT->usResCode:(Y)304:STS_TEXT_COM%  ##
%STS_TEXT_RES_NOTMODI :CONTINUE:(D)pINPUT->usResCode:(N)0:STS_NOTMODFIED% #{
	FPRINTF(LOG_LEVEL, "%s : TEXT_RES_NOTMODI pINPUT [RESCODE:%d]", (char *)__FUNCTION__, pINPUT->usResCode); 
	}#
%STS_DOWNLOAD   :CONTINUE:(D)1:(Y)1:STS_INIT%  #{
	FPRINTF(LOG_LEVEL, "%s : DL_TYPE: dont care pINPUT=%p", (char *)__FUNCTION__, pINPUT); 
	}#
%STS_CHECK_FB   :CONTINUE:(D)pINPUT->usSvcL4Type:(Y)L4_FB:STS_ABNORMAL_OTHER%  ##
%STS_CHECK_FB   :CONTINUE:(D)pINPUT->usSvcL4Type:(N)0:STS_INIT%  #{
	FPRINTF(LOG_LEVEL, "%s : STS_CHECK_FB: SvcL4Type=%ld", (char *)__FUNCTION__, pINPUT->usSvcL4Type); 
	}#
%STS_ABNORMAL_OTHER   :OTHERMSG:(D)pINPUT->usContentsType:(Y)CTYPE_HTML:STS_NEW_PAGE%  ##
%STS_ABNORMAL_OTHER   :OTHERMSG:(D)pINPUT->usContentsType:(Y)CTYPE_MULTI:STS_NEW_PAGE%  ##
%STS_ABNORMAL_OTHER   :OTHERMSG:(D)pINPUT->usContentsType:(Y)CTYPE_WML:STS_NEW_PAGE%  ##
%STS_ABNORMAL_OTHER   :OTHERMSG:(D)pINPUT->usContentsType:(N)0:STS_ABNORMAL_OTHER%  #{
	FPRINTF(LOG_LEVEL, "%s : STS_ABNORMAL_OTHER: LastL7FailCode=%d LastL4FailCode=%ld usUserErrorCode=%d", 
		(char *)__FUNCTION__, 
		pTHIS->pLOG_PAGE_TRANS->LastL7FailCode, pTHIS->pLOG_PAGE_TRANS->LastL4FailCode, pINPUT->usUserErrorCode); 
    {
		pTHIS->pLOG_PAGE_TRANS->ExecuteReqCnt++;
/*
        if(pTHIS->pLOG_PAGE_TRANS->LastL7FailCode == 0) {
			if(pINPUT->usUserErrorCode > 0) {
            	pTHIS->pLOG_PAGE_TRANS->LastL4FailCode = pINPUT->usL4FailCode;
            	pTHIS->pLOG_PAGE_TRANS->LastL7FailCode = pINPUT->usUserErrorCode;
			}
            pTHIS->pLOG_PAGE_TRANS->LastResCode = pINPUT->usResCode;
        }
*/
    }
	}#
%STS_CHECK_RES_FB   :CONTINUE:(D)pINPUT->usSvcL4Type:(Y)L4_FB:STS_TEXT_COM%  ##
%STS_CHECK_RES_FB   :CONTINUE:(D)pINPUT->usSvcL4Type:(N)0:STS_NEW_PAGE%  #{
	FPRINTF(LOG_LEVEL, "%s : STS_CHECK_RES_FB: LastL7FailCode=%d LastL4FailCode=%ld usUserErrorCode=%d", 
		(char *)__FUNCTION__, 
		pTHIS->pLOG_PAGE_TRANS->LastL7FailCode, pTHIS->pLOG_PAGE_TRANS->LastL4FailCode, pINPUT->usUserErrorCode); 
    {
/*
        if(pTHIS->pLOG_PAGE_TRANS->LastL7FailCode == 0) {
			if(pINPUT->usUserErrorCode > 0) {
            	pTHIS->pLOG_PAGE_TRANS->LastL4FailCode = pINPUT->usL4FailCode;
            	pTHIS->pLOG_PAGE_TRANS->LastL7FailCode = pINPUT->usUserErrorCode;
			}
            pTHIS->pLOG_PAGE_TRANS->LastResCode = pINPUT->usResCode;
        }
*/
    }
	}#
<TAG_FLOW_END:PAGE>

/** 설명
  (D)1:(Y(1)   --> Don't Care
  (N) 0        --> 나열된 것 이외의 DEFAULT
  D : 도시락
  V : VOD
  K : KUN
  M : ME
  TD : Tear_down
  DN : Download
**/

#define ONLINE_UERR_EMPTY   0
#define ONLINE_UERR_102     102     /**< 헤더 signature(cp 패킷의 매직코드) 오류 */
#define ONLINE_UERR_105     105     /**< 헤더 길이만큼 받을 수 없거나 최대 패킷 사이즈를 초과함 */
#define ONLINE_UERR_113     113     /**< 포맷이 잘못된 전화번호 */
#define ONLINE_UERR_900     900     /**< 기타 */

/* ONLINE을 위한 정의 절대 수정 불가 */
#define DEF_BREWAPIVER_LEN  10  
#define DEF_BREWEXTVER_LEN  10
#define DEF_HANDSET_LEN     10
#define DEF_CHNL_LEN        2
#define DEF_SID_LEN         5
#define DEF_NID_LEN         5
#define DEF_BID_LEN         5
#define DEF_BSCID_LEN       5
#define DEF_MARSBESTPN_LEN  4
#define DEF_QOS_LEN         5

#define DEF_MARSMIN_LEN     16

#define DEF_CONTENTSID_LEN  12
#define DEF_BREWCHARGENUM_LEN   12
#define DEF_SIGNATURE2_LEN  4

#define DEF_APPID_LEN       10
#define DEF_KTFPAPIVER_LEN  10
#define DEF_KTFPEXTVER_LEN  10
#define DEF_BESTPN_LEN      5

#define DEF_IMSI_LEN        16

#define DEF_CHARGENUM_LEN   16
#define DEF_MNC_LEN         2
/*********************************/

typedef struct _st_MacsBillCom {
    S32         dPacketLen;
    S32         dClassID;
    STRING          szBREWApiVer[DEF_BREWAPIVER_LEN];
    STRING       szBREWExtVer[DEF_BREWEXTVER_LEN];
    STRING       szHandSet[DEF_HANDSET_LEN];
    STRING       szMIN[DEF_MARSMIN_LEN];
    STRING       szChnl[DEF_CHNL_LEN];
    STRING       szSID[DEF_SID_LEN];
    STRING       szNID[DEF_NID_LEN];
    STRING       szBID[DEF_BID_LEN];
    STRING       szBSCID[DEF_BSCID_LEN];
    STRING       szBestPN[DEF_MARSBESTPN_LEN];
    IP4        uiDestIP;
    U16      usDestPort;
    STRING       szQos[DEF_QOS_LEN];
    U8        szReserved[5];
} st_MacsBillCom;

typedef struct _st_Macs {
    S32         dSignature1;
    STRING       szContentsID[DEF_CONTENTSID_LEN];
    STRING       szChargeNumber[DEF_BREWCHARGENUM_LEN];
    U8        szReserved[12];
    U32        uiLen;
    STRING       szSignature2[DEF_SIGNATURE2_LEN];
} st_Macs;

typedef struct _st_WicgsBillCom {
    S32         dPacketLen;
    STRING       szAppID[DEF_APPID_LEN];
    STRING       szKTFPApiVer[DEF_KTFPAPIVER_LEN];
    STRING       szKTFPExtVer[DEF_KTFPEXTVER_LEN];
    STRING       szHandSet[DEF_HANDSET_LEN];
    STRING       szMIN[DEF_IMSI_LEN];
    STRING       szChnl[DEF_CHNL_LEN];
    STRING       szSID[DEF_SID_LEN];
    STRING       szNID[DEF_NID_LEN];
    STRING       szBID[DEF_BID_LEN];
    STRING       szBestPN[DEF_BESTPN_LEN];
    U16      usDestPort;
    IP4        uiDestIP;
    S32         dSockConnTime;
    STRING       szQos[DEF_QOS_LEN];
    STRING       szMNC[DEF_MNC_LEN];
    U8        szReserved[9];
} st_WicgsBillCom;

typedef struct _st_Wicgs {
    S32         dSignature1;
    STRING       szContentsID[DEF_CONTENTSID_LEN];
    STRING       szChargeNumber[DEF_CHARGENUM_LEN];
    S32         dSMFlag;
    U8        szReserved[12];
    U32        uiLen;
    STRING       szSignature2[DEF_SIGNATURE2_LEN];
} st_Wicgs;

TABLE_LOG typedef struct _st_Online_Log {

    <STG_COMMON:LOG_COMMON>

    U16     usClientPort;           /**< 단말 Port */
    IP4     uiServerIP;             /**< Server IP */
    U16     usServerPort;           /**< Server Port */
    IP4     uiAppDestIP;            /**< Billcom Header의 Application Server IP */
    U16     usAppDestPort;          /**< Billcom Header의 Application Server Port */
    STIME   uiTcpSynTime;           /**< Tcp Syn Time */
    MTIME   uiTcpSynMTime;          /**< Tcp Syn Micro Time */
    DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;         /**< usSvcL4Type / 1000 * 1000 */
    DEF     <TAG_DEFINE:L4CODE>usSvcL4Type;         /**< IP, PORT로 판단한 Service type */
    DEF     <TAG_DEFINE:L7CODE>usSvcL7Type;         /**< URL, HostName으로 판단한 Service type */
    U8      ucSubSysNo;             /**< Sub System No. */

    STRING     szApplicationID[MAX_APPLICATION_SIZE];
    STRING     szExtVersion[MAX_EXTVERSION_SIZE];
    STRING     szBSCID[MAX_BSCID_SIZE];
    STRING     szBestPN[MAX_BESTPN_SIZE];
    STRING     szMNC[MAX_MNC_SIZE];

    STIME   uiFirstReqStartTime;            /**< GET/POST Request Start Time */
    MTIME   uiFirstReqStartMTime;       /**< GET/POST Request Start Micro Time */
    STIME   uiFirstResStartTime;            /**< Response Start Time */
    MTIME   uiFirstResStartMTime;       /**< Response Start Micro Time */
    STIME   uiLastPktTime;          /**< Last Packet Time */
    MTIME   uiLastPktMTime;         /**< Last Packet Micro Time */
    S64     llUseGapTime;           /**< LastPktTime - FirstReqStartTime */

    U32     usUserErrorCode;        /**< NTAS Error Code */
    DEF     <TAG_DEFINE:L4FAILCODE>usL4FailCode;    /**< TCP Fail Code */

    U32     uiIPDataUpPktCnt;       /**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
    U32     uiIPDataDnPktCnt;       /**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
    U32     uiIPTotUpPktCnt;        /**< MN => Server, 전구간에서 패킷 개수 */
    U32     uiIPTotDnPktCnt;        /**< Server => MN, 전구간에서 패킷 개수 */
    U32     uiIPDataUpRetransCnt;   /**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
    U32     uiIPDataDnRetransCnt;   /**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
    U32     uiIPTotUpRetransCnt;    /**< MN => Server, 전구간에서 재전송 패킷 개수 */
    U32     uiIPTotDnRetransCnt;    /**< Server => MN, 전구간에서 재전송 패킷 개수 */
    U32     uiIPDataUpPktSize;      /**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
    U32     uiIPDataDnPktSize;      /**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
    U32     uiIPTotUpPktSize;       /**< MN => Server, 전구간에서 데이터 사이즈 */
    U32     uiIPTotDnPktSize;       /**< Server => MN, 전구간에서 데이터 사이즈 */
    U32     uiIPDataUpRetransSize;  /**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
    U32     uiIPDataDnRetransSize;  /**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
    U32     uiIPTotUpRetransSize;   /**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
    U32     uiIPTotDnRetransSize;   /**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
    U32     uiTcpUpBodySize;        /**< MN => Server, TCP Payload Size */
    U32     uiTcpDnBodySize;        /**< Server => MN, TCP Payload Size */

    U32     uiTcpUpRetransBodySize;     /**< MN => Server, 재전송만의 TCP Payload Size의 합 */
    U32     uiTcpDnRetransBodySize;     /**< Server => MN, 재전송만의 TCP Payload Size의 합 */

    U16     usBillcomHeaderCnt;     /**< MN => Server, Billcom Header Count (UP) */
    U16     usServerHeaderCnt;      /**< Server => MN, Wicgs/Macs Header Count (Down) */

    U32     uiL7UpBodySize;         /**< MN => Server, TCP Payload Data중 Billcom Header를 제외한 Data Size */
    U32     uiL7DnBodySize;         /**< Server => MN, TCP Payload Data중 Wicgs/Macs Header를 제외한 Data Size */

    STIME   uiOpStartTime;          /** 분석 시작 Time */
    MTIME   uiOpStartMTime;         /** 분석 시작 Micro Time */
    STIME   uiOpEndTime;            /** 마지막 처리 Time */
    MTIME   uiOpEndMTime;           /** 마지막 처리 Micro Time */
} LOG_ONLINE_TRANS;

typedef struct _st_Online_TSess_Key {
    U32             uiCliIP;                /**< 단말 IP Address */
    U16             usCliPort;              /**< 단말 Port */
    U16             usReserved;             /**< 0x00으로 초기화 할 것 */
} ONLINE_TSESS_KEY;

<TAG_AUTO_DEFINE_START :ONLINE_STATE(700)>
STS_DATA_WAIT
STS_STATE_CHECK
STS_CHECK_HDR_SIZE
STS_SET_HDR
STS_CHECK_DATA_SIZE
STS_SET_DATA
<TAG_AUTO_DEFINE_END:ONLINE_STATE>

<TAG_AUTO_DEFINE_START :ONLINE_FLAG(0)>
ONLINE_NO
ONLINE_YES
<TAG_AUTO_DEFINE_END:ONLINE_FLAG>

<TAG_AUTO_DEFINE_START :ONLINE_CHECK_STATUS(1)>
ONLINE_HDR_WAIT
ONLINE_DATA_WAIT
<TAG_AUTO_DEFINE_END:ONLINE_STATUS>

<TAG_AUTO_DEFINE_START :ONLINE_TYPE(1)>
ONLINE_WICGS
ONLINE_MACS
<TAG_AUTO_DEFINE_END:ONLINE_TYPE>

<TAG_AUTO_DEFINE_START :ONLINE_UPDOWN(0)>
ONLINE_UP
ONLINE_DOWN
<TAG_AUTO_DEFINE_END:ONLINE_UPDOWN>

<TAG_AUTO_DEFINE_START :ONLINE_SVCTYPE(1)>
ONLINE_WICGS_BILL
ONLINE_WICGS_HDR
ONLINE_MACS_BILL
ONLINE_MACS_HDR
<TAG_AUTO_DEFINE_END:ONLINE_SVCTYPE>

#define MAX_ONLINE_HDR      108

TABLE_LOG typedef struct _st_Node_Info {
    S32         magic;
    S32         <TAG_DEFINE:ONLINE_UPDOWN>updown;
    S32         dataSize;
    S32         svcType;
    S32         <TAG_DEFINE:ONLINE_FLAG>isValidSize;
    S32         <TAG_DEFINE:ONLINE_FLAG>haveRcvSize;
    OFFSET      offset_DATA;
    OFFSET      offset_TCPINFO;
    OFFSET      offset_NODE;
    stMEMSINFO  *pMEMSINFO;
    S32         (*func1)(void *);
    S32         (*func2)(void *);
    S32         (*func3)(void *);
    S32         (*func4)(void *);
} NODE_INFO;

typedef struct _st_Online_Info {
    S32         <TAG_DEFINE:ONLINE_CHECK_STATUS>isState;
    S32         checkHdrSize;
    S32         checkDataSize;
    S32         oldDataSize;
    S32         remainHDRSize;
    STRING         szHDR[MAX_ONLINE_HDR];
} ONLINE_INFO;

typedef struct _st_Online_TSess {
    S32         <TAG_DEFINE:ONLINE_TYPE>type;
    DEF         <TAG_DEFINE:ONLINE_STATUS>ONLINE_STATE;
    DEF         <TAG_DEFINE:ONLINE_STATUS>ONLINE_OLD_STATE;
    ONLINE_INFO ONLINEINFO[2];
    OFFSET      offset_LOG;
    U32         uiUpNextSeq;
    U32         uiDnNextSeq;
    U8          ucSynRtx;
    U8          ucBroken;
} ONLINE_TSESS;

<TAG_FLOW_START:ONLINE(pTHIS-ONLINE_TSESS,pINPUT-NODE_INFO)>
%STS_DATA_WAIT  :OTHERMSG:(D)1:(Y)1:STS_STATE_CHECK%  #{
    FPRINTF(LOG_LEVEL, "=== %s :  DATA_WAIT" , (char *)__FUNCTION__);
    }#

%STS_STATE_CHECK    :CONTINUE:(D)pTHIS->ONLINEINFO[pINPUT->updown].isState:(Y)ONLINE_HDR_WAIT:STS_CHECK_HDR_SIZE%  ##
%STS_STATE_CHECK    :CONTINUE:(D)pTHIS->ONLINEINFO[pINPUT->updown].isState:(Y)ONLINE_DATA_WAIT:STS_CHECK_DATA_SIZE%  ##
%STS_STATE_CHECK    :CONTINUE:(D)pTHIS->ONLINEINFO[pINPUT->updown].isState:(N)0:STS_DATA_WAIT%  #{
    FPRINTF(LOG_LEVEL, "=== %s : STATE CHECK [%d] UPDOWN[%d]" ,
        (char *)__FUNCTION__, pTHIS->ONLINEINFO[pINPUT->updown].isState, pINPUT->updown);
    }#

%STS_CHECK_HDR_SIZE    :CONTINUE:(D)pINPUT->isValidSize:(Y)ONLINE_YES:STS_SET_HDR%  ##
%STS_CHECK_HDR_SIZE    :CONTINUE:(D)pINPUT->isValidSize:(Y)ONLINE_NO:STS_DATA_WAIT%  #{
    // 사이즈 비교 후 isValidSize 세팅
    ONLINE_INFO     *pONLINEINFO;
    TCP_INFO        *pTCPINFO;
    U8              *pDATA;
    S32             copySize;


    pTCPINFO = (TCP_INFO *)nifo_ptr(pINPUT->pMEMSINFO, pINPUT->offset_TCPINFO);
    pDATA = nifo_ptr(pINPUT->pMEMSINFO, pINPUT->offset_DATA);

    pONLINEINFO = &pTHIS->ONLINEINFO[pINPUT->updown];

    FPRINTF(LOG_LEVEL, "=== %s : CHECK HDR SIZE [%d] UPDOWN[%d]", (char *)__FUNCTION__, pONLINEINFO->isState, pINPUT->updown);

    if(pONLINEINFO->remainHDRSize + pINPUT->dataSize >= pONLINEINFO->checkHdrSize) {
        copySize = pONLINEINFO->checkHdrSize - pONLINEINFO->remainHDRSize;
        pINPUT->isValidSize = ONLINE_YES;
    } else {
        copySize = pINPUT->dataSize;
        pINPUT->isValidSize = ONLINE_NO;
    }

    FPRINTF(LOG_LEVEL, "=@= %s : CHECK HDR SIZE [%d] copySize[%d] dataSize[%d] isValidSize[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, copySize, pINPUT->dataSize, pINPUT->isValidSize);

    memcpy(&pONLINEINFO->szHDR[pONLINEINFO->remainHDRSize], pDATA, copySize);
    pONLINEINFO->remainHDRSize += copySize;
    pINPUT->dataSize = (pINPUT->dataSize - copySize);
    pINPUT->offset_DATA = (pINPUT->offset_DATA + copySize);

    FPRINTF(LOG_LEVEL, "==@ %s : CHECK HDR SIZE [%d] copySize[%d] dataSize[%d] isValidSize[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, copySize, pINPUT->dataSize, pINPUT->isValidSize);

    }#

%STS_SET_HDR   :CONTINUE:(D)pINPUT->haveRcvSize:(Y)ONLINE_YES:STS_STATE_CHECK%  ##
%STS_SET_HDR   :CONTINUE:(D)pINPUT->haveRcvSize:(Y)ONLINE_NO:STS_DATA_WAIT%  #{
    // 세팅
    ONLINE_INFO     *pONLINEINFO;
    TCP_INFO        *pTCPINFO;
    U8              *pDATA;
    S32             err = ONLINE_UERR_EMPTY;
    LOG_ONLINE_TRANS    *pLOGTRANS;
    st_Macs         *pMACS;
    st_MacsBillCom  *pMACSBILL;
    st_Wicgs        *pWICGS;
    st_WicgsBillCom *pWICGSBILL;


    pONLINEINFO = &pTHIS->ONLINEINFO[pINPUT->updown];
    pTCPINFO = (TCP_INFO *)nifo_ptr(pINPUT->pMEMSINFO, pINPUT->offset_TCPINFO);
    pDATA = nifo_ptr(pINPUT->pMEMSINFO, pINPUT->offset_DATA);
    pLOGTRANS = (LOG_ONLINE_TRANS *)nifo_ptr(pINPUT->pMEMSINFO, pTHIS->offset_LOG);

    FPRINTF(LOG_LEVEL, "=== %s : SET HDR [%d] SVCTYPE[%d] UPDOWN[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, pINPUT->svcType, pINPUT->updown);

    switch(pINPUT->svcType)
    {
    case ONLINE_WICGS_BILL:
        pWICGSBILL = (st_WicgsBillCom *)pONLINEINFO->szHDR;
        pLOGTRANS->uiTcpUpBodySize += pONLINEINFO->checkHdrSize;

        if(pLOGTRANS->uiAppDestIP == 0)
            pLOGTRANS->uiAppDestIP = ntohl(pWICGSBILL->uiDestIP);
        if(pLOGTRANS->usAppDestPort == 0)
            pLOGTRANS->usAppDestPort = ntohs(pWICGSBILL->usDestPort);
        if(pLOGTRANS->szApplicationID[0] == 0x00) {
            memcpy(pLOGTRANS->szApplicationID, pWICGSBILL->szAppID, MAX_APPLICATION_LEN);
            pLOGTRANS->szApplicationID[MAX_APPLICATION_LEN] = 0x00;
        }
        if(pLOGTRANS->szExtVersion[0] == 0x00) {
            memcpy(pLOGTRANS->szExtVersion, pWICGSBILL->szKTFPExtVer, MAX_EXTVERSION_LEN);
            pLOGTRANS->szExtVersion[MAX_EXTVERSION_LEN] = 0x00;
            memcpy(pLOGTRANS->szBrowserInfo, pWICGSBILL->szKTFPExtVer, MAX_EXTVERSION_LEN);
            pLOGTRANS->szBrowserInfo[MAX_EXTVERSION_LEN] = 0x00;
        }
        if(pLOGTRANS->szBestPN[0] == 0x00) {
            memcpy(pLOGTRANS->szBestPN, pWICGSBILL->szBestPN, MAX_BESTPN_LEN);
            pLOGTRANS->szBestPN[MAX_BESTPN_LEN] = 0x00;
        }
        if(pLOGTRANS->szMNC[0] == 0x00) {
            memcpy(pLOGTRANS->szMNC, pWICGSBILL->szMNC, MAX_MNC_LEN);
            pLOGTRANS->szMNC[MAX_MNC_LEN] = 0x00;
        }
        if(pLOGTRANS->uiFirstReqStartTime == 0) {
            pLOGTRANS->uiFirstReqStartTime = pTCPINFO->uiCapTime;
            pLOGTRANS->uiFirstReqStartMTime = pTCPINFO->uiCapMTime;
        }
#if 0
        if(pLOGTRANS->szBaseID[0] == 0x00) {
            memcpy(pLOGTRANS->szBaseID, pWICGSBILL->szBID, DEF_BID_LEN);
            pLOGTRANS->szBaseID[DEF_BID_LEN] = 0x00;
        }
        if(pLOGTRANS->szNID[0] == 0x00) {
            memcpy(pLOGTRANS->szNID, pWICGSBILL->szNID, DEF_NID_LEN);
            pLOGTRANS->szNID[DEF_NID_LEN] = 0x00;
        }
        if(pLOGTRANS->szSID[0] == 0x00) {
            memcpy(pLOGTRANS->szSID, pWICGSBILL->szSID, DEF_SID_LEN);
            pLOGTRANS->szSID[DEF_SID_LEN] = 0x00;
        }
#endif
        if(pLOGTRANS->szMIN[0] == 0x00) {
            memcpy(pLOGTRANS->szMIN, pWICGSBILL->szMIN, MAX_MIN_LEN);
            pLOGTRANS->szMIN[MAX_MIN_LEN] = 0x00;
        }

        if(pLOGTRANS->szModel[0] == 0x00) {
            memcpy(pLOGTRANS->szModel, pWICGSBILL->szHandSet, DEF_HANDSET_LEN);
            pLOGTRANS->szModel[DEF_HANDSET_LEN] = 0x00;
        }

        pLOGTRANS->usBillcomHeaderCnt++;

        if((err = pINPUT->func1((void *)pWICGSBILL)) != ONLINE_UERR_EMPTY)
        {
            pLOGTRANS->usUserErrorCode = (pLOGTRANS->usUserErrorCode == ONLINE_UERR_EMPTY) ? err : pLOGTRANS->usUserErrorCode;
            pINPUT->magic = -1;
            pINPUT->haveRcvSize = ONLINE_NO;
        }
        else
        {
            pINPUT->magic = 0;

            pONLINEINFO->isState = ONLINE_DATA_WAIT;

            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] WICGS BILL packetLen[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, ntohl(pWICGSBILL->dPacketLen));
            pONLINEINFO->checkDataSize = ntohl(pWICGSBILL->dPacketLen) - st_WicgsBillCom_SIZE;
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] WICGS BILL checkDataSize[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, pONLINEINFO->checkDataSize);
            pONLINEINFO->remainHDRSize = 0;
            pONLINEINFO->oldDataSize = 0;
            if(pINPUT->dataSize > 0) {
                pINPUT->haveRcvSize = ONLINE_YES;
            } else {
                pINPUT->haveRcvSize = ONLINE_NO;
            }
        }

        break;

    case ONLINE_WICGS_HDR:
        pWICGS = (st_Wicgs *)pONLINEINFO->szHDR;
        pLOGTRANS->uiTcpDnBodySize += pONLINEINFO->checkHdrSize;

        if(pLOGTRANS->uiFirstResStartTime == 0) {
            pLOGTRANS->uiFirstResStartTime = pTCPINFO->uiCapTime;
            pLOGTRANS->uiFirstResStartMTime = pTCPINFO->uiCapMTime;
        }

        pLOGTRANS->usServerHeaderCnt++;

        if((err = pINPUT->func2((void *)pWICGS)) != ONLINE_UERR_EMPTY)
        {
            pLOGTRANS->usUserErrorCode = (pLOGTRANS->usUserErrorCode == ONLINE_UERR_EMPTY) ? err : pLOGTRANS->usUserErrorCode;
            pINPUT->magic = -1;
            pINPUT->haveRcvSize = ONLINE_NO;
        }
        else
        {
            pINPUT->magic = 0;

            pONLINEINFO->isState = ONLINE_DATA_WAIT;
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] WICGS packetLen[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, ntohl(pWICGS->uiLen));
            pONLINEINFO->checkDataSize = ntohl(pWICGS->uiLen);
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] WICGS checkDataSize[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, pONLINEINFO->checkDataSize);
            pONLINEINFO->remainHDRSize = 0;
            pONLINEINFO->oldDataSize = 0;
            if(pINPUT->dataSize > 0) {
                pINPUT->haveRcvSize = ONLINE_YES;
            } else {
                pINPUT->haveRcvSize = ONLINE_NO;
            }

        }
        break;

    case ONLINE_MACS_BILL:
        pMACSBILL = (st_MacsBillCom *)pONLINEINFO->szHDR;
        pLOGTRANS->uiTcpUpBodySize += pONLINEINFO->checkHdrSize;

        if(pLOGTRANS->uiAppDestIP == 0)
            pLOGTRANS->uiAppDestIP = ntohl(pMACSBILL->uiDestIP);
        if(pLOGTRANS->usAppDestPort == 0)
            pLOGTRANS->usAppDestPort = ntohs(pMACSBILL->usDestPort);
        if(pLOGTRANS->szApplicationID[0] == 0x00) {
//          sprintf(pLOGTRANS->szApplicationID, "%u", ntohl(pMACSBILL->dClassID));
            sprintf(pLOGTRANS->szApplicationID, "%08X", ntohl(pMACSBILL->dClassID));
        }
        if(pLOGTRANS->szExtVersion[0] == 0x00) {
            memcpy(pLOGTRANS->szExtVersion, pMACSBILL->szBREWExtVer, MAX_EXTVERSION_LEN);
            pLOGTRANS->szExtVersion[MAX_EXTVERSION_LEN] = 0x00;
        }
        if(pLOGTRANS->szBSCID[0] == 0x00) {
            memcpy(pLOGTRANS->szBSCID, pMACSBILL->szBSCID, MAX_BSCID_LEN);
            pLOGTRANS->szBSCID[MAX_BSCID_LEN] = 0x00;
        }
        if(pLOGTRANS->szBestPN[0] == 0x00) {
            memcpy(pLOGTRANS->szBestPN, pMACSBILL->szBestPN, MAX_BESTPN_LEN-1);
            pLOGTRANS->szBestPN[MAX_BESTPN_LEN-1] = 0x00;
        }
        if(pLOGTRANS->uiFirstReqStartTime == 0) {
            pLOGTRANS->uiFirstReqStartTime = pTCPINFO->uiCapTime;
            pLOGTRANS->uiFirstReqStartMTime = pTCPINFO->uiCapMTime;
        }
#if 0
        if(pLOGTRANS->szBaseID[0] == 0x00) {
            memcpy(pLOGTRANS->szBaseID, pMACSBILL->szBID, DEF_BID_LEN);
            pLOGTRANS->szBaseID[DEF_BID_LEN] = 0x00;
        }
        if(pLOGTRANS->szNID[0] == 0x00) {
            memcpy(pLOGTRANS->szNID, pMACSBILL->szNID, DEF_NID_LEN);
            pLOGTRANS->szNID[DEF_NID_LEN] = 0x00;
        }
        if(pLOGTRANS->szSID[0] == 0x00) {
            memcpy(pLOGTRANS->szSID, pMACSBILL->szSID, DEF_SID_LEN);
            pLOGTRANS->szSID[DEF_SID_LEN] = 0x00;
        }
#endif
        if(pLOGTRANS->szMIN[0] == 0x00) {
            memcpy(pLOGTRANS->szMIN, pMACSBILL->szMIN, MAX_MIN_LEN);
            pLOGTRANS->szMIN[MAX_MIN_LEN] = 0x00;
        }

        pLOGTRANS->usBillcomHeaderCnt++;

        if((err = pINPUT->func3((void *)pMACSBILL)) != ONLINE_UERR_EMPTY)
        {
            pLOGTRANS->usUserErrorCode = (pLOGTRANS->usUserErrorCode == ONLINE_UERR_EMPTY) ? err : pLOGTRANS->usUserErrorCode;
            pINPUT->magic = -1;
            pINPUT->haveRcvSize = ONLINE_NO;
        }
        else
        {
            pINPUT->magic = 0;

            pONLINEINFO->isState = ONLINE_DATA_WAIT;
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] MACS BILL packetLen[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, ntohl(pMACSBILL->dPacketLen));
            pONLINEINFO->checkDataSize = ntohl(pMACSBILL->dPacketLen) - st_MacsBillCom_SIZE;
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] MACS BILL checkDataSize[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, pONLINEINFO->checkDataSize);
            pONLINEINFO->remainHDRSize = 0;
            pONLINEINFO->oldDataSize = 0;
            if(pINPUT->dataSize > 0) {
                pINPUT->haveRcvSize = ONLINE_YES;
            } else {
                pINPUT->haveRcvSize = ONLINE_NO;
            }

        }

        break;

    case ONLINE_MACS_HDR:
        pMACS = (st_Macs *)pONLINEINFO->szHDR;
        pLOGTRANS->uiTcpDnBodySize += pONLINEINFO->checkHdrSize;

        if(pLOGTRANS->uiFirstResStartTime == 0) {
            pLOGTRANS->uiFirstResStartTime = pTCPINFO->uiCapTime;
            pLOGTRANS->uiFirstResStartMTime = pTCPINFO->uiCapMTime;
        }

        pLOGTRANS->usServerHeaderCnt++;

        if((err = pINPUT->func4((void *)pMACS)) != ONLINE_UERR_EMPTY)
        {
            pLOGTRANS->usUserErrorCode = (pLOGTRANS->usUserErrorCode == ONLINE_UERR_EMPTY) ? err : pLOGTRANS->usUserErrorCode;
            pINPUT->magic = -1;
            pINPUT->haveRcvSize = ONLINE_NO;
        }
        else
        {
            pINPUT->magic = 0;

            pONLINEINFO->isState = ONLINE_DATA_WAIT;
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] MACS packetLen[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, ntohl(pMACS->uiLen));
            pONLINEINFO->checkDataSize = ntohl(pMACS->uiLen);
            FPRINTF(LOG_LEVEL, "=@= %s : SET HDR [%d] MACS checkDataSize[%d]",
                (char *)__FUNCTION__, pONLINEINFO->isState, pONLINEINFO->checkDataSize);
            pONLINEINFO->remainHDRSize = 0;
            pONLINEINFO->oldDataSize = 0;
            if(pINPUT->dataSize > 0) {
                pINPUT->haveRcvSize = ONLINE_YES;
            } else {
                pINPUT->haveRcvSize = ONLINE_NO;
            }

        }

        break;

    default:
        break;
    }

    FPRINTF(LOG_LEVEL, "==@ %s : SET HDR [%d] checkDataSize[%d] remainHDRSize[%d] oldDataSize[%d] havaRcvSize[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, pONLINEINFO->checkDataSize,
        pONLINEINFO->remainHDRSize, pONLINEINFO->oldDataSize, pINPUT->haveRcvSize);

    }#

%STS_CHECK_DATA_SIZE    :CONTINUE:(D)pINPUT->isValidSize:(Y)ONLINE_YES:STS_SET_DATA%  ##
%STS_CHECK_DATA_SIZE    :CONTINUE:(D)pINPUT->isValidSize:(Y)ONLINE_NO:STS_DATA_WAIT%  #{
        // 사이즈 비교 후 isValidSize 세팅
    ONLINE_INFO     *pONLINEINFO;
    TCP_INFO        *pTCPINFO;
    U8              *pDATA;
    S32             copySize;


    pTCPINFO = (TCP_INFO *)nifo_ptr(pINPUT->pMEMSINFO, pINPUT->offset_TCPINFO);
    pDATA = nifo_ptr(pINPUT->pMEMSINFO, pINPUT->offset_DATA);
    pONLINEINFO = &pTHIS->ONLINEINFO[pINPUT->updown];

    FPRINTF(LOG_LEVEL, "=== %s : CHECK DATA SIZE [%d] UPDOWN[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, pINPUT->updown);

    FPRINTF(LOG_LEVEL, "=@= %s : CHECK DATA SIZE [%d] copySize[%d] dataSize[%d] isValidSize[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, copySize, pINPUT->dataSize, pINPUT->isValidSize);

    if(pONLINEINFO->oldDataSize + pINPUT->dataSize >= pONLINEINFO->checkDataSize) {
        copySize = pONLINEINFO->checkDataSize - pONLINEINFO->oldDataSize;
        pINPUT->isValidSize = ONLINE_YES;
    } else {
        copySize = pINPUT->dataSize;
        pINPUT->isValidSize = ONLINE_NO;
    }

    pONLINEINFO->oldDataSize += copySize;
    pINPUT->dataSize = (pINPUT->dataSize - copySize);
    pINPUT->offset_DATA = (pINPUT->offset_DATA + copySize);

    FPRINTF(LOG_LEVEL, "==@ %s : CHECK DATA SIZE [%d] copySize[%d] dataSize[%d] isValidSize[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, copySize, pINPUT->dataSize, pINPUT->isValidSize);

    }#

%STS_SET_DATA   :CONTINUE:(D)pINPUT->haveRcvSize:(Y)ONLINE_YES:STS_STATE_CHECK%  ##
%STS_SET_DATA   :CONTINUE:(D)pINPUT->haveRcvSize:(Y)ONLINE_NO:STS_DATA_WAIT%  #{
        // 세팅
    ONLINE_INFO     *pONLINEINFO;
    LOG_ONLINE_TRANS    *pLOGTRANS;

    pLOGTRANS = (LOG_ONLINE_TRANS *)nifo_ptr(pINPUT->pMEMSINFO, pTHIS->offset_LOG);
    pONLINEINFO = &pTHIS->ONLINEINFO[pINPUT->updown];

    FPRINTF(LOG_LEVEL, "=== %s : SET DATA [%d] UPDOWN[%d]", (char *)__FUNCTION__, pONLINEINFO->isState, pINPUT->updown);

    switch(pINPUT->svcType)
    {
    case ONLINE_WICGS_BILL:
        pLOGTRANS->uiL7UpBodySize += pONLINEINFO->checkDataSize;
        pLOGTRANS->uiTcpUpBodySize += pONLINEINFO->checkDataSize;

        pONLINEINFO->isState = ONLINE_HDR_WAIT;
        pONLINEINFO->checkDataSize = 0;
        pONLINEINFO->oldDataSize = 0;
        if(pINPUT->dataSize > 0) {
            pINPUT->haveRcvSize = ONLINE_YES;
        } else {
            pINPUT->haveRcvSize = ONLINE_NO;
        }

        break;

    case ONLINE_WICGS_HDR:
        pLOGTRANS->uiL7DnBodySize += pONLINEINFO->checkDataSize;
        pLOGTRANS->uiTcpDnBodySize += pONLINEINFO->checkDataSize;

        pONLINEINFO->isState = ONLINE_HDR_WAIT;
        pONLINEINFO->checkDataSize = 0;
        pONLINEINFO->oldDataSize = 0;
        if(pINPUT->dataSize > 0) {
            pINPUT->haveRcvSize = ONLINE_YES;
        } else {
            pINPUT->haveRcvSize = ONLINE_NO;
        }
        break;

    case ONLINE_MACS_BILL:
        pLOGTRANS->uiL7UpBodySize += pONLINEINFO->checkDataSize;
        pLOGTRANS->uiTcpUpBodySize += pONLINEINFO->checkDataSize;

        pONLINEINFO->isState = ONLINE_HDR_WAIT;
        pONLINEINFO->checkDataSize = 0;
        pONLINEINFO->oldDataSize = 0;
        if(pINPUT->dataSize > 0) {
            pINPUT->haveRcvSize = ONLINE_YES;
        } else {
            pINPUT->haveRcvSize = ONLINE_NO;
        }

        break;

    case ONLINE_MACS_HDR:
        pLOGTRANS->uiL7DnBodySize += pONLINEINFO->checkDataSize;
        pLOGTRANS->uiTcpDnBodySize += pONLINEINFO->checkDataSize;

        pONLINEINFO->isState = ONLINE_HDR_WAIT;
        pONLINEINFO->checkDataSize = 0;
        pONLINEINFO->oldDataSize = 0;
        if(pINPUT->dataSize > 0) {
            pINPUT->haveRcvSize = ONLINE_YES;
        } else {
            pINPUT->haveRcvSize = ONLINE_NO;
        }

        break;

    default:
        break;
    }

    FPRINTF(LOG_LEVEL, "==@ %s : SET DATA [%d] checkDataSize[%d] remainHDRSize[%d] oldDataSize[%d] havaRcvSize[%d]",
        (char *)__FUNCTION__, pONLINEINFO->isState, pONLINEINFO->checkDataSize,
        pONLINEINFO->remainHDRSize, pONLINEINFO->oldDataSize, pINPUT->haveRcvSize);

    }#

<TAG_FLOW_END:ONLINE>

/*********************************/

/**
 * @brief JNC_LOG : JAVA Network Contents 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_JNC_Log {

	<STG_COMMON:LOG_COMMON>

	U16		usClientPort;			/**< 단말 Port */
	IP4		uiServerIP;				/**< Server IP */
	U16		usServerPort;			/**< Server Port */
	STIME	uiTcpSynTime;			/**< Tcp Syn Time */
	MTIME	uiTcpSynMTime;			/**< Tcp Syn Micro Time */
	U16		usTransID;				/**< HTTP Transaction ID */
	DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;			/**< usSvcL4Type / 1000 * 1000 */
	DEF		<TAG_DEFINE:L4CODE>usSvcL4Type;			/**< IP, PORT로 판단한 Service type */
	DEF		<TAG_DEFINE:L7CODE>usSvcL7Type;			/**< URL, HostName으로 판단한 Service type */
	U8		ucSubSysNo;				/**< Sub System No. */
	DEF		<TAG_DEFINE:METHOD>ucMethod;		/**< Method Code 값 */			/* HTTP level */
	STIME	uiReqStartTime;			/**< GET/POST Request Start Time */
	MTIME	uiReqStartMTime;		/**< GET/POST Request Start Micro Time */
	STIME	uiReqEndTime;			/**< GET/POST Request End Time */
	MTIME	uiReqEndMTime;			/**< GET/POST Request End Micro Time */
	STIME	uiReqAckTime;			/**< Request에 대한 서버 측의 Ack Time */
	MTIME	uiReqAckMTime;			/**< Request에 대한 서버 측의 Ack Micro Time */
	STIME	uiResStartTime;			/**< Response Start Time */
	MTIME	uiResStartMTime;		/**< Response Start Micro Time */
	STIME	uiResEndTime;			/**< Response End Time */
	MTIME	uiResEndMTime;			/**< Response End Micro Time */
	STIME	uiMNAckTime;			/**< 단말 Ack Time */
	MTIME	uiMNAckMTime;			/**< 단말 Ack Micro Time */
	STIME	uiLastPktTime;			/**< Last Packet Time */
	MTIME	uiLastPktMTime;			/**< Last Packet Micro Time */
	S64		llTransGapTime;			/**< LastPktTime - ReqStartTime */
	U32		usResCode;				/**< HTTP Response Code */
	DEF		<TAG_DEFINE:CLI>ucTcpClientStatus;			/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>ucTcpServerStatus;			/**< 서버 상태 */
	DEF		<TAG_DEFINE:LOG_HTTP_STATUS>ucStatus;	/**< HTTP 서비스 상태 */
	U32		usUserErrorCode;		/**< NTAS Error Code */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;	/**< TCP Fail Code */
	U16		usL7FailCode;			/**< HTTP Fail Code */
	U32		uiIPDataUpPktCnt;		/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPDataDnPktCnt;		/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 */
	U32		uiIPDataUpRetransCnt;	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPDataDnRetransCnt;	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		uiIPDataUpPktSize;		/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPDataDnPktSize;		/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		uiIPDataUpRetransSize;	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPDataDnRetransSize;	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		uiTcpUpBodySize;		/**< MN => Server, TCP Payload Size */
	U32		uiTcpDnBodySize;		/**< Server => MN, TCP Payload Size */

	STRING	szContentCode[MAX_CONTENTCODE_SIZE];
	STRING	szCpCode[MAX_CPCODE_SIZE];

	STIME	uiOpStartTime;			/** 분석 시작 Time */
	MTIME	uiOpStartMTime;			/** 분석 시작 Micro Time */
	STIME	uiOpEndTime;			/** 마지막 처리 Time */
	MTIME	uiOpEndMTime;			/** 마지막 처리 Micro Time */
} LOG_JNC_TRANS;				$PARSING_CASE_IGNORE$

/**
 * @brief IV_LOG : Internet Viewer 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_IV_Log {

	<STG_COMMON:LOG_COMMON>

	U16	usClientPort;			/**< Client jPort */
	IP4	uiServerIP;				/**< Server IP */
	U16	usServerPort;			/**< Server Port */
	STRING	szPcode[MAX_PCODE_SIZE];
	DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;         /**< usSvcL4Type / 1000 * 1000 */
	DEF	usSvcL4Type;
	DEF	usSvcL7Type;
	
	U32	uiPageID;
	STRING	szPageURL[MAX_URL_SIZE];
	U16	usPageFlag; 		/* 1 : Start Page, 2 : Middle Page, 3 : End Page */
	U32	uiPageFirstFailActionCode; /* see pciv_api.h,  same value CmdEnum_t.  0 : none, 1 : only response. */
	U32	uiPageActionCnt;
	U32	uiPageActionFailCnt;
	U32	uiPageDataUpPktSize;
	U32	uiPageDataDnPktSize;

	STIME	uiPageStartTime;
	MTIME	uiPageStartMTime;
	STIME	uiPageEndTime;
	MTIME	uiPageEndMTime;

	STIME	uiOpStartTime;			/** 분석 시작 Time */
	MTIME	uiOpStartMTime;			/** 분석 시작 Micro Time */
	STIME	uiOpEndTime;			/** 마지막 처리 Time */
	MTIME	uiOpEndMTime;			/** 마지막 처리 Micro Time */

	STIME	uiClickTime;
	MTIME	uiClickMTime;

	STIME	uiNavigateTime;
	MTIME	uiNavigateMTime;

	STIME	uiIsCompletedTime;
	MTIME	uiIsCompletedMTime;

	STIME	uiGetAllheadersTime;
	MTIME	uiGetAllheadersMTime;

	STIME	uiGetChunkReqStartTime;
	MTIME	uiGetChunkReqStartMTime;

	STIME	uiGetChunkReqEndTime;
	MTIME	uiGetChunkReqEndMTime;

	STIME	uiGetChunkRespStartTime;
	MTIME	uiGetChunkRespStartMTime;

	STIME	uiGetChunkRespEndTime;
	MTIME	uiGetChunkRespEndMTime;

	STIME	uiLastAPITime;
	MTIME	uiLastAPIMTime;

	S64		llTransDurationTime;
	U8      ucSubSysNo;             /**< Sub System No. */

} LOG_IV;				$PARSING_CASE_IGNORE$

/**
 * @brief VOD_LOG : VOD 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_VOD_Log {

	<STG_COMMON:LOG_COMMON>

	U16		usClientPort;			/**< 단말 Port */
	IP4		uiServerIP;				/**< Server IP */
	U16		usServerPort;			/**< Server Port */
	STIME	uiTcpSynTime;			/**< Tcp Syn Time */
	MTIME	uiTcpSynMTime;			/**< Tcp Syn Micro Time */

	DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;			/**< usSvcL4Type / 1000 * 1000 */
	DEF		<TAG_DEFINE:L4CODE>usSvcL4Type;			/**< IP, PORT로 판단한 Service type */
	DEF		<TAG_DEFINE:L7CODE>usSvcL7Type;			/**< URL, HostName으로 판단한 Service type */
	U8		ucSubSysNo;				/**< Sub System No. */
	DEF		<TAG_DEFINE:METHOD>ucLastMethod;		/**< Method Code 값 */			/* HTTP level */
	STIME	uiSetupStartTime;			/**< GET/POST Request Start Time */
	MTIME	uiSetupStartMTime;		/**< GET/POST Request Start Micro Time */
	STIME	uiSetupEndTime;			/**< Request에 대한 서버 측의 Ack Time */
	MTIME	uiSetupEndMTime;			/**< Request에 대한 서버 측의 Ack Micro Time */
	STIME	uiTeardownTime;			/**< GET/POST Request End Time */
	MTIME	uiTeardownMTime;			/**< GET/POST Request End Micro Time */
	STIME	uiLastPktTime;			/**< Last Packet Time */
	MTIME	uiLastPktMTime;			/**< Last Packet Micro Time */
	S64		llSessGapTime;			/**< LastPktTime - ReqStartTime */

	DEF		<TAG_DEFINE:CLI>ucTcpClientStatus;			/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>ucTcpServerStatus;			/**< 서버 상태 */
	DEF		<TAG_DEFINE:LOG_HTTP_STATUS>ucStatus;	/**< HTTP 서비스 상태 */
	U32		usUserErrorCode;		/**< NTAS Error Code */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;	/**< TCP Fail Code */
	U16		usL7FailCode;			/**< HTTP Fail Code */

	U32		uiIPDataUpPktCnt;		/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPDataDnPktCnt;		/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 */
	U32		uiIPDataUpRetransCnt;	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPDataDnRetransCnt;	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		uiIPDataUpPktSize;		/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPDataDnPktSize;		/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		uiIPDataUpRetransSize;	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPDataDnRetransSize;	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		uiTcpUpBodySize;		/**< MN => Server, TCP Payload Size */
	U32		uiTcpDnBodySize;		/**< Server => MN, TCP Payload Size */

	U32		uiTrafficSize;
	U32		uiAudioDataSize;
	U32		uiVideoDataSize;

	U32 	AudioCnt;
	U32 	VideoCnt;
	U32 	AudioLossCnt;
	U32 	VideoLossCnt;

	U16		usRtspUpCnt;
	U16		usRtspDnCnt;

	U32 	usRtpUpCnt;
	U32 	usRtpDnCnt;
	U32 	usRtpUpLossCnt;
	U32 	usRtpDnLossCnt;
	U32 	uiRtpUpDataSize;
	U32 	uiRtpDnDataSize;

	U32		uiMaxJitter;
	U16		usMaxJitterTrackID;

	U16		usRTI;
	U16		usMediaCnt;
	U32		uiTimeRange;
	U32		uiTimeMRange;

	U16		usLOGURLSize;			/**< LOG URL Size */			/* HTTP level */
	STRING	szLOGURL[MAX_LOGURL_SIZE];	@CHECKING_VALUE:http@ 	/**< LOG URL */	

	STRING	szMsMan[MAX_MSMAN_SIZE];
	STRING	szVodSessID[MAX_VODSESSID_SIZE];

	STIME	uiOpStartTime;			/** 분석 시작 Time */
	MTIME	uiOpStartMTime;			/** 분석 시작 Micro Time */
	STIME	uiOpEndTime;			/** 마지막 처리 Time */
	MTIME	uiOpEndMTime;			/** 마지막 처리 Micro Time */
} LOG_VOD_SESS;				$PARSING_CASE_IGNORE$

/* LOG_SIP_TRANS를 위한 define 값 */
#define SIP_CALLID_SIZE         65
#define SIP_CALLID_LEN          (SIP_CALLID_SIZE - 1)
#define SIP_FROM_SIZE           65
#define SIP_FROM_LEN            (SIP_FROM_SIZE - 1)
#define SIP_TO_SIZE             65
#define SIP_TO_LEN              (SIP_TO_SIZE - 1)
#define SIP_URI_SIZE            257
#define SIP_URI_LEN             (SIP_URI_SIZE - 1)
#define SIP_TAG_SIZE            33
#define SIP_TAG_LEN             (SIP_TAG_SIZE - 1)
#define SIP_USERAGENT_SIZE      65
#define SIP_USERAGENT_LEN       (SIP_USERAGENT_SIZE - 1)
#define SIP_USERNAME_SIZE       33
#define SIP_USERNAME_LEN        (SIP_USERNAME_SIZE - 1)
#define SIP_NONCE_SIZE          33
#define SIP_NONCE_LEN           (SIP_NONCE_SIZE - 1)
#define SIP_PROTO_SIZE          33
#define SIP_PROTO_LEN           (SIP_PROTO_SIZE - 1)
#define SIP_METHOD_SIZE         17
#define SIP_METHOD_LEN          (SIP_METHOD_SIZE - 1)
#define SIP_CONTACT_SIZE		257
#define SIP_CONTACT_LEN			(SIP_CONTACT_SIZE - 1)

<TAG_DEFINE_START:SIP_ENDSTATUS>
#define SIP_ENDSTATUS_REQ       1
#define SIP_ENDSTATUS_1xx       2
#define SIP_ENDSTATUS_RES       3
#define SIP_ENDSTATUS_ACK       4
<TAG_DEFINE_END:SIP_ENDSTATUS>

<TAG_DEFINE_START:SIP_ERROR>
#define SIP_UERR_EMPTY  0
#define SIP_UERR_8000   8000			/* 서버로부터 오류를 나타내는 응답 코드가 온 경우 (응답 코드 400 이상) */ 
#define SIP_UERR_8100   8100			/* INVITE 이후에 RESPONSE 없이 ACK를 받은 경우 */ 
#define SIP_UERR_8200   8200			/* TIMEOUT으로 정리된 경우 */
<TAG_DEFINE_END:SIP_ERROR>

#define SIP_MSG_ACK							100
#define SIP_MSG_BYE							110
#define SIP_MSG_CANCEL						120
#define SIP_MSG_INFO						130
#define SIP_MSG_INVITE_ADHOC				140
#define SIP_MSG_INVITE_MTOCSCF				141
#define SIP_MSG_INVITE_MTOIM				142
#define SIP_MSG_INVITE_TERMUE				143
#define SIP_MSG_INVITE						149
#define SIP_MSG_MESSAGE						150
#define SIP_MSG_NOTIFY_PRES					160
#define SIP_MSG_NOTIFY_CONF					161
#define SIP_MSG_NOTIFY						169
#define SIP_MSG_OPTIONS						170
#define SIP_MSG_PRACK						180
#define SIP_MSG_PUBLISH						190
#define SIP_MSG_REFER						200
#define SIP_MSG_REGISTER					210
#define SIP_MSG_SUBSCRIBE_PRES				220
#define SIP_MSG_SUBSCRIBE_CONF				221
#define SIP_MSG_SUBSCRIBE					229
#define SIP_MSG_UPDATE						230

#define IM_VENDOR_LGT		10
#define IM_VENDOR_KTF		20
#define IM_VENDOR_SKT		30

#define SIP_EVENT_PRES		10
#define SIP_EVENT_CONF		20

#define SIP_RANGE_ADHOC		10
#define SIP_RANGE_MTOCSCF	20
#define SIP_RANGE_MTOIM		30
#define SIP_RANGE_TERMUE	40 

#define SIP_CTYPE_CHAT      1
#define SIP_CTYPE_FILE     2

/**
 * @brief LOG_SIP_TRANS : SIP Transaciton DB Log
 *
 *
 * @see common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_Sip_Trans_Log {
	<STG_COMMON:LOG_COMMON>

	DEF			<TAG_DEFINE:PLATFORMTYPE>usPlatformType;        /**< usSvcL4Type / 1000 * 1000 */
	DEF			<TAG_DEFINE:L4CODE>usSvcL4Type;         		/**< IP, PORT로 판단한 Service type */
	DEF			<TAG_DEFINE:L7CODE>usSvcL7Type;         		/**< URL, HostName으로 판단한 Service type */
	U8			ucSubSysNo;										/**< Sub System No. */
	STIME       TransStartTime;									/**< Transaction 시작 시간 */ 
	MTIME       TransStartMTime;								/**< Transaction 시작 시간 (Micro) */ 
	STRING      CallID[SIP_CALLID_SIZE];  					  	/**< Call-ID */ 
	U16         method;             							/**< Request Method */
	STRING      MethodString[SIP_METHOD_SIZE]; 					/**< Request Method */ 
	U32         CSeq;											/**< CSeq: 1 INVITE 에서 숫자 */ 
	U16         Protocol;										/**< 사용 Protocol: TCP, UDP, SCTP 구분 */
	U16			Vendor;
	IP4         SrcIP;											/**< Source IP */ 
	IP4         DestIP;											/**< Destination IP */ 
	U16         SrcPort;										/**< Source Port */ 
	U16         DestPort;										/**< Destination Port */ 
	STIME       TransEndTime;									/**< Transaction 끝 시간 */ 
	MTIME       TransEndMTime;									/**< Transaction 끝 시간 (Micro) */ 
	STIME       FirstResTime;									/**< 첫번째 Response를 받은 시간 */
	MTIME       FirstResMTime;									/**< 첫번째 Response를 받은 시간 (Micro) */
	STIME       ResTime;										/**< Response를 받은 시간 */
	MTIME       ResMTime;										/**< Response를 받은 시간 (Micro) */
	STIME       AckTime;										/**< Ack Method를 보낸 시간 */
	MTIME       AckMTime;										/**< Ack Method를 보낸  시간 (Micro) */
	U32         ResCode;										/**< Response Code */ 
	U32     	LastUserErrCode;/**< user error */
	U16         <TAG_DEFINE:SIP_ERROR>L7FailCode;   /**< FailCode */

	U16         TotalReqCnt;    
	U16         TotalResCnt;    
	U16         SkipResCnt;     /**< 1xx 응답의 개수 */
	U16         RetransReqCnt;
	U16         RetransResCnt;

	U32         ReqDataSize;        /**< UDP, TCP Payload Size */
	U32         ResDataSize;        /**< UDP, TCP Payload Size */
	U32         ReqIPDataSize;      /**< IP Payload Size */ 
	U32         ResIPDataSize;      /**< IP Payload Size */ 

	U16         <TAG_DEFINE:SIP_ENDSTATUS>EndStatus;
	U32         FirstResGapTime;    /**< FirstResTime - TransStartTime */ 
	U32         ResGapTime;         /**< ResTime - TransStartTime */ 
	U32         AckGapTime;         /**< AckTime - ResTime */ 

	U32         SessID;             /**< SDP의 Owner/Creator에 있는 Session ID */
	U16         AudioPort;          /**< SDP의 Media Description에 있는 audio Port */
	U16         VideoPort;          /**< SDP의 Media Description에 있는 video Port */
	U16 		CType;				/**< Contents Type , Message or File Transfer */
	STRING      SIPFrom[SIP_FROM_SIZE]; /**< From 필드 값 */ 
	STRING      SIPTo[SIP_TO_SIZE]; /**< To 필드 값 */ 
	STRING      URI[SIP_URI_SIZE];  /**< Request URI */ 
	STRING      UserAgent[SIP_USERAGENT_SIZE];  /**< User-Agent */
	STRING      Auth_nonce[SIP_NONCE_SIZE]; /**< REGISTER에서 WWW-Authenticate, Authorization의 nonce값 */
	STRING      UserName[SIP_USERNAME_SIZE];    /**< SDP의 Owner/Creator에 있는 Username */
	STRING      AudioProto[SIP_PROTO_SIZE];     /**< SDP의 Media Description에 있는 audio Proto */
	STRING      VideoProto[SIP_PROTO_SIZE];     /**< SDP의 Media Description에 있는 video Proto */   

	STIME       OpStartTime;    /**< 분석 시작 Time */          
	MTIME       OpStartMTime;   /**< 분석 시작 Micro Time */    
	STIME       OpEndTime;      /**< 마지막 처리 Time */        
	MTIME       OpEndMTime;     /**< 마지막 처리 Micro Time */  

	U32			isUsed;		@CILOG_HIDDEN@
} LOG_SIP_TRANS; 

<TAG_DEFINE_START:VT_ERROR>
#define VT_UERR_EMPTY  		0
#define VT_UERR_NOSETUP 	6000			/* INVITE 가 OK로 끝나지 않은 경우 */ 
#define VT_UERR_NOPLAY 		6100			
#define VT_UERR_TIMEOUT		6200			/* BYE 없이 TIMEOUT으로 정리된 경우 */
<TAG_DEFINE_END:VT_ERROR>

/**
 * @brief LOG_VT_SESS : SIP Transaciton DB Log
 *
 *
 * @see common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_vt_Sess_Log {
	<STG_COMMON:LOG_COMMON>

	U16 		ClientPort;
	IP4 		ServerIP;
	U16 		ServerPort;

	DEF			<TAG_DEFINE:PLATFORMTYPE>usPlatformType;    /**< usSvcL4Type / 1000 * 1000 */
	DEF			<TAG_DEFINE:L4CODE>usSvcL4Type;         	/**< IP, PORT로 판단한 Service type */
	DEF			<TAG_DEFINE:L7CODE>usSvcL7Type;         	/**< URL, HostName으로 판단한 Service type */
	U8			ucSubSysNo;									/**< Sub System No. */

	U16         LastMethod;        							/**< Request Method */

	STIME       SessStartTime;								/**< Session 시작 시간 */ 
	MTIME       SessStartMTime;								/**< Session 시작 시간 (Micro) */ 
	STIME       SetupEndTime;								/**< Session 시작 시간 */ 
	MTIME       SetupEndMTime;								/**< Session 시작 시간 (Micro) */ 
	STIME		LastPktTime;								/**< Last Packet Time */
	MTIME		LastPktMTime;								/**< Last Packet Micro Time */
	S64			SessGapTime;								/**< LastPktTime - ReqStartTime */

	STRING      CallID[SIP_CALLID_SIZE];  					/**< Call-ID */ 
	STRING 		CallerMIN[MAX_MIN_SIZE];
	STRING 		CalledMIN[MAX_MIN_SIZE];

	U16         LastResCode;								/**< Response Code */ 
	U32     	<TAG_DEFINE:VT_ERROR>LastUserErrCode;		/**< user error */
	U16         L7FailCode;   		

	U16         TotalReqCnt;    
	U16         TotalResCnt;    
	U16         SkipResCnt;     							/**< 1xx 응답의 개수 */
	U16         RetransReqCnt;
	U16         RetransResCnt;

	/* TRAFFIC */
	U32 		uiIPDataUpPktCnt;							/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32 		uiIPDataDnPktCnt;							/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32 		uiIPTotUpPktCnt;							/**< MN => Server, 전구간에서 패킷 개수 */
	U32 		uiIPTotDnPktCnt;							/**< Server => MN, 전구간에서 패킷 개수 */
	U32 		uiIPDataUpRetransCnt;						/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32 		uiIPDataDnRetransCnt;						/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32 		uiIPTotUpRetransCnt;						/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32 		uiIPTotDnRetransCnt;						/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32 		uiIPDataUpPktSize;							/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32 		uiIPDataDnPktSize;							/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32 		uiIPTotUpPktSize;							/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32 		uiIPTotDnPktSize;							/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32 		uiIPDataUpRetransSize;						/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32 		uiIPDataDnRetransSize;						/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32 		uiIPTotUpRetransSize;						/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32 		uiIPTotDnRetransSize;						/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32 		uiTcpUpBodySize;							/**< MN => Server, TCP Payload Size */
	U32 		uiTcpDnBodySize;							/**< Server => MN, TCP Payload Size */

	/* RTP */
	U32 		AudioUpCnt;
	U32 		AudioDownCnt;
	U32 		AudioUpLossCnt;
	U32 		AudioDownLossCnt;

	U32 		VideoUpCnt;
	U32 		VideoDownCnt;
	U32 		VideoUpLossCnt;
	U32 		VideoDownLossCnt;

	U32 		AudioUpSize;
	U32 		AudioDownSize;
	U32 		VideoUpSize;
	U32 		VideoDownSize;

	U32			RTPUpCnt;									/**< UDP 총 패킷수 (단말 -> 서버) */
	U32			RTPDnCnt;									/**< UDP 총 패킷수 (서버 -> 단말) */
	U16			RTPUpLossCnt;
	U16			RTPDnLossCnt;
	U32			RTPUpDataSize;
	U32			RTPDnDataSize;

	U16         AudioPort;									/**< SDP의 Media Description에 있는 audio Port */
	U16         VideoPort;									/**< SDP의 Media Description에 있는 video Port */
	STRING      AudioProto[SIP_PROTO_SIZE];					/**< SDP의 Media Description에 있는 audio Proto */
	STRING      VideoProto[SIP_PROTO_SIZE];					/**< SDP의 Media Description에 있는 video Proto */   

	U32			UpMaxJitter;
	U32			DnMaxJitter;

	STIME       OpStartTime;								/**< 분석 시작 Time */          
	MTIME       OpStartMTime;								/**< 분석 시작 Micro Time */    
	STIME       OpEndTime;									/**< 마지막 처리 Time */        
	MTIME       OpEndMTime;									/**< 마지막 처리 Micro Time */  
} LOG_VT_SESS; 

<TAG_DEFINE_START:IM_ERROR>
#define IM_UERR_EMPTY  		0
#define IM_UERR_NOSETUP 	7000			/* INVITE 가 OK로 끝나지 않은 경우 */ 
#define IM_UERR_NOPLAY 		7100			
#define IM_UERR_TIMEOUT		7200			/* BYE 없이 TIMEOUT으로 정리된 경우 */
<TAG_DEFINE_END:IM_ERROR>


/**
 * @brief LOG_IM_SESS : IM Session LOG
 *
 *
 * @see common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_IM_Sess_Log {
	<STG_COMMON:LOG_COMMON>

	U16 		ClientPort;
	IP4 		ServerIP;
	U16 		ServerPort;

	DEF			<TAG_DEFINE:PLATFORMTYPE>usPlatformType;    /**< usSvcL4Type / 1000 * 1000 */
	DEF			<TAG_DEFINE:L4CODE>usSvcL4Type;         	/**< IP, PORT로 판단한 Service type */
	DEF			<TAG_DEFINE:L7CODE>usSvcL7Type;         	/**< URL, HostName으로 판단한 Service type */
	U8			ucSubSysNo;									/**< Sub System No. */

	U16         LastMethod;        							/**< Request Method */

	STIME       SessStartTime;								/**< Session 시작 시간 */ 
	MTIME       SessStartMTime;								/**< Session 시작 시간 (Micro) */ 
	STIME       SetupEndTime;								/**< Session 시작 시간 */ 
	MTIME       SetupEndMTime;								/**< Session 시작 시간 (Micro) */ 
	STIME		LastPktTime;								/**< Last Packet Time */
	MTIME		LastPktMTime;								/**< Last Packet Micro Time */
	S64			SessGapTime;								/**< LastPktTime - ReqStartTime */

	STRING      CallID[SIP_CALLID_SIZE];  					/**< Call-ID */ 
	STRING 		CallerMIN[MAX_MIN_SIZE];
	STRING 		CalledMIN[MAX_MIN_SIZE];

	U16         LastResCode;								/**< Response Code */ 
	U32     	<TAG_DEFINE:IM_ERROR>LastUserErrCode;		/**< user error */
	U16         L7FailCode;

	U16         TotalReqCnt;    
	U16         TotalResCnt;    
	U16         SkipResCnt;     							/**< 1xx 응답의 개수 */
	U16         RetransReqCnt;
	U16         RetransResCnt;

	/* TRAFFIC */
	U32         ReqBodySize;								/**< UDP, TCP Payload Size */
	U32         ResBodySize;								/**< UDP, TCP Payload Size */
	U32         ReqDataSize;								/**< UDP, TCP Payload Size */
	U32         ResDataSize;								/**< UDP, TCP Payload Size */
	U32         ReqIPDataSize;								/**< IP Payload Size */ 
	U32         ResIPDataSize;								/**< IP Payload Size */ 
	U32         RetransReqDataSize;							/**< Retrans UDP, TCP Payload Size */
	U32         RetransResDataSize;							/**< Retrans UDP, TCP Payload Size */

	/* MSRP */
	U16         UpMSRPPort;									/**< SDP의 Media Description에 있는 Message Port */
	U16         DnMSRPPort;									/**< SDP의 Media Description에 있는 Message Port */

	U16         MSRPTotalReqCnt;
	U16         MSRPTotalResCnt;
	U16         MSRPTotalReportCnt;
	U16         MSRPRetransReqCnt;
	U16         MSRPRetransResCnt;

	U32         MSRPReqDataSize;							/**< UDP, TCP Payload Size */
	U32         MSRPResDataSize;							/**< UDP, TCP Payload Size */

	U32         ReportBodySize;								/**< UDP, TCP Payload Size */
	U32         ReportDataSize;								/**< UDP, TCP Payload Size */
	U32         ReportIPDataSize;							/**< IP Payload Size */ 

	/* XCAP */
	U16         XCAPTotalReqCnt;
	U16         XCAPTotalResCnt;
	U16         XCAPRetransReqCnt;
	U16         XCAPRetransResCnt;

	STIME       OpStartTime;								/**< 분석 시작 Time */          
	MTIME       OpStartMTime;								/**< 분석 시작 Micro Time */    
	STIME       OpEndTime;									/**< 마지막 처리 Time */        
	MTIME       OpEndMTime;									/**< 마지막 처리 Micro Time */  
} LOG_IM_SESS; 

typedef struct _st_IM_session_hash_DATA {
	OFFSET 				offset;
	U64					timerNID; 							/**< TIMERNID */
	U32 				STATUS;
	LOG_IM_SESS			*pLOG_IM_SESS;
	STIME				LastPktTime;
	MTIME				LastPktMTime;
} IM_SESSION_HASH_DATA;

/* 2007.11.27 BY LDH FOR DUPLICATE PACKET */
typedef struct _st_DupNode_ {               
	U16      usNext;
	U16      usPrev;
	U16      usIdentification;
	U16      usFragmentOffset;
} st_DupNode;
    
/* 2007.11.27 BY LDH FOR DUPLICATE PACKET */
#define MAX_DUP_NODE        20
typedef struct _st_DupList_ {                                   
	U16      usFirstIndex;
	U16      usLastIndex;
	U16      usCurrentCount;
	U16      usReserved;

	st_DupNode  stNode[MAX_DUP_NODE];
} st_DupList;

typedef struct _st_vt_session_hash_DATA {
	OFFSET 				offset;
	U64					timerNID; 			/**< TIMERNID */
	LOG_VT_SESS			*pLOG_VT_SESS;

	struct timeval		tvAudioUpOldTime;
	struct timeval		tvAudioDnOldTime;
	struct timeval		tvVideoUpOldTime;
	struct timeval		tvVideoDnOldTime;

	U32					uiAudioUpOldSequence;
	U32					uiAudioDnOldSequence;
	U32					uiVideoUpOldSequence;
	U32					uiVideoDnOldSequence;

	U32					uiAudioUpOldTimestamp;
	U32					uiAudioDnOldTimestamp;
	U32					uiVideoUpOldTimestamp;
	U32					uiVideoDnOldTimestamp;

	U32					uiAudioUpJitter;
	U32					uiAudioDnJitter;
	U32					uiVideoUpJitter;
	U32					uiVideoDnJitter;

	U32					uiAudioUpLossCnt;
	U32					uiAudioDnLossCnt;
	U32					uiVideoUpLossCnt;
	U32					uiVideoDnLossCnt;

	st_DupList			stUpList;
	st_DupList			stDownList;
	STIME				LastPktTime;
	MTIME				LastPktMTime;
} VT_SESSION_HASH_DATA;

/**
 * @brief TEXT_INFO
 *
 *
 * @see common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
typedef struct _st_TEXT_INFO {
    OFFSET  offset;                 /**< PACKET_DATA로 부터의 TEXT DATA 시작 OFFSET 값 */
    U32     len;                    /**< DATA Length */
    STIME   uiStartTime;
    MTIME   uiStartMTime;
    STIME   uiLastUpdateTime;
    MTIME   uiLastUpdateMTime;
    STIME   uiAckTime;
    MTIME   uiAckMTime;
    IP4     clientIP;
    IP4     serverIP;
    U16     clientPort;
    U16     serverPort;
    U16     protocol;
    U16     failcode;
    U32     IPDataSize;
    U32     range;
    U32     network;
    U32     rawFileIndex;
    U32     rawPacketIndex;
    U32     rtx;
	U16     usL4Code;
} TEXT_INFO;

#define YES 1
#define NO  0

<TAG_AUTO_DEFINE_START :TSIP(700)>
TSIP_MSG_WAIT
TSIP_RCV_REQ_NORMAL
TSIP_RCV_RES_NORMAL
TSIP_RCV_RES_NORMAL_SKIP
TSIP_RCV_REQ_INVITE
TSIP_RCV_RES_INVITE
TSIP_RCV_REQ_ACK
TSIP_RCV_RES_INVITE_SKIP
<TAG_AUTO_DEFINE_END:TSIP>


<TAG_AUTO_DEFINE_START :TSIP_STATUS(1)>
TSIP_RES_SKIP
TSIP_RES_NORMAL
TSIP_REQ_NORMAL
TSIP_REQ_INVITE
TSIP_REQ_ACK
<TAG_AUTO_DEFINE_END:TSIP_STATUS>

typedef struct _st_SIP_INFO {
    DEF         <TAG_DEFINE:TSIP>TSIP_STATE;            /**< TAG_FLOW의 기본 현재 STATE */
    DEF         <TAG_DEFINE:TSIP>TSIP_OLD_STATE;        /**< TAG_FLOW의 기본 OLD_STATE */
    U64         timerNID;                       /**< TIMER ID */
    OFFSET      offset_LOG;                     /**< NODE에서 LOG의 offset 값 */
    OFFSET      offset_NODE;                    /**< HEADER NODE의 offset 값 */
    S32         finish_trans;                   /**< transaction finish 여부 판단 */
    S32         start_trans;                    /**< transaction start 여부 판단 */
    U16         failcode;                       /**< Fail Code */
    U16         endstatus;                      /**< END STATUS */
} SIP_INFO;

typedef struct _st_TSIP_INFO {
    U32         <TAG_DEFINE:TSIP_STATUS>status;             /**< 현재 MSG의 STATE 값 */
    S32         delete_node;                                /**< NODE 삭제 여부 판단 */
    U32         msgtype;
    void        *pTEXTINFO;                                 /**< TEXT_INFO */
    void        *pMEMSINFO;                                 /**< nifo 정보 */
    OFFSET      offset_DATA;                                /**< 현재 MSG NODE */
    void        (*AddMsg)(void *, void *);                  /**< args(SIP_INFO, TSIP_INFO) */
    void        (*InitLog)(void *, void *);                 /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetResSkip)(void *, void *);              /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetResNormal)(void *, void *);            /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetRetransReq)(void *, void *);           /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetRetransRes)(void *, void *);           /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetAck)(void *, void *);                  /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetRetransAck)(void *, void *);           /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetReqDataSize)(void *, void *);          /**< args(SIP_INFO, TSIP_INFO) */
    void        (*SetResDataSize)(void *, void *);          /**< args(SIP_INFO, TSIP_INFO) */
} TSIP_INFO;

<TAG_FLOW_START:TSIP(pTHIS-SIP_INFO,pINPUT-TSIP_INFO)>
%TSIP_MSG_WAIT:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_MSG_WAIT%  ##
%TSIP_MSG_WAIT:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_MSG_WAIT%  ##
%TSIP_MSG_WAIT:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_NORMAL:TSIP_RCV_REQ_NORMAL% ##
%TSIP_MSG_WAIT:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_INVITE:TSIP_RCV_REQ_INVITE% ##
%TSIP_MSG_WAIT:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_ACK:TSIP_MSG_WAIT%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_MSG_WAIT:
			switch (pINPUT->status)
			{
				case TSIP_RES_SKIP:
					FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_MSG_WAIT [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);
					break;
				case TSIP_RES_NORMAL:
					FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_MSG_WAIT [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);
					break;
				case TSIP_REQ_ACK:
					FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_MSG_WAIT [EDGE] TSIP_REQ_ACK", __FILE__, __LINE__);
					break;
			}
			
			/* NODE 삭제 */
			pINPUT->delete_node = YES;

			break;
		case TSIP_RCV_REQ_INVITE:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_INVITE [EDGE] TSIP_REQ_ACK", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pTHIS->finish_trans = YES;
			pTHIS->failcode = SIP_UERR_8100;
			pINPUT->SetAck(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_RES_INVITE_SKIP:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE_SKIP [EDGE] TSIP_REQ_ACK", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pTHIS->finish_trans = YES;
			pTHIS->failcode = SIP_UERR_8100;
			pINPUT->SetAck(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

	FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_MSG_WAIT", __FILE__, __LINE__);
	}#

%TSIP_RCV_REQ_NORMAL:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_RES_NORMAL_SKIP%  ##
%TSIP_RCV_REQ_NORMAL:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_RES_NORMAL%  ##
%TSIP_RCV_REQ_NORMAL:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_NORMAL:TSIP_RCV_REQ_NORMAL%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_MSG_WAIT:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_MSG_WAIT [EDGE] TSIP_REQ_NORMAL", __FILE__, __LINE__);
			
			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pTHIS->start_trans = YES;
			pINPUT->InitLog(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_REQ_NORMAL:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_NORMAL [EDGE] TSIP_REQ_NORMAL", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransReq(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			break;
		case TSIP_RCV_RES_NORMAL:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_NORMAL [EDGE] TSIP_REQ_NORMAL", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransReq(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			break;
		case TSIP_RCV_RES_NORMAL_SKIP:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_NORMAL_SKIP [EDGE] TSIP_REQ_NORMAL", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransReq(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

	FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_REQ_NORMAL", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_REQ;
	}#

%TSIP_RCV_RES_NORMAL:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_RES_NORMAL_SKIP%  ##
%TSIP_RCV_RES_NORMAL:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_RES_NORMAL%  ##
%TSIP_RCV_RES_NORMAL:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_NORMAL:TSIP_RCV_REQ_NORMAL%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_RCV_REQ_NORMAL:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_NORMAL [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pINPUT->SetResNormal(pTHIS, pINPUT);
			pTHIS->finish_trans = YES;
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_RES_NORMAL_SKIP:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_NORMAL_SKIP [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pINPUT->SetResNormal(pTHIS, pINPUT);
			pTHIS->finish_trans = YES;
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_RES_NORMAL:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_NORMAL [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransRes(pTHIS, pINPUT);
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

    FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_RES_NORMAL", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_RES;
	}#

%TSIP_RCV_RES_NORMAL_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_RES_NORMAL_SKIP%  ##
%TSIP_RCV_RES_NORMAL_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_RES_NORMAL%  ##
%TSIP_RCV_RES_NORMAL_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_NORMAL:TSIP_RCV_REQ_NORMAL%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_RCV_REQ_NORMAL:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_NORMAL [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetResSkip(pTHIS, pINPUT);
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			break;
		case TSIP_RCV_RES_NORMAL:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_NORMAL [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			break;
		case TSIP_RCV_RES_NORMAL_SKIP:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_NORMAL_SKIP [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

    FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_RES_NORMAL_SKIP", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_1xx;
	}#

%TSIP_RCV_REQ_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_RES_INVITE_SKIP%  ##
%TSIP_RCV_REQ_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_RES_INVITE%  ##
%TSIP_RCV_REQ_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_INVITE:TSIP_RCV_REQ_INVITE%  ##
%TSIP_RCV_REQ_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_ACK:TSIP_MSG_WAIT%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_MSG_WAIT:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_MSG_WAIT [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pTHIS->start_trans = YES;
			pINPUT->InitLog(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_REQ_INVITE:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_INVITE [EDGE] TSIP_REQ_INVITE", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransReq(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			break;
		case TSIP_RCV_RES_INVITE:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE [EDGE] TSIP_REQ_INVITE", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransReq(pTHIS, pINPUT);
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

    FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_REQ_INVITE", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_REQ;
	}#

%TSIP_RCV_RES_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_RES_INVITE_SKIP%  ##
%TSIP_RCV_RES_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_RES_INVITE%  ##
%TSIP_RCV_RES_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_INVITE:TSIP_RCV_REQ_INVITE%  ##
%TSIP_RCV_RES_INVITE:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_ACK:TSIP_RCV_REQ_ACK%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_RCV_REQ_INVITE:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_INVITE [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pINPUT->SetResNormal(pTHIS, pINPUT);
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_RES_INVITE_SKIP:
    		FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE_SKIP [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pINPUT->SetResNormal(pTHIS, pINPUT);
			pINPUT->SetResDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_RES_INVITE:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetRetransRes(pTHIS, pINPUT);
			pINPUT->SetResDataSize(pTHIS, pINPUT);
			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

    FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_RES_INVITE", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_RES;
	}#

%TSIP_RCV_REQ_ACK:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_REQ_ACK%  ##
%TSIP_RCV_REQ_ACK:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_REQ_ACK%  ##
%TSIP_RCV_REQ_ACK:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_INVITE:TSIP_RCV_REQ_ACK%  ##
%TSIP_RCV_REQ_ACK:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_ACK:TSIP_RCV_REQ_ACK%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_RCV_RES_INVITE:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE [EDGE] TSIP_REQ_ACK", __FILE__, __LINE__);

			/* ADD MSG */
			pINPUT->AddMsg(pTHIS, pINPUT);	
			pINPUT->SetAck(pTHIS, pINPUT);
			pTHIS->finish_trans = YES;
			pINPUT->SetReqDataSize(pTHIS, pINPUT);

			pINPUT->delete_node = NO;

			break;
		case TSIP_RCV_REQ_ACK:

			/* NODE 삭제 */
			pINPUT->delete_node = YES;

			switch (pINPUT->status)
			{
				case TSIP_RES_SKIP:
    				FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_ACK [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);
					pINPUT->SetResDataSize(pTHIS, pINPUT);
					break;
				case TSIP_RES_NORMAL:
    				FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_ACK [EDGE] TSIP_RES_NORMAL", __FILE__, __LINE__);
					pINPUT->SetRetransRes(pTHIS, pINPUT);
					pINPUT->SetResDataSize(pTHIS, pINPUT);
					break;
				case TSIP_REQ_INVITE:
    				FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_ACK [EDGE] TSIP_REQ_INVITE", __FILE__, __LINE__);
					pINPUT->SetRetransReq(pTHIS, pINPUT);
					pINPUT->SetReqDataSize(pTHIS, pINPUT);
					break;
				case TSIP_REQ_ACK:
    				FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_ACK [EDGE] TSIP_REQ_ACK", __FILE__, __LINE__);
					pINPUT->SetRetransAck(pTHIS, pINPUT);
					pINPUT->SetReqDataSize(pTHIS, pINPUT);
					break;
				default:
					break;
			}

			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

    FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_REQ_ACK", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_ACK;
	}#

%TSIP_RCV_RES_INVITE_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_SKIP:TSIP_RCV_RES_INVITE_SKIP%  ##
%TSIP_RCV_RES_INVITE_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_RES_NORMAL:TSIP_RCV_RES_INVITE%  ##
%TSIP_RCV_RES_INVITE_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_INVITE:TSIP_RCV_RES_INVITE_SKIP%  ##
%TSIP_RCV_RES_INVITE_SKIP:OTHERMSG:(D)pINPUT->status:(Y)TSIP_REQ_ACK:TSIP_MSG_WAIT%  #{

	switch(pTHIS->TSIP_OLD_STATE)
	{
		case TSIP_RCV_REQ_INVITE:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_REQ_INVITE [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetResSkip(pTHIS, pINPUT);
			pINPUT->SetResDataSize(pTHIS, pINPUT);
			break;
		case TSIP_RCV_RES_INVITE:
			FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);

			/* NODE 삭제 */
			pINPUT->delete_node = YES;
			pINPUT->SetResDataSize(pTHIS, pINPUT);
			break;
		case TSIP_RCV_RES_INVITE_SKIP:

			/* NODE 삭제 */
			pINPUT->delete_node = YES;

			switch (pINPUT->status)
			{
				case TSIP_RES_SKIP:
    				FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE_SKIP [EDGE] TSIP_RES_SKIP", __FILE__, __LINE__);
					pINPUT->SetResSkip(pTHIS, pINPUT);
					pINPUT->SetResDataSize(pTHIS, pINPUT);
					break;
				case TSIP_REQ_INVITE:
    				FPRINTF(LOG_LEVEL, "### [%s][%d] TSIP_RCV_RES_INVITE_SKIP [EDGE] TSIP_REQ_INVITE", __FILE__, __LINE__);
					pINPUT->SetRetransReq(pTHIS, pINPUT);
					pINPUT->SetReqDataSize(pTHIS, pINPUT);
					break;
				default:
					break;
			}
			break;
		default:
			FPRINTF(LOG_LEVEL, "### [%s][%d] UNKNOWN TSIP_OLD_STATUS: [%ld] [EDGE]", __FILE__, __LINE__, pTHIS->TSIP_OLD_STATE);
			pINPUT->delete_node = YES;
			break;
	}

    FPRINTF(LOG_LEVEL, "### [%s][%d] [VERTEX] TSIP_RCV_RES_INVITE_SKIP", __FILE__, __LINE__);
	pTHIS->endstatus = SIP_ENDSTATUS_1xx;
	}#

<TAG_FLOW_END:TSIP>

/* LOG_MSRP_TRANS를 위한 define 값 */
#define MSRP_MSGID_SIZE				33
#define MSRP_MSGID_LEN				(MSRP_MSGID_SIZE - 1)
#define MSRP_PATH_SIZE				257
#define MSRP_PATH_LEN				(MSRP_PATH_SIZE - 1)
#define MSRP_TID_SIZE				33
#define MSRP_TID_LEN				(MSRP_TID_SIZE - 1)
#define MSRP_METHOD_SIZE			17
#define MSRP_METHOD_LEN				(MSRP_METHOD_SIZE - 1)
#define MSRP_CONTENTTYPE_SIZE		33
#define MSRP_CONTENTTYPE_LEN		(MSRP_CONTENTTYPE_SIZE - 1)
#define MSRP_SURI_SIZE				65
#define MSRP_SURI_LEN				(MSRP_SURI_SIZE - 1)

<TAG_DEFINE_START:MSRP_ENDSTATUS>       
#define MSRP_ENDSTATUS_REQ		1
#define MSRP_ENDSTATUS_RES		2
#define MSRP_ENDSTATUS_REPORT	3
<TAG_DEFINE_END:MSRP_ENDSTATUS>       

<TAG_DEFINE_START:MSRP_ERROR>       
#define MSRP_UERR_EMPTY	0
#define MSRP_UERR_9000	9000	/* 서버로부터 오류를 나타내는 응답 코드가 온 경우 (응답 코드 400 이상) */ 
#define MSRP_UERR_9100	9100	/* Abort 상태로 끝난 경우 */ 
#define MSRP_UERR_9200	9200	/* TIMEOUT으로 정리된 경우 */
#define MSRP_UERR_9300	9300	/* ABNORMAL FINISH */
<TAG_DEFINE_END:MSRP_ERROR>

<TAG_DEFINE_START:MSRP_FLAG>
#define MSRP_FLAG_NOTHING	0
#define MSRP_FLAG_YES		1
#define MSRP_FLAG_NO		2
#define MSRP_FLAG_PARTIAL	3
<TAG_DEFINE_END:MSRP_FLAG>

<TAG_DEFINE_START:MSRP_METHOD>
#define MSRP_METHOD_UNKNOWN		0
#define MSRP_METHOD_RESPONSE	10
#define MSRP_METHOD_SEND		11
#define MSRP_METHOD_AUTH		12
#define MSRP_METHOD_REPORT		13
<TAG_DEFINE_END:MSRP_METHOD>

/**
 * @brief LOG_MSRP_TRANS : MSRP Transaciton DB Log
 *
 *
 * @see	common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_MSRP_Trans_Log {
	<STG_COMMON:LOG_COMMON>

	DEF			<TAG_DEFINE:PLATFORMTYPE>usPlatformType;        /**< usSvcL4Type / 1000 * 1000 */
	DEF			<TAG_DEFINE:L4CODE>usSvcL4Type;         		/**< IP, PORT로 판단한 Service type */
	DEF			<TAG_DEFINE:L7CODE>usSvcL7Type;         		/**< URL, HostName으로 판단한 Service type */
	U8			ucSubSysNo;										/**< Sub System No. */
	STIME		TransStartTime;		/**< Transaction 시작 시간 */ 
	MTIME		TransStartMTime;	/**< Transaction 시작 시간 (Micro) */ 
	STRING		MSGID[MSRP_MSGID_SIZE];	/**< Message-ID */ 
	U16			method;				/**< Request Method */
	STRING		MethodString[MSRP_METHOD_SIZE]; /**< Request Method */ 
	STRING		ToPath[MSRP_PATH_SIZE];	/**< To-Path */ 
	STRING		FromPath[MSRP_PATH_SIZE];	/**< From-Path */ 
	U16			<TAG_DEFINE:MSRP_FLAG>SuccessReport;	/**< Success-Report 세팅 값 */ 
	U16			<TAG_DEFINE:MSRP_FLAG>FailureReport;	/**< Failure-Report 세팅 값 */ 
	STRING		ContentsType[MSRP_CONTENTTYPE_SIZE];		/**< ContentType */ 
	U16			Vendor;
	IP4			SrcIP;				/**< Source IP */ 
	IP4			DestIP;				/**< Destination IP */ 
	U16			SrcPort;			/**< Source Port */ 
	U16			DestPort;			/**< Destination Port */ 
	STIME		TransEndTime;		/**< Transaction 끝 시간 */ 
	MTIME		TransEndMTime;		/**< Transaction 끝 시간 (Micro) */ 
	STIME		ResTime;			/**< Response를 받은 시간 */
	MTIME		ResMTime;			/**< Response를 받은 시간 (Micro) */
	STIME		ReportTime;			/**< Report Method를 보낸 시간 */
	MTIME		ReportMTime;		/**< Report Method를 보낸  시간 (Micro) */
	U32			ResCode;			/**< Response Code */ 
	U32			ReportCode;			/**< Report Code */ 
	U32     	LastUserErrCode;	/**< user error */
	U16			L7RstCode;			/**< Response Code or Report Code */ 

	U16			TotalReqCnt;	
	U16			TotalResCnt;	
	U16			TotalReportCnt;
	U16			RetransReqCnt;
	U16			RetransResCnt;

	U32			ReqBodySize;		@CILOG_HIDDEN@		/**< UDP, TCP Payload Size */
	U32			ResBodySize;		@CILOG_HIDDEN@		/**< UDP, TCP Payload Size */
	U32			ReportBodySize;		@CILOG_HIDDEN@		/**< UDP, TCP Payload Size */
	U32			ReqDataSize;							/**< UDP, TCP Payload Size */
	U32			ResDataSize;							/**< UDP, TCP Payload Size */
	U32			ReportDataSize;							/**< UDP, TCP Payload Size */
	U32			ReqIPDataSize;							/**< IP Payload Size */ 
	U32			ResIPDataSize;							/**< IP Payload Size */ 
	U32			ReportIPDataSize;						/**< IP Payload Size */ 
	U32			RetransReqDataSize;						/**< Retrans UDP, TCP Payload Size */
	U32			RetransResDataSize;						/**< Retrans UDP, TCP Payload Size */
	U16			<TAG_DEFINE:MSRP_ENDSTATUS>EndStatus;

	U32			ResGapTime;								/**< ResTime - TransStartTime */ 
	U32			ReportGapTime;							/**< ReportTime - ResTime */ 
	STIME		OpStartTime;							/**< 분석 시작 Time */			
	MTIME		OpStartMTime;							/**< 분석 시작 Micro Time */	
	STIME		OpEndTime;								/**< 마지막 처리 Time */		
	MTIME		OpEndMTime;								/**< 마지막 처리 Micro Time */	
} LOG_MSRP_TRANS; 

TABLE_LOG typedef struct _st_CF_XCAP_MSG {
	<STG_COMMON:LOG_COMMON>

	U32		HeaderSize;      
	U32		BodySize;
	U32		ContentLength;          
	STRING	LOGURL[MAX_LOGURL_SIZE];
} CF_XCAP_MSG;

/** 
 * @brief LOG_RPPI : RPPI Transaciton DB Log
 *  
 *  
 * @see common_stg.h
 *  
 * @note   nothing
 *  
 * @todo   nothing
 */ 
TABLE_LOG typedef struct _st_RPPI_Log {
    <STG_COMMON:LOG_COMMON> 
   
    S64         llRPDuration;
    U32         uiGREKey;
    U16         usSvcOption;
    U16         usFMux;
    U16         usRMux; 
    U8          ucAlwaysOnFlag;         
    U16         usRegiReqCnt;           
    U16         usRegiSuccRepCnt;       
    U16         usUpdateReqCnt;         
    U16         usUpdateAckCnt;
	STIME		uiFirstUpdateReqTime;
	MTIME		uiFirstUpdateReqMTime;
	STIME		uiFirstUpdateResTime; 
	MTIME		uiFirstUpdateResMTime; 
	STIME		uiLastUpdateReqTime;
	MTIME		uiLastUpdateReqMTime;
	STIME		uiLastUpdateResTime; 
	MTIME		uiLastUpdateResMTime; 
    U16         usActiveStartCnt;       
    U16         usActiveStopCnt;        
    U16         usSvcOptChgCnt;
	STRING		szFirstBSMSC[DEF_BSMSD_LENGTH]; 
    U16         usBSMSCChgCnt;
    U32         uiRegiRepCode;

    U32         uiUpGREPkts;
    U32         uiDnGREPkts;
    U32         uiUpGREBytes;
    U32         uiDnGREBytes;

    U16         usUpLCPReqCnt;
    U16         usDnLCPReqCnt;
    STIME       uiUpLCPStartTime;
    MTIME       uiUpLCPStartMTime;
    STIME       uiUpLCPEndTime;
    MTIME       uiUpLCPEndMTime;

    STIME       uiDnLCPStartTime;
    MTIME       uiDnLCPStartMTime;
    STIME       uiDnLCPEndTime;
    MTIME       uiDnLCPEndMTime;
    S64         llLCPDuration;
	
	U16         usAuthMethod;
    STIME       uiAuthReqTime;
    MTIME       uiAuthReqMTime;
    STIME       uiAuthEndTime;
    MTIME       uiAuthEndMTime;
    S64         llAuthDuration;
    U16         usAuthResultCode;

    IP4         uiAAAIP;
    STIME       uiAccessReqTime;
    MTIME       uiAccessReqMTime;
    STIME       uiAccessResTime;
    MTIME       uiAccessResMTime;
    U16         usAccessResCode;

    U16         usUpIPCPReqCnt;
    U16         usDnIPCPReqCnt;
    STIME       uiUpIPCPStartTime;
    MTIME       uiUpIPCPStartMTime;
    STIME       uiUpIPCPEndTime;
    MTIME       uiUpIPCPEndMTime;

    STIME       uiDnIPCPStartTime;
    MTIME       uiDnIPCPStartMTime;
    STIME       uiDnIPCPEndTime;
    MTIME       uiDnIPCPEndMTime;

    S64         llIPCPDuration;
    STIME       uiPPPSetupTime;
    MTIME       uiPPPSetupMTime;
    S64         llPPPSetupDelTime;
    U16         usAccountReqCnt;
    U16         usAccountSuccRepCnt;
   
	STIME		uiAccStartResTime;
	MTIME		uiAccStartResMTime;
	STIME		uiLastAccStartReqTime; 
	MTIME		uiLastAccStartReqMTime; 
	STIME		uiLastAccStartResTime; 
	MTIME		uiLastAccStartResMTime;
	STIME		uiFirstAccStopReqTime; 
	MTIME		uiFirstAccStopReqMTime; 
	STIME		uiFirstAccStopResTime; 
	MTIME		uiFirstAccStopResMTime;
	STIME		uiLastAccStopReqTime; 
	MTIME		uiLastAccStopReqMTime; 
	STIME		uiLastAccStopResTime; 
	MTIME		uiLastAccStopResMTime;
	
	U16         usAccountCode;

	U16         usCallType;
    U16         usCallState;
    U32         uiSetupFailReason;

    U16         usInterimTime;
    S64         llRPTCPSynDelTime;

    /* FOR DIAMETER */
    IP4         uiCSCFIP;
    IP4         uiHSSIP;
    U16         usUARReqCnt;
    U16         usUARSuccRepCnt;
    U16         usSARReqCnt;
    U16         usSARSuccRepCnt;
    U16         usLIRReqCnt;
    U16         usLIRSuccRepCnt;
    U16         usMARReqCnt;
    U16         usMARSuccRepCnt;
    U16         usRTRReqCnt;
    U16         usRTRSuccRepCnt;
    U16         usPPRReqCnt;
    U16         usPPRSuccRepCnt;
    STIME       uiUARStartTime;
    MTIME       uiUARStartMTime;
	STIME       uiUAREndTime;
    MTIME       uiUAREndMTime;
    STIME       uiSARStartTime;
    MTIME       uiSARStartMTime;
    STIME       uiSAREndTime;
    MTIME       uiSAREndMTime;
    STIME       uiLIRStartTime;
    MTIME       uiLIRStartMTime;
    STIME       uiLIREndTime;
    MTIME       uiLIREndMTime;
    STIME       uiMARStartTime;
    MTIME       uiMARStartMTime;
    STIME       uiMAREndTime;
    MTIME       uiMAREndMTime;
    STIME       uiRTRStartTime;
    MTIME       uiRTRStartMTime;
    STIME       uiRTREndTime;
    MTIME       uiRTREndMTime;
    STIME       uiPPRStartTime;
    MTIME       uiPPRStartMTime;
    STIME       uiPPREndTime;
    MTIME       uiPPREndMTime;
    
	U32         uiFirstPlatformType;
    U32         uiFirstSvcL4Type;
    U32         uiFirstSvcL7Type;
    U32         uiLastPlatformType;
    U32         uiLastSvcL4Type;
    U32         uiLastSvcL7Type;

    U32         uiLastFailReason;
    U32         uiTCPSynCnt;
    U32         uiTCPConnCnt;
    STIME       uiFirstTCPSynTime;
    MTIME       uiFirstTCPSynMTime;
    STIME       uiTCPConnEndTime;
    MTIME       uiTCPConnEndMTime;

    U32         uiUpTCPPacketCnt;
    U32         uiDnTCPPacketCnt;
    U32         uiUpTCPRetransCnt;
    U32         uiDnTCPRetransCnt;

    S64         llTCPConnDelayedTime;
    U32         uiTCPConnDelayedCnt;
    U32         uiMenuGetCnt;
    U32         uiMenuAckCnt;
    STIME       uiMenuStartReqTime;
    MTIME       uiMenuStartReqMTime;
    STIME       uiMNAckTime;
    MTIME       uiMNAckMTime;
    S64         llMenuDelayedTime;
    U32         uiMenuDelayedCnt;
	U32         uiHTTPGetCnt;
    U32         uiHTTPAckCnt;
    STIME       uiHTTPStartReqTime;
    MTIME       uiHTTPStartReqMTime;
    STIME       uiHTTPMNAckTime;
    MTIME       uiHTTPMNAckMTime;
    S64         llHTTPDelayedTime;
    U32         uiHTTPDelayedCnt;
	U32			uiIMReqCnt;
	U32			uiIMSetupCnt;
	STIME		uiIMStartReqTime;
	MTIME		uiIMStartReqMTime;
	STIME		uiIMSetupTime;
	MTIME		uiIMSetupMTime;
    U32         uiDnReqCnt;
    U32         uiDnSuccCnt;
    S64         llUpDataLoadingTime;
    S64         llDnDataLoadingTime;
    U32         uiUpDataSize;
    U32         uiDnDataSize;
    U32         uiThroughputDelayCnt;
    U32         uiVODReqCnt;
    U32         uiVODSetupCnt;
	U32			uiVTReqCnt;
	U32			uiVTSetupCnt;
    U32         uiRTPUpCnt;
    U32         uiRTPDnCnt;
    U32         uiRTPUpLossCnt;
    U32         uiRTPDnLossCnt;
   	U32			uiRTPLossOverCnt;
	U32         uiRTPUpMaxJitter;
    U32         uiRTPDnMaxJitter;
    U32         uiRTPJitterOverCnt;
    U32         uiRTPUpDataSize;
    U32         uiRTPDnDataSize;
	U32			uiDNSReqCnt;
	U32			uiDNSResCnt;
	STIME		uiDNSReqTime;
	MTIME		uiDNSReqMTime;
	STIME		uiDNSResTime;
	MTIME		uiDNSResMTime;
	U32			uiDNSCode;
	U32			uiUpTotPktCnt;
	U32			uiDnTotPktCnt;
   	U32			uiUpTotDataSize;
	U32			uiDnTotDataSize; 
	STIME       uiReleaseTime;
    MTIME       uiReleaseMTime;
    STIME       uiOpStartTime;
    MTIME       uiOpStartMTime;
    STIME       uiOpEndTime;
    MTIME       uiOpEndMTime;
	STIME		uiFirstSvcStartTime;
	MTIME		uiFirstSvcStartMTime;
	STIME		uiFirstSvcEndTime;
	MTIME		uiFirstSvcEndMTime;
	STIME		uiLastSvcStartTime;
	MTIME		uiLastSvcStartMTime;
	STIME		uiLastSvcEndTime;
	MTIME		uiLastSvcEndMTime;
	STIME		uiAuthResTime;
	MTIME		uiAuthResMTime;
	U16			usAuthReqCnt;
	U16			usDiaReqCnt;
	U16			usDiaSuccRepCnt;
	S64			llDiaSuccSumTime;	
	U16			usUpLCPRetrans;				@CILOG_HIDDEN@
	U16			usDnLCPRetrans;				@CILOG_HIDDEN@
	U32			uiCHAPRespCode;				@CILOG_HIDDEN@ 
	U16			usUpIPCPRetrans;			@CILOG_HIDDEN@
	U16			usDnIPCPRetrans;			@CILOG_HIDDEN@
	U32			stopFlag;					@CILOG_HIDDEN@
	U32			stateFlag;					@CILOG_HIDDEN@
	U32			lcpEchoFlag;				@CILOG_HIDDEN@
	STIME		uiTmpAuthReqTime;			@CILOG_HIDDEN@			
	MTIME		uiTmpAuthReqMTime;			@CILOG_HIDDEN@			
	STIME		uiTmpAuthEndTime;			@CILOG_HIDDEN@			
	MTIME		uiTmpAuthEndMTime;			@CILOG_HIDDEN@			
} LOG_RPPI;

typedef struct _st_Notify_Sig {
	STIME		uiEventTime;
	U32			uiType;
} NOTIFY_SIG;

/*
   TRACE MSG HDR 
 */
#define MAX_TRACE_CNT   50
#define MAX_USER_NAME_LEN       24

enum {
	TRC_TYPE_IP	= 1,
	TRC_TYPE_IMSI,
	TRC_TYPE_SERV,
	TRC_TYPE_MDN,
	TRC_TYPE_ROAM_IMSI,
	TRC_TYPE_ROAM_MDN
};

typedef struct _st_TraceID {
    STRING 		szMIN[MAX_MIN_SIZE];
    S64   		llIMSI;
    IP4 		uIP;
} st_TraceID;

typedef struct _st_TraceInfo {
    st_TraceID  stTraceID;
    S32				dType;
    STIME			tExpiredTime;
    STRING			adminID[MAX_USER_NAME_LEN];
    U16				usEstimatedTime;
} st_TraceInfo;
    
typedef struct _st_TraceList {
    S32             count;
    S32             dSysNo;
    st_TraceInfo    stTraceInfo[MAX_TRACE_CNT];
} st_TraceList;

TABLE_LOG typedef struct _TraceMsgHdr {
    STIME		time;
    MTIME		mtime;

    S32			dType;
    U16			usDataLen;
    U8			reserved[2];

    st_TraceID 	stTraceID;
} st_TraceMsgHdr;



/**
 * @brief LOG_RPPI : RPPI Transaciton DB Log
 *
 *
 * @see common_stg.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_Ftp_Log {
    <STG_COMMON:LOG_COMMON>

	DEF         	<TAG_DEFINE:PLATFORMTYPE>usPlatformType;        /**< usSvcL4Type / 1000 * 1000 */
    DEF         	<TAG_DEFINE:L4CODE>usSvcL4Type;                 /**< IP, PORT로 판단한 Service type */
    DEF         	<TAG_DEFINE:L7CODE>usSvcL7Type;                 /**< URL, HostName으로 판단한 Service type */

    IP4				uiServerIP;
    U32				uiFTPLogonDuration;

    STIME			uiEndTime;
    MTIME			uiEndMTime;
    U32				uiEndDuration;
    STIME			uiTcpSynTime;
    MTIME			uiTcpSynMTime;
    STIME			uiTcpSynAckTime;

    U32				uiUpFrames;
    U32				uiDownFrames;
    U32				uiUpBytes;
    U32				uiDownBytes;

    U32				uiUpRetranBytes;
    U32				uiDownRetranBytes;

    STIME			uiFTPSynTime;
	MTIME			uiFTPSynMTime;
    STIME			uiFTPFinTime;
	MTIME			uiFTPFinMTime;

    U32				uiFTPUpFirstSeq;
    U32				uiFTPUpLastSeq;
    U32				uiFTPDownFirstSeq;
    U32				uiFTPDownLastSeq;
    STIME			uiLastUpdateTime;
    U32				uiFTPTimeDuration;
    U16				usCliFTPStatus;
	U16				usSvrFTPStatus;

	STIME       	OpStartTime;                            /**<  분석 시작 Time */
    MTIME       	OpStartMTime;                           /**<  분석 시작 Micro Time */
    STIME       	OpEndTime;                              /**<  마지막 처리 Time */
    MTIME       	OpEndMTime;                             /**<  마지막 처리 Micro Time */
} LOG_FTP;

TABLE_LOG typedef struct _st_Dns_Log {
	<STG_COMMON:LOG_COMMON>

    DEF             <TAG_DEFINE:PLATFORMTYPE>usPlatformType;        /**< usSvcL4Type / 1000 * 1000 */
    DEF             <TAG_DEFINE:L4CODE>usSvcL4Type;                 /**< IP, PORT로 판단한 Service type */
    DEF             <TAG_DEFINE:L7CODE>usSvcL7Type;                 /**< URL, HostName으로 판단한 Service type */

	U16     usIdentification;
    U8      ucErrorCode;

    U16     usSPort;
    IP4     DIP;

    STIME   dRequestTime;
    MTIME   dRequestMTime;
    STIME   dResponseTime;
    MTIME   dResponseMTime;

    U16     usRequestCnt;
    U16     usResponseCnt;

    U32     uiRequestSize;
    U32     uiResponseSize;
} LOG_DNS;


TABLE_LOG typedef struct _st_RPPI_ERR_Log {
    <STG_COMMON:LOG_COMMON>

	IP4				uiAAAIP;
	IP4				uiCSCFIP;
	IP4				uiHSSIP;
	STIME			uiSessStartTime;
	MTIME			uiSessStartMTime;
	U16				usProtoType;
	U32				uiErrorCode;
	STIME       	uiOpStartTime;
    MTIME       	uiOpStartMTime;
    STIME       	uiOpEndTime;
    MTIME       	uiOpEndMTime;
} LOG_RPPI_ERR;      

<TAG_AUTO_DEFINE_START:TIMERINFO(0)>
RPPI_CALL_TIMEOUT
RPPI_WAIT_TIMEOUT
PI_VT_TIMEOUT
PI_IM_TIMEOUT
PI_TCP_RSTWAIT
PI_TCP_TIMEOUT
PI_DNS_TIMEOUT
PI_SIP_TIMEOUT
PI_MSRP_TIMEOUT
PI_RAD_TIMEOUT
PI_DIA_TIMEOUT
PI_CALL_TIMEOUT 
PI_WAIT_TIMEOUT
PI_DORM_TIMEOUT
RP_CALL_TIMEOUT
RP_DORM_TIMEOUT
PI_INET_TIMEOUT
PI_RCALL_TIMEOUT
RP_RCALL_TIMEOUT
PI_RCALL_SIGWAIT
RP_RCALL_SIGWAIT
<TAG_AUTO_DEFINE_END:TIMERINFO>


typedef struct _st_SVC_CONF {
	S32			dSvcID;		
	S32			dOnOff;		
} SVC_CONF;

/** 
 * @brief LOG_DIAMETER : LOG DIAMETER DB Log
 *  
 *  
 * @see common_stg.h
 *  
 * @note   nothing
 *  
 * @todo   nothing
 */ 
TABLE_LOG typedef struct _st_DIAMETER_Log {
    <STG_COMMON:LOG_COMMON> 

	STIME       uiOpStartTime;
	MTIME       uiOpStartMTime;
	STIME       uiOpEndTime;
	MTIME       uiOpEndMTime;

	U32         uiLastFailReason;
   
    /* FOR DIAMETER */
    IP4         uiCSCFIP;
    IP4         uiHSSIP;
    U16         usUARReqCnt;
    U16         usUARSuccRepCnt;
    U16         usSARReqCnt;
    U16         usSARSuccRepCnt;
    U16         usLIRReqCnt;
    U16         usLIRSuccRepCnt;
    U16         usMARReqCnt;
    U16         usMARSuccRepCnt;
    U16         usRTRReqCnt;
    U16         usRTRSuccRepCnt;
    U16         usPPRReqCnt;
    U16         usPPRSuccRepCnt;
    STIME       uiUARStartTime;
    MTIME       uiUARStartMTime;
	STIME       uiUAREndTime;
    MTIME       uiUAREndMTime;
    STIME       uiSARStartTime;
    MTIME       uiSARStartMTime;
    STIME       uiSAREndTime;
    MTIME       uiSAREndMTime;
    STIME       uiLIRStartTime;
    MTIME       uiLIRStartMTime;
    STIME       uiLIREndTime;
    MTIME       uiLIREndMTime;
    STIME       uiMARStartTime;
    MTIME       uiMARStartMTime;
    STIME       uiMAREndTime;
    MTIME       uiMAREndMTime;
    STIME       uiRTRStartTime;
    MTIME       uiRTRStartMTime;
    STIME       uiRTREndTime;
    MTIME       uiRTREndMTime;
    STIME       uiPPRStartTime;
    MTIME       uiPPRStartMTime;
    STIME       uiPPREndTime;
    MTIME       uiPPREndMTime;
    
	U16			usDiaReqCnt;
	U16			usDiaSuccRepCnt;
	S64			llDiaSuccSumTime;	
} DB_LOG_DIAMETER;

typedef struct _st_inet_call_key {
    U32         uiIP;
    U32         uiReserved;
} INET_CALL_KEY;

typedef struct _st_inet_call_data {
	U32			uiSessStartTime;
	U32			uiReserved;
    OFFSET      offset_Data;
} INET_CALL_DATA;

typedef struct _st_inet_key {
    U32         uiCIP;
    U32         uiSIP;
    U16         usSPort;
    U16         usReserved;
    U32         uiReserved;
} INET_KEY;

typedef struct _st_inet_data {
	U64			timerNID;
	OFFSET		offset_Log;	
} INET_DATA;

/**
 * @brief INET_LOG : Internet 사용량 분석 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_Inet_Log {
	<STG_COMMON:LOG_COMMON>

	IP4		uiServerIP;					/**< Server IP */
	U16		usServerPort;				/**< Server Port */
	STIME	uiFirstPktTime;				/**< First Packet Time */
	MTIME	uiFirstPktMTime;			/**< First Packet Micro Time */
	STIME	uiLastPktTime;				/**< Last Packet Time */
	MTIME	uiLastPktMTime;				/**< Last Packet Micro Time */
	U32		uiUpPacketCnt;				/**< MN => Server, 패킷 개수 */
	U32		uiDnPacketCnt;				/**< Server => MN, 패킷 개수 */
	U32		uiUpPacketSize;				/**< MN => Server, 데이터 사이즈 */
	U32		uiDnPacketSize;				/**< Server => MN, 데이터 사이즈 */
	STIME	uiOpStartTime;				/**< 분석 시작 Time */
	MTIME	uiOpStartMTime;				/**< 분석 시작 Micro Time */
	STIME	uiOpEndTime;				/**< 마지막 처리 Time */
	MTIME	uiOpEndMTime;				/**< 마지막 처리 Micro Time */
} LOG_INET;


/**
 * @brief TCP_SESS_LOG : TCP 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
TABLE_LOG typedef struct _st_ITcp_Sess_Log {
	<STG_COMMON:LOG_COMMON>

	DEF		<TAG_DEFINE:PLATFORMTYPE>usPlatformType;	/**< PlatformType usSvcL4Type / 1000 * 1000 */
	DEF		<TAG_DEFINE:L4CODE>usSvcL4Type;				/**< Server IP, PORT로 판단한 Service type */
	U8		ucSubSysNo;					/**< Sub System No. */
	U16		usClientPort;				/**< 단말 Port */
	IP4		uiServerIP;					/**< Server IP */
	U16		usServerPort;				/**< Server Port */
	STIME	uiTcpSessStartTime;			/**< Tcp Session Start Time */
	MTIME	uiTcpSessStartMTime;		/**< Tcp Session Start Micro Time */
	U32		uiITcpSynTime;				/**< Tcp Syn Time */
	U32		uiITcpSynMTime;				/**< Tcp Syn Micro Time */
	STIME	uiTcpSynAckTime;			@CILOG_HIDDEN@	/**< Tcp SynAck Time */
	MTIME	uiTcpSynAckMTime;			@CILOG_HIDDEN@	/**< Tcp SynAck Micro Time */
	STIME	uiTcpSynAckAckTime;			@CILOG_HIDDEN@	/**< Syn => SynAck => Ack의 Ack Time */
	MTIME	uiTcpSynAckAckMTime;		@CILOG_HIDDEN@	/**< Syn => SynAck => Ack의 Ack Micro Time */
	U32		uiTcpSynAckGapTime;			/**< TcpSynAckTime - TcpSynTime */
	S64		llConnSetupGapTime;			/**< TcpConnEndTime - CallTime */
	U32		uiITcpFinTime;				/**< 첫번째 Tcp Fin, RST Time */
	U32		uiITcpFinMTime;				/**< 첫번째 Tcp Fin, RST Micro Time */
	U32		uiITcpFinAckTime;			/**< 마지막 Tcp Fin Ack Time */
	U32		uiITcpFinAckMTime;			/**< 마지막 Tcp Fin Ack Micro Time */
	U32		uiITcpUpLastPktTime;			/**< MN => Server, Last Packet Time */
	U32		uiITcpUpLastPktMTime;		/**< MN => Server, Last Packet Micro Time */
	U32		uiITcpDnLastPktTime;			/**< Server => MN, Last Packet Time */
	U32		uiITcpDnLastPktMTime;		/**< Server => MN, Last Packet Micro Time */
	STIME	uiTcpLastPktTime;			/**< Last Packet Time */
	MTIME	uiTcpLastPktMTime;			/**< Last Packet Micro Time */
	S64		llTcpSessGapTime;			/**< Last Packet Time - CallTime */
	DEF		<TAG_DEFINE:CLI>ucTcpClientStatus;			/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>ucTcpServerStatus;			/**< 서버 상태 */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;		/**< TCP Fail Code */
	U8		ucTcpSynCnt;				/**< Syn Count */
	U8		ucTcpSynAckCnt;				/**< SynAck Count */
	U8		ucTcpUpFinCnt;				/**< MN => Server, Fin Count */
	U8		ucTcpDnFinCnt;				/**< Server => MN, Fin Count */
	U8		ucTcpUpRstCnt;				/**< MN => Server, Rst Count */
	U8		ucTcpDnRstCnt;				/**< Server => MN, Rst Count */
	U32		uiIPDataUpPktCnt;			@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPDataDnPktCnt;			@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPTotUpPktCnt;			/**< MN => Server, 전구간에서 패킷 개수 */
	U32		uiIPTotDnPktCnt;			/**< Server => MN, 전구간에서 패킷 개수 */
	U32		uiIPDataUpRetransCnt;		@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPDataDnRetransCnt;		@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPTotUpRetransCnt;		/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		uiIPTotDnRetransCnt;		/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		uiIPDataUpPktSize;			@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPDataDnPktSize;			@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPTotUpPktSize;			/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		uiIPTotDnPktSize;			/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		uiIPDataUpRetransSize;		@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPDataDnRetransSize;		@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPTotUpRetransSize;		/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		uiIPTotDnRetransSize;		/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		uiTcpUpBodySize;			@CILOG_HIDDEN@	/**< MN => Server, Tcp Payload 사이즈 */
	U32		uiTcpDnBodySize;			@CILOG_HIDDEN@	/**< Server => MN, Tcp Payload 사이즈 */
	U32		uiTcpUpRetransBodySize;		@CILOG_HIDDEN@	/**< MN => Server, Tcp Payload 사이즈, 재전송 포함 */
	U32		uiTcpDnRetransBodySize;		@CILOG_HIDDEN@	/**< Server => MN, Tcp Payload 사이즈, 재전송 포함 */
	U16		usTcpUpMSS;					/**< MN => Server, Syn의 MSS */
	U16		usTcpDnMSS;					/**< Server => MN, SynAck의 MSS */
	U16		usTcpUpFirstWindowSize;		/**< MN => Server, 최초 패킷의 Window Size */
	U16		usTcpDnFirstWindowSize;		/**< Server => MN, 최초 패킷의 Window Size */
	STIME	uiOpStartTime;				/**< 분석 시작 Time */
	MTIME	uiOpStartMTime;				/**< 분석 시작 Micro Time */
	STIME	uiOpEndTime;				/**< 마지막 처리 Time */
	MTIME	uiOpEndMTime;				/**< 마지막 처리 Micro Time */
	U8		<TAG_DEFINE:RTX>ucRtx;		@CILOG_HIDDEN@	/**< Syn의 방향 */
} LOG_ITCP_SESS;

/**
 * @brief HTTP_LOG : HTTP 세션 정보를 DB Log
 *
 *
 * @see	aqua.h
 *
 * @note   nothing
 *
 * @todo   nothing
 */
STG_LOG_TEXT_PARSING typedef struct _st_IHttp_Log {
	<STG_COMMON:LOG_COMMON>

	U16		usClientPort;			/**< 단말 Port */
	IP4		uiServerIP;				/**< Server IP */
	U16		usServerPort;			/**< Server Port */
	U32		uiITcpSynTime;			/**< Tcp Syn Time */
	U32		uiITcpSynMTime;			/**< Tcp Syn Micro Time */
	U16		usTransID;				/**< HTTP Transaction ID */
	DEF     <TAG_DEFINE:PLATFORMTYPE>usPlatformType;			/**< usSvcL4Type / 1000 * 1000 */
	DEF		<TAG_DEFINE:L4CODE>usSvcL4Type;			/**< IP, PORT로 판단한 Service type */
	DEF		<TAG_DEFINE:L7CODE>usSvcL7Type;			/**< URL, HostName으로 판단한 Service type */
	U8		ucSubSysNo;				/**< Sub System No. */
	DEF		<TAG_DEFINE:ContentsType>usContentsType; @CILOG_HIDDEN@	/**< Content-Type Define Type */
	STRING	szContentsType[MAX_CONTENTSTYPE_SIZE]; 	/**< Content-Type String */	/* HTTP level */ 
	DEF		<TAG_DEFINE:METHOD>ucMethod;		/**< Method Code 값 */			/* HTTP level */
	STIME	uiReqStartTime;			/**< GET/POST Request Start Time */
	MTIME	uiReqStartMTime;		/**< GET/POST Request Start Micro Time */
	STIME	uiReqEndTime;			@CILOG_HIDDEN@	/**< GET/POST Request End Time */
	MTIME	uiReqEndMTime;			@CILOG_HIDDEN@	/**< GET/POST Request End Micro Time */
	STIME	uiReqAckTime;			@CILOG_HIDDEN@	/**< Request에 대한 서버 측의 Ack Time */
	MTIME	uiReqAckMTime;			@CILOG_HIDDEN@	/**< Request에 대한 서버 측의 Ack Micro Time */
	STIME	uiResStartTime;			@CILOG_HIDDEN@	/**< Response Start Time */
	MTIME	uiResStartMTime;		@CILOG_HIDDEN@	/**< Response Start Micro Time */
	STIME	uiResEndTime;			@CILOG_HIDDEN@	/**< Response End Time */
	MTIME	uiResEndMTime;			@CILOG_HIDDEN@	/**< Response End Micro Time */
	STIME	uiMNAckTime;			@CILOG_HIDDEN@	/**< 단말 Ack Time */
	MTIME	uiMNAckMTime;			@CILOG_HIDDEN@	/**< 단말 Ack Micro Time */
	STIME	uiLastPktTime;			@CILOG_HIDDEN@	/**< Last Packet Time */
	MTIME	uiLastPktMTime;			@CILOG_HIDDEN@	/**< Last Packet Micro Time */
	U32		uiReqEndGapTime;		/**< ReqEndTime - ReqStartTime */
	U32		uiReqAckGapTime;		/**< ReqAckTime - ReqStartTime */
	U32		uiResStartGapTime;		/**< ResStartTime - ReqStartTime */
	U32		uiResEndGapTime;		/**< ResEndTime - ReqStartTime */
	U32		uiMNAckGapTime;			/**< MNAckTime - ReqStartTime */
	S64		llTransGapTime;			/**< LastPktTime - ReqStartTime */
	U32		usResCode;				/**< HTTP Response Code */
	DEF		<TAG_DEFINE:CLI>ucTcpClientStatus;			/**< 단말 상태 */
	DEF		<TAG_DEFINE:SVR>ucTcpServerStatus;			/**< 서버 상태 */
	DEF		<TAG_DEFINE:LOG_HTTP_STATUS>ucStatus;	/**< HTTP 서비스 상태 */
	U32		usUserErrorCode;		/**< NTAS Error Code */
	DEF		<TAG_DEFINE:L4FAILCODE>usL4FailCode;	/**< TCP Fail Code */
	U16		usL7FailCode;			/**< HTTP Fail Code */
	U16		usLOGURLSize;			@CILOG_HIDDEN@	/**< LOG URL Size */			/* HTTP level */
	STRING	szLOGURL[MAX_LOGURL_SIZE];	@CILOG_HIDDEN@	/**< LOG URL */	
	U16		usIURLSize;				/**< LOG URL Size */			/* HTTP level */
	STRING	szIURL[MAX_IURL_SIZE];	/**< LOG URL */	
	U32		uiIPDataUpPktCnt;		@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPDataDnPktCnt;		@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 패킷 개수 */
	U32		uiIPTotUpPktCnt;		/**< MN => Server, 전구간에서 패킷 개수 */
	U32		uiIPTotDnPktCnt;		/**< Server => MN, 전구간에서 패킷 개수 */
	U32		uiIPDataUpRetransCnt;	@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPDataDnRetransCnt;	@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 재전송 패킷 개수 */
	U32		uiIPTotUpRetransCnt;	/**< MN => Server, 전구간에서 재전송 패킷 개수 */
	U32		uiIPTotDnRetransCnt;	/**< Server => MN, 전구간에서 재전송 패킷 개수 */
	U32		uiIPDataUpPktSize;		@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPDataDnPktSize;		@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 데이터 사이즈 */
	U32		uiIPTotUpPktSize;		/**< MN => Server, 전구간에서 데이터 사이즈 */
	U32		uiIPTotDnPktSize;		/**< Server => MN, 전구간에서 데이터 사이즈 */
	U32		uiIPDataUpRetransSize;	@CILOG_HIDDEN@	/**< MN => Server, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPDataDnRetransSize;	@CILOG_HIDDEN@	/**< Server => MN, 데이터 전송 단계에서 재전송 데이터 사이즈 */
	U32		uiIPTotUpRetransSize;	/**< MN => Server, 전구간에서 재전송 데이터 사이즈 */
	U32		uiIPTotDnRetransSize;	/**< Server => MN, 전구간에서 재전송 데이터 사이즈 */
	U32		uiTcpUpBodySize;		@CILOG_HIDDEN@	/**< MN => Server, TCP Payload Size */
	U32		uiTcpDnBodySize;		@CILOG_HIDDEN@	/**< Server => MN, TCP Payload Size */
	U32		uiUpHeaderSize;			/**< MN => Server, HTTP Header Size */
	U32		uiDnHeaderSize;			/**< Server => MN, HTTP Header Size */
	U32		uiUpBodySize;			/**< MN => Server, HTTP Body Size */
	U32		uiDnBodySize;			/**< Server => MN, HTTP Body Size */
	U32		uiContentLength;		/**< HTTP Response Header의 ContentLength 필드 값 */
	STIME	uiOpStartTime;			/** 분석 시작 Time */
	MTIME	uiOpStartMTime;			/** 분석 시작 Micro Time */
	STIME	uiOpEndTime;			/** 마지막 처리 Time */
	MTIME	uiOpEndMTime;			/** 마지막 처리 Micro Time */

	S32		dChunked;		@CILOG_HIDDEN@

	S32		dReqZip;		@CILOG_HIDDEN@
	S32		dReqMultiLen;	@CILOG_HIDDEN@
	STRING	szReqMulti[MAX_MULTIPART_SIZE];	@CILOG_HIDDEN@
	
	S32		dResZip;		@CILOG_HIDDEN@
	S32		dResMultiLen;	@CILOG_HIDDEN@
	STRING	szResMulti[MAX_MULTIPART_SIZE];	@CILOG_HIDDEN@

	U32		uiLimitDataSize;		@CILOG_HIDDEN@	/**< Server => MN, TCP Payload Size 10초 이내 */
} LOG_IHTTP_TRANS;				$PARSING_CASE_IGNORE$

/*
 * $Log: common_stg.pstg,v $
 * Revision 1.1.1.1  2011/08/29 05:56:43  dcham
 * NEW OAM SYSTEM
 *
 * Revision 1.1  2011/08/19 04:25:39  uamyd
 * CGALIB moved in DQMS
 *
 * Revision 1.4  2011/08/12 05:08:10  hhbaek
 * common_stg.pstg
 *
 * Revision 1.3  2011/08/08 08:38:42  hhbaek
 * *** empty log message ***
 *
 * Revision 1.2  2011/08/05 08:49:11  uamyd
 * modified
 *
 * Revision 1.1  2011/08/03 06:02:38  uamyd
 * CGA, HASHO, TIMERN library added
 *
 * Revision 1.154  2011/07/11 07:58:58  night1700
 * *** empty log message ***
 *
 * Revision 1.153  2011/05/13 11:52:11  jsyoon
 * *** empty log message ***
 *
 * Revision 1.152  2011/05/09 16:28:48  innaei
 * *** empty log message ***
 *
 * Revision 1.151  2011/05/09 08:55:58  dark264sh
 * A_CALL: multi 처리 위한 S_MSGQ, SEQ_PROC, S_SSHM 추가
 *
 * Revision 1.150  2011/05/02 08:25:01  jsyoon
 * *** empty log message ***
 *
 * Revision 1.149  2011/05/01 14:15:30  jsyoon
 * *** empty log message ***
 *
 * Revision 1.148  2011/04/24 10:44:23  jsyoon
 * *** empty log message ***
 *
 * Revision 1.147  2011/04/24 09:55:47  dark264sh
 * PI_RCALL_SIGWAIT, RP_RCALL_SIGWAIT 추가
 *
 * Revision 1.146  2011/04/23 10:55:13  dark264sh
 * PI_RCALL_TIMEOUT, RP_RCALL_TIMEOUT 추가
 *
 * Revision 1.145  2011/04/22 17:36:59  innaei
 * *** empty log message ***
 *
 * Revision 1.144  2011/04/20 10:01:01  dark264sh
 * INET_CALL_DATA 구조체에 SessStartTime 추가
 *
 * Revision 1.143  2011/04/19 15:20:49  jsyoon
 * *** empty log message ***
 *
 * Revision 1.142  2011/04/19 08:42:50  jsyoon
 * *** empty log message ***
 *
 * Revision 1.141  2011/04/18 15:45:10  jsyoon
 * *** empty log message ***
 *
 * Revision 1.140  2011/04/17 11:43:15  jsyoon
 * *** empty log message ***
 *
 * Revision 1.139  2011/04/16 09:25:14  dark264sh
 * L4_INET_RECV 추가, APP_INET_SEND, APP_INET_RECV 삭제
 *
 * Revision 1.138  2011/04/16 08:12:00  dark264sh
 * SYN, SYNACK없이 TCP Session을 생성한 경우 처리를 위한 define 추가
 *
 * Revision 1.137  2011/04/14 14:50:56  dark264sh
 * HTTP_TSESS 에서 usContentsTypeSize, szContentsType 추가
 *
 * Revision 1.136  2011/04/14 11:05:52  dark264sh
 * LOG_IHTTP_TRANS 에서 link_cnt, href_cnt 삭제
 *
 * Revision 1.135  2011/04/14 10:29:44  dark264sh
 * *** empty log message ***
 *
 * Revision 1.134  2011/04/14 08:17:59  dark264sh
 * LOG_ITCP_SESS, LOG_IHTTP_TRANS 추가
 *
 * Revision 1.133  2011/04/13 13:10:05  dark264sh
 * A_INET 추가
 *
 * Revision 1.132  2011/04/13 07:48:17  dark264sh
 * *** empty log message ***
 *
 * Revision 1.131  2011/04/13 07:28:18  dark264sh
 * LOG_INET 추가
 *
 * Revision 1.130  2011/04/13 03:07:14  jsyoon
 * *** empty log message ***
 *
 * Revision 1.129  2011/04/12 02:45:39  dark264sh
 * A_ITCP를 위한 define 값 추가
 *
 * Revision 1.128  2011/04/11 11:39:09  dark264sh
 * A_IHTTP를 위한 define 값 추가
 *
 * Revision 1.127  2011/04/11 08:24:17  jsyoon
 * *** empty log message ***
 *
 * Revision 1.126  2011/01/11 04:09:02  uamyd
 * modified
 *
 * Revision 1.7  2010/11/22 02:35:07  jwkim96
 * *** empty log message ***
 *
 * Revision 1.5  2010/09/29 06:50:05  uamyd
 * added lastFailReason to LOG_DIAMETER
 *
 * Revision 1.4  2010/09/27 01:28:17  dqms
 * added field opend,start time to LOG_DIAMETER_DB Log
 *
 * Revision 1.3  2010/09/17 05:06:49  dqms
 *  LOG_DIAMETER -> DB_LOG_DIAMETER, field correct by uamyd
 *
 * Revision 1.2  2010/09/16 04:30:41  dqms
 * added define of LOG_DIAMETER by uamyd
 *
 * Revision 1.1.1.1  2010/08/23 01:13:05  uamyd
 * DQMS With TOTMON, 2nd-import
 *
 * Revision 1.125  2010/05/04 12:16:07  dqms
 * *** empty log message ***
 *
 * Revision 1.124  2010/04/23 06:42:01  dqms
 * *** empty log message ***
 *
 * Revision 1.123  2010/03/18 11:21:04  dqms
 * *** empty log message ***
 *
 * Revision 1.122  2010/03/10 12:55:31  dqms
 * *** empty log message ***
 *
 * Revision 1.121  2010/03/10 02:35:56  dqms
 * LOG_SIGNAL->ucEquipType 추가
 *
 * Revision 1.120  2010/03/04 10:57:33  dark264sh
 * ROAM_SYS_LNS, ROAM_SYS_LAC, ROAM_SYS_AAA 삭제
 *
 * Revision 1.119  2010/03/04 10:05:26  jsyoon
 * *** empty log message ***
 *
 * Revision 1.118  2010/03/04 09:58:31  jsyoon
 * *** empty log message ***
 *
 * Revision 1.117  2010/03/03 09:38:51  jsyoon
 * *** empty log message ***
 *
 * Revision 1.116  2010/03/03 08:22:13  dark264sh
 * LOG_RPPI에 uiTmpAuthReqTime, uiTmpAuthEndTime 추가
 *
 * Revision 1.115  2010/03/02 06:08:17  dark264sh
 * *** empty log message ***
 *
 * Revision 1.114  2010/03/02 05:40:16  dark264sh
 * *** empty log message ***
 *
 * Revision 1.113  2010/03/02 05:20:42  dark264sh
 * *** empty log message ***
 *
 * Revision 1.112  2010/03/02 04:42:00  jsyoon
 * LOG_SIGNAL->usErrorCode 이름변경
 *
 * Revision 1.111  2010/02/26 05:52:39  jsyoon
 * Add A_L2TP Process information
 *
 * Revision 1.110  2010/02/25 11:54:11  dark264sh
 * ROAM 구별을 위한 define 추가
 *
 * Revision 1.109  2010/02/22 04:09:44  upst_cvs
 * *** empty log message ***
 *
 * Revision 1.108  2010/02/18 13:20:34  upst_cvs
 * MODIFY LOG_SIGNAL
 *
 * Revision 1.107  2009/11/19 06:27:55  pkg
 * LOG_RPPI LCP ECHO 처리를 위한 hidden field 추가
 *
 * Revision 1.106  2009/10/26 08:50:35  pkg
 * Page 이미지 처리 | LOG_HTTP에 LimitLen 추가
 *
 * Revision 1.105  2009/10/08 06:34:58  pkg
 * S_SSHM_RADIUS, S_SSHM_DIAMETER 추가
 *
 * Revision 1.104  2009/09/21 07:04:41  pkg
 * S_SSHM_MODELHASH1, S_SSHM_MODELHASH2 추가
 *
 * Revision 1.103  2009/09/15 12:34:21  pkg
 * *** empty log message ***
 *
 * Revision 1.102  2009/09/13 17:14:30  pkg
 * LCP CHAP IPCP에러 코드 세팅을 위한 Hidden 필드 추가
 *
 * Revision 1.101  2009/09/10 12:48:14  pkg
 * LOG_RPPI CHAR, DIAMETER 필등 추가
 *
 * Revision 1.100  2009/09/07 08:24:15  jsyoon
 * 법인서비스 L4_CORP, DEF_PLATFORM_CORP 추가
 *
 * Revision 1.99  2009/09/02 15:08:49  jsyoon
 * SIP의 1xx 응답일때 마지막 코드를 ResCode에 설정
 *
 * Revision 1.98  2009/08/23 12:26:21  jsyoon
 * ADD S_MSGQ_ETC
 *
 * Revision 1.97  2009/08/19 13:24:36  pkg
 * CALL_SESS_CNT(200003 => 250007) 크기 변경
 *
 * Revision 1.96  2009/08/17 15:51:28  jsyoon
 * *** empty log message ***
 *
 * Revision 1.95  2009/08/17 15:13:04  jsyoon
 * ADD S_SSHM_TCP_LIST S_SSHM_SIPT_LIST
 *
 * Revision 1.94  2009/08/16 12:06:35  jsyoon
 * ADD pTHIS->aPAGE_DATA.offset_InBODY = 0;
 *
 * Revision 1.93  2009/08/13 20:59:42  jsyoon
 * CALL -> 200003개로 변경
 *
 * Revision 1.92  2009/08/10 15:11:06  dqms
 * ADD SessStartTime in LOG_DIALUP_SESS
 *
 * Revision 1.91  2009/08/10 07:07:39  dqms
 * LOG_SIP_TRANS에 isUsed 필드 HIDDEN 으로 추가
 *
 * Revision 1.90  2009/08/09 16:34:39  dqms
 * *** empty log message ***
 *
 * Revision 1.89  2009/08/05 16:40:08  dqms
 * DEF_MSG_ACCESS     0
 *
 * Revision 1.88  2009/08/05 13:29:53  dqms
 * ADD S_SSHM_SIPT_SESS
 *
 * Revision 1.87  2009/08/03 08:23:40  dqms
 * *** empty log message ***
 *
 * Revision 1.86  2009/08/03 01:08:23  hjpark
 * TIMER_INFO에 U16을 U32로 변경
 *
 * Revision 1.85  2009/08/01 08:05:42  dqms
 * 명령어 처리를 위한 타이머 재정의
 *
 * Revision 1.84  2009/08/01 06:32:02  dqms
 * *** empty log message ***
 *
 * Revision 1.83  2009/08/01 06:25:31  dqms
 * *** empty log message ***
 *
 * Revision 1.82  2009/07/31 06:15:17  jsyoon
 * CALL_DUP_HASH_DATA 추가
 *
 * Revision 1.81  2009/07/30 14:41:04  dark264sh
 * *** empty log message ***
 *
 * Revision 1.80  2009/07/29 15:23:34  jsyoon
 * *** empty log message ***
 *
 * Revision 1.79  2009/07/29 04:40:41  pkg
 * LOG_RPPI_ERR에 CSCF IP 추가
 *
 * Revision 1.78  2009/07/29 01:49:22  dqms
 * DEF_WAIT_TIMEOUT        7초, A_IM/A_VT 타임아웃 시간 변경
 *
 * Revision 1.77  2009/07/26 13:01:39  dqms
 * *** empty log message ***
 *
 * Revision 1.76  2009/07/26 08:38:05  dqms
 * *** empty log message ***
 *
 * Revision 1.75  2009/07/25 13:53:50  dqms
 * *** empty log message ***
 *
 * Revision 1.74  2009/07/25 08:22:05  pkg
 * *** empty log message ***
 *
 * Revision 1.73  2009/07/22 05:45:55  dqms
 * ADD isSuccDNSFlag
 *
 * Revision 1.72  2009/07/22 04:59:48  dqms
 * *** empty log message ***
 *
 * Revision 1.71  2009/07/21 11:49:18  dqms
 * *** empty log message ***
 *
 * Revision 1.70  2009/07/20 15:04:51  dqms
 * *** empty log message ***
 *
 * Revision 1.69  2009/07/20 06:49:58  dqms
 * *** empty log message ***
 *
 * Revision 1.68  2009/07/20 04:30:02  pkg
 * *** empty log message ***
 *
 * Revision 1.67  2009/07/20 02:22:32  dqms
 * add dns log info
 *
 * Revision 1.66  2009/07/17 11:15:40  dqms
 * Add isStopFlag
 *
 * Revision 1.65  2009/07/17 09:53:47  jsyoon
 * *** empty log message ***
 *
 * Revision 1.64  2009/07/16 15:35:34  jsyoon
 * A_CALL 재시작 할때 포인터를 복구하도록 offset 추가
 *
 * Revision 1.63  2009/07/16 05:37:34  pkg
 * *** empty log message ***
 *
 * Revision 1.62  2009/07/15 17:01:48  dqms
 * REMOVE LOG_DIALUP_DEF_NUM
 *
 * Revision 1.61  2009/07/15 11:54:17  dqms
 * *** empty log message ***
 *
 * Revision 1.60  2009/07/15 11:02:54  pkg
 * *** empty log message ***
 *
 * Revision 1.59  2009/07/15 11:01:17  pkg
 * *** empty log message ***
 *
 * Revision 1.58  2009/07/15 02:03:11  dqms
 * ADD DIAL-UP ACCESS LOG
 *
 * Revision 1.57  2009/07/13 07:34:53  dqms
 * *** empty log message ***
 *
 * Revision 1.56  2009/07/12 12:39:02  dqms
 * *** empty log message ***
 *
 * Revision 1.55  2009/07/12 11:09:16  dqms
 * ADD 전화접속 코드
 *
 * Revision 1.54  2009/07/09 09:04:27  dqms
 * *** empty log message ***
 *
 * Revision 1.53  2009/07/09 08:36:33  dqms
 * PLATFORMTYPE 수정
 *
 * Revision 1.52  2009/07/08 12:57:41  dqms
 * ADD LOG_PISIGNAL_DEF_NUM
 *
 * Revision 1.51  2009/07/08 12:57:03  dqms
 * ADD MULTI A_RP, A_GRE
 *
 * Revision 1.50  2009/07/07 12:27:29  pkg
 * HTTP 관련 필드 추가, TotDataSize 필드 추가
 *
 * Revision 1.49  2009/07/07 06:32:02  dqms
 * ADD RADIUS_START_NUM 13
 *
 * Revision 1.48  2009/07/06 11:52:49  jsyoon
 * Add DIAMETER Interface
 *
 * Revision 1.47  2009/07/03 05:08:42  dqms
 * *** empty log message ***
 *
 * Revision 1.46  2009/07/02 06:25:35  dqms
 * ADD SEQ_PROC_MEM
 *
 * Revision 1.45  2009/07/02 06:00:37  dqms
 * ADD SEQ_PROC_PROCESS
 *
 * Revision 1.44  2009/06/28 11:25:50  dqms
 * *** empty log message ***
 *
 * Revision 1.43  2009/06/27 14:33:28  dqms
 * ADD L4_UNKNOWN
 *
 * Revision 1.42  2009/06/26 17:18:32  bgpark
 * *** empty log message ***
 *
 * Revision 1.41  2009/06/25 10:53:51  bgpark
 * LOG_RPPI_ERR 추가
 *
 * Revision 1.40  2009/06/24 07:26:35  bgpark
 * *** empty log message ***
 *
 * Revision 1.39  2009/06/22 12:41:13  upst_cvs
 * *** empty log message ***
 *
 * Revision 1.38  2009/06/21 13:39:07  upst_cvs
 * ADD TRACE MESSAGE HEAD NUM
 *
 * Revision 1.37  2009/06/20 07:05:36  bgpark
 * LOG_RPPI 필드 삭제
 *
 * Revision 1.36  2009/06/19 14:01:14  dark264sh
 * *** empty log message ***
 *
 * Revision 1.35  2009/06/19 13:35:40  dark264sh
 * *** empty log message ***
 *
 * Revision 1.34  2009/06/19 13:32:06  bgpark
 * LOG_RPPI 필드 추가
 *
 * Revision 1.33  2009/06/19 13:27:13  dark264sh
 * *** empty log message ***
 *
 * Revision 1.32  2009/06/19 13:18:26  jsyoon
 * ADD S_SSHM_A_TSESS[0-5]
 *
 * Revision 1.31  2009/06/19 11:20:16  jsyoon
 * ADD st_TraceMsgHdr, st_TraceID
 *
 * Revision 1.30  2009/06/19 08:58:48  upst_cvs
 * *** empty log message ***
 *
 * Revision 1.29  2009/06/19 08:55:29  jsyoon
 * ADD MULTIPLE TCP_HASHKEY
 *
 * Revision 1.28  2009/06/19 08:23:34  dark264sh
 * NOTIFY_SIG 구조체 추가
 *
 * Revision 1.27  2009/06/18 16:33:08  jsyoon
 * *** empty log message ***
 *
 * Revision 1.26  2009/06/16 15:21:05  jsyoon
 * *** empty log message ***
 *
 * Revision 1.25  2009/06/16 15:11:55  jsyoon
 * *** empty log message ***
 *
 * Revision 1.24  2009/06/16 08:49:29  jsyoon
 * Add pLOG_COMMON->usBranchID
 *
 * Revision 1.23  2009/06/16 06:57:28  bgpark
 * LOG_RPPI 필드명 변경
 *
 * Revision 1.22  2009/06/16 05:54:24  jsyoon
 * Add uiServerIP in LOG_PAGE
 *
 * Revision 1.21  2009/06/16 05:35:13  dark264sh
 * add SVCMONMSG_DEF_NUM
 *
 * Revision 1.20  2009/06/15 09:23:17  bgpark
 * *** empty log message ***
 *
 * Revision 1.19  2009/06/15 08:58:43  jsyoon
 * *** empty log message ***
 *
 * Revision 1.18  2009/06/14 13:05:23  jsyoon
 * *** empty log message ***
 *
 * Revision 1.17  2009/06/14 08:41:49  jsyoon
 * *** empty log message ***
 *
 * Revision 1.16  2009/06/13 21:52:56  bgpark
 * LOG_RPPI 정의
 *
 * Revision 1.15  2009/06/13 19:34:32  jsyoon
 * *** empty log message ***
 *
 * Revision 1.14  2009/06/13 13:58:24  dark264sh
 * *** empty log message ***
 *
 * Revision 1.13  2009/06/13 12:24:38  jsyoon
 * *** empty log message ***
 *
 * Revision 1.12  2009/06/12 16:27:37  upst_cvs
 * *** empty log message ***
 *
 * Revision 1.11  2009/06/12 14:43:15  upst_cvs
 * *** empty log message ***
 *
 * Revision 1.10  2009/06/12 11:15:10  jsyoon
 * *** empty log message ***
 *
 * Revision 1.9  2009/06/12 08:40:41  jsyoon
 * LOG_COMMON 구조체 수정
 *
 * Revision 1.8  2009/06/12 07:59:10  jsyoon
 * LOG_VT_SESS 구조체 수정
 *
 * Revision 1.7  2009/06/12 07:25:46  jsyoon
 * *** empty log message ***
 *
 * Revision 1.6  2009/06/12 01:06:48  dark264sh
 * *** empty log message ***
 *
 * Revision 1.5  2009/06/11 19:27:34  jsyoon
 * *** empty log message ***
 *
 * Revision 1.4  2009/06/10 21:48:53  dark264sh
 * *** empty log message ***
 *
 * Revision 1.3  2009/06/10 21:42:32  dark264sh
 * *** empty log message ***
 *
 * Revision 1.2  2009/06/10 21:24:34  dark264sh
 * *** empty log message ***
 *
 * Revision 1.1  2009/06/10 16:45:50  dqms
 * *** empty log message ***
 *
 * Revision 1.7  2009/06/08 18:54:42  jsyoon
 * *** empty log message ***
 *
 * Revision 1.6  2009/06/08 02:46:22  jsyoon
 * *** empty log message ***
 *
 * Revision 1.5  2009/06/05 05:30:16  jsyoon
 * *** empty log message ***
 *
 * Revision 1.4  2009/06/04 09:03:28  jsyoon
 * *** empty log message ***
 *
 * Revision 1.3  2009/05/27 17:27:44  dqms
 * *** empty log message ***
 *
 * Revision 1.2  2009/05/27 14:24:48  dqms
 * *** empty log message ***
 *
 * Revision 1.1.1.1  2009/05/26 02:13:10  dqms
 * Init TAF_RPPI
 *
 * Revision 1.52  2009/03/02 09:07:56  dark264sh
 * DOWNLOAD VOD : 1x 단말에서 Content-Length, Transfer-Encoding Chunked, Multi Part 없이 Packet-Counter만 있는 경우 처리
 *
 * Revision 1.51  2009/02/11 06:26:44  dark264sh
 * MSRP 3사 연동 처리
 *
 * Revision 1.50  2009/01/28 14:56:43  dark264sh
 * A_SIPT node free 버그 수정
 *
 * Revision 1.49  2009/01/08 06:53:34  bgpark
 * vmbank L4, widget L7 추가
 *
 * Revision 1.48  2008/12/19 11:08:53  dark264sh
 * *** empty log message ***
 *
 * Revision 1.47  2008/12/18 07:26:45  dark264sh
 * Filter 변경 작업
 *
 * Revision 1.46  2008/12/17 12:21:46  dark264sh
 * WIDGET Ack Msg인 경우 L4CODE 변경
 *
 * Revision 1.45  2008/12/17 10:50:40  dark264sh
 * WIPI ONLINE szModel = szHandSet, szBrowserInfo = szKTFPExtVer 할당
 *
 * Revision 1.44  2008/12/17 09:42:36  dark264sh
 * *** empty log message ***
 *
 * Revision 1.43  2008/12/17 06:21:41  dark264sh
 * LOG_MMS L7Code L4_MMS_NEW 추가
 *
 * Revision 1.42  2008/12/17 03:26:12  dark264sh
 * *** empty log message ***
 *
 * Revision 1.41  2008/12/17 02:41:01  dark264sh
 * Internet 구간 관련하여 L4Code 변경
 *
 * Revision 1.40  2008/12/12 13:28:50  dark264sh
 * LOG_SIP SIP_USERAGENT_SIZE (33 => 65) 변경
 *
 * Revision 1.39  2008/11/27 06:00:14  dark264sh
 * SIP Vendor 필드 임시 처리
 *
 * Revision 1.38  2008/11/25 12:48:34  dark264sh
 * WIDGET 처리
 *
 * Revision 1.37  2008/11/24 12:42:04  dark264sh
 * *** empty log message ***
 *
 * Revision 1.36  2008/11/24 07:02:25  dark264sh
 * WIPI ONLINE 처리
 *
 * Revision 1.35  2008/11/24 05:30:10  dark264sh
 * INTERNET 처리
 *
 * Revision 1.34  2008/11/17 09:02:29  dark264sh
 * 64bits 작업
 *
 * Revision 1.33  2008/10/30 08:51:37  dark264sh
 * 구간 처리, up/down별 통계 처리
 *
 * Revision 1.32  2008/10/30 04:50:04  dark264sh
 * no message
 *
 * Revision 1.31  2008/09/21 10:40:21  dark264sh
 * MSRP Failure-Report Partial paring 추가
 *
 * Revision 1.30  2008/09/18 07:36:41  dark264sh
 * IM 서비스 추가 (SIP, XCAP, MSRP)
 *
 * Revision 1.29  2008/08/01 08:51:42  jsyoon
 * *** empty log message ***
 *
 * Revision 1.29  2008/08/01 02:30:40  dark264sh
 * Full Browser LGT 요청에 의한 원복 작업
 *
 * Revision 1.28  2008/07/16 16:00:05  dark264sh
 * *** empty log message ***
 *
 * Revision 1.27  2008/07/16 08:08:16  dark264sh
 * *** empty log message ***
 *
 * Revision 1.26  2008/07/16 06:40:51  dark264sh
 * *** empty log message ***
 *
 * Revision 1.25  2008/07/15 17:04:59  dark264sh
 * *** empty log message ***
 *
 * Revision 1.24  2008/07/15 13:45:20  dark264sh
 * *** empty log message ***
 *
 * Revision 1.23  2008/07/14 12:41:31  dark264sh
 * *** empty log message ***
 *
 * Revision 1.22  2008/07/14 11:07:21  dark264sh
 * *** empty log message ***
 *
 * Revision 1.21  2008/07/14 10:02:53  dark264sh
 * *** empty log message ***
 *
 * Revision 1.20  2008/07/14 09:56:11  dark264sh
 * *** empty log message ***
 *
 * Revision 1.19  2008/07/14 07:46:05  jsyoon
 * L4_EMS_NO 코드 추가
 *
 * Revision 1.18  2008/07/14 07:19:53  dark264sh
 * *** empty log message ***
 *
 * Revision 1.17  2008/07/07 17:22:42  jsyoon
 * *** empty log message ***
 *
 * Revision 1.16  2008/07/07 15:05:24  jyjung
 * IsCompleted가 Page시작 위치
 *
 * Revision 1.15  2008/07/02 13:16:38  dark264sh
 * *** empty log message ***
 *
 * Revision 1.14  2008/07/02 11:49:13  jsyoon
 * ADD L4_P_EMS CODE
 *
 * Revision 1.13  2008/07/02 07:46:08  dark264sh
 * *** empty log message ***
 *
 * Revision 1.12  2008/06/30 12:45:46  jsyoon
 * *** empty log message ***
 *
 * Revision 1.11  2008/06/26 12:39:57  jsyoon
 * SOURCE COMMIT
 *
 * Revision 1.10  2008/06/23 04:06:41  jyjung
 * A_IV 추가
 *
 * Revision 1.9  2008/06/22 10:15:13  dark264sh
 * A_FB chunked, multipart, gzip, deflate, min 처리
 *
 * Revision 1.8  2008/06/19 12:12:26  jsyoon
 * L4CODE 정의 변경, EMS 관련 L7CODE 추가
 *
 * Revision 1.7  2008/06/19 05:46:30  watas
 * ADD MAX_COMMAND_LEN
 *
 * Revision 1.6  2008/06/18 12:24:33  dark264sh
 * A_FB 추가
 *
 * Revision 1.5  2008/06/18 11:11:34  dark264sh
 * A_FV Error-Code값이 발생하는 경우 UserErrorCode, L7FailCode 세팅
 *
 * Revision 1.4  2008/06/18 09:21:15  dark264sh
 * A_IV 관련 상수 선언
 *
 * Revision 1.3  2008/06/18 07:06:11  jsyoon
 * szAppFailCode 파싱룰 추가
 *
 * Revision 1.2  2008/06/17 12:21:24  dark264sh
 * A_FV, A_EMS 추가
 *
 * Revision 1.1.1.1  2008/06/09 08:17:18  jsyoon
 * WATAS3 PROJECT START
 *
 * Revision 1.11  2007/10/08 04:29:20  dark264sh
 * no message
 *
 * Revision 1.10  2007/09/05 07:11:57  dark264sh
 * *** empty log message ***
 *
 * Revision 1.9  2007/09/04 11:39:00  dark264sh
 * *** empty log message ***
 *
 * Revision 1.8  2007/09/04 11:23:21  watas
 * *** empty log message ***
 *
 * Revision 1.7  2007/09/04 06:20:22  dark264sh
 * *** empty log message ***
 *
 * Revision 1.6  2007/09/03 12:19:04  dark264sh
 * *** empty log message ***
 *
 * Revision 1.5  2007/09/03 05:31:32  dark264sh
 * *** empty log message ***
 *
 * Revision 1.4  2007/08/31 10:56:45  dark264sh
 * *** empty log message ***
 *
 * Revision 1.3  2007/08/29 12:41:48  dark264sh
 * *** empty log message ***
 *
 * Revision 1.2  2007/08/29 07:44:16  dark264sh
 * *** empty log message ***
 *
 * Revision 1.1  2007/08/27 13:32:41  dark264sh
 * *** empty log message ***
 *
 * Revision 1.1  2007/08/21 12:48:22  dark264sh
 * no message
 *
 * Revision 1.45  2006/11/01 04:42:22  cjlee
 * STRING type추가
 *
 * Revision 1.30  2006/10/17 05:28:50  cjlee
 * *** empty log message ***
 *
 * Revision 1.29  2006/10/17 05:16:46  cjlee
 * aqua.pstg 와 flow.stg를 합침 -> aqua.pstg
 *
 * Revision 1.28  2006/10/17 03:54:17  cjlee
 * flow action 내용 수정 : compile 완료
 *
 * Revision 1.27  2006/10/16 15:32:24  shlee
 * UPDATE Structure for FLOW
 *
 * Revision 1.26  2006/10/16 08:47:47  cjlee
 * flow 반영중
 *
 * Revision 1.40  2006/10/11 06:13:38  cjlee
 * *** empty log message ***
 *
 * Revision 1.39  2006/10/11 05:45:54  cjlee
 * *** empty log message ***
 *
 * Revision 1.38  2006/10/11 03:16:50  cjlee
 * SIZE 는 선언 , LEN은 실제 사용
 *
 * Revision 1.37  2006/10/10 08:55:17  cjlee
 * PAGE CALL 의 field들 내용 추가
 *
 * Revision 1.36  2006/10/09 13:27:26  dark264sh
 * URL을 http://hostname/path 형태로 만드는 부분 추가 (Port 번호를 뺀 값)
 *
 * Revision 1.35  2006/10/09 10:30:57  cjlee
 * *** empty log message ***
 *
 * Revision 1.34  2006/10/09 10:02:08  cjlee
 * *** empty log message ***
 *
 * Revision 1.33  2006/10/09 08:54:31  cjlee
 * *** empty log message ***
 *
 * Revision 1.32  2006/10/09 07:50:27  shlee
 * t
 *
 * Revision 1.31  2006/10/04 08:40:28  cjlee
 * *** empty log message ***
 *
 * Revision 1.30  2006/10/04 07:37:00  dark264sh
 * 필터 읽는 방법 변경, define PATH_FILTER
 *
 * Revision 1.29  2006/10/04 06:24:13  cjlee
 * *** empty log message ***
 *
 * Revision 1.28  2006/10/04 06:16:55  cjlee
 * *** empty log message ***
 *
 * Revision 1.27  2006/10/04 05:24:40  dark264sh
 * APPCODE 대신에 MSGQKEY 추가
 *
 * Revision 1.26  2006/10/04 01:48:39  dark264sh
 * define 이름 변경(유사한 이름 사용으로 헷갈림)
 *
 * Revision 1.25  2006/10/04 01:48:05  cjlee
 * conf 완료
 *
 * Revision 1.24  2006/10/04 00:11:53  cjlee
 * conf-new에 맞춘 aqua.pstg
 *
 * Revision 1.23  2006/10/02 00:14:54  dark264sh
 * 디버깅을 목적으로 uiLastSeq 추가
 *
 * Revision 1.22  2006/10/01 23:59:45  cjlee
 * *** empty log message ***
 *
 * Revision 1.21  2006/10/01 23:55:50  cjlee
 * HASH추가
 *
 * Revision 1.20  2006/09/29 08:50:38  dark264sh
 * FIN 재전송 체크를 위한 필드 추가
 *
 * Revision 1.19  2006/09/29 01:46:27  cjlee
 * *** empty log message ***
 *
 * Revision 1.18  2006/09/28 06:42:53  cjlee
 * service option의 자리수 늘려줌
 *
 * Revision 1.17  2006/09/28 04:23:28  cjlee
 * URL PARSE 추가
 *
 * Revision 1.16  2006/09/27 05:15:29  dark264sh
 * 이름 변경
 *
 * Revision 1.15  2006/09/27 04:08:19  cjlee
 * ASSOCIATION을 포함한 새로운 update :
 * - HTTP , CALL , PAGE
 *
 * Revision 1.14  2006/09/26 09:46:57  dark264sh
 * no message
 *
 * Revision 1.13  2006/09/26 09:27:41  dark264sh
 * HTTP_TRANS 멤버 변경
 * 필요없는 필드 삭제
 *
 * Revision 1.12  2006/09/25 02:53:49  dark264sh
 * http req/res header/body 구분 번호 변경
 *
 * Revision 1.11  2006/09/22 07:02:30  dark264sh
 * no message
 *
 * Revision 1.10  2006/09/21 05:32:18  dark264sh
 * http body 끝을 판단하는 방법 변경
 *
 * Revision 1.9  2006/09/19 07:21:20  dark264sh
 * no message
 *
 * Revision 1.8  2006/09/18 03:04:52  dark264sh
 * no message
 *
 * Revision 1.7  2006/09/13 05:05:30  dark264sh
 * TCP Session, HTTP Transaction Count 변경
 * - 현재 시스템에서 메모리 사이즈 부족으로 할당을 못하는 문제 발생
 *    상용 시스템에 설치시에 알맞은 값으로 변경해야 함.
 *
 * Revision 1.6  2006/09/11 02:14:49  dark264sh
 * no message
 *
 * Revision 1.5  2006/09/11 02:07:37  dark264sh
 * no message
 *
 * Revision 1.4  2006/09/11 01:55:19  dark264sh
 * no message
 *
 * Revision 1.3  2006/09/08 06:06:59  cjlee
 * debug : U32로 맞춰줌
 *
 * Revision 1.2  2006/09/08 05:59:44  cjlee
 * CONF UPDATE
 *
 * Revision 1.1  2006/09/08 01:56:55  dark264sh
 * INIT
 *
 * Revision 1.21  2006/09/07 09:07:56  cjlee
 * L4 , L7 , MN CONF 변경 및 추가
 *
 * Revision 1.20  2006/09/07 06:04:33  dark264sh
 * PRE_A
 * filter 정보 검색 추가
 *
 * Revision 1.19  2006/09/06 11:25:28  dark264sh
 * uiSndQID => dSndQID로 변경
 *
 * Revision 1.18  2006/09/06 09:32:03  dark264sh
 * 구조체 번호 선정
 *
 * Revision 1.17  2006/09/05 04:57:27  dark264sh
 * 에러 핸들링, 에러 코드 부분 수정
 *
 * Revision 1.16  2006/09/04 06:56:33  dark264sh
 * no message
 *
 * Revision 1.15  2006/09/04 05:31:10  dark264sh
 * Data Cnt, Size를 HTTP에 전송하기 위한 부분 수정
 *
 * Revision 1.14  2006/08/29 04:27:39  dark264sh
 * no message
 *
 * Revision 1.13  2006/08/29 01:46:06  dark264sh
 * no message
 *
 * Revision 1.12  2006/08/29 01:30:33  dark264sh
 * no message
 *
 * Revision 1.11  2006/08/29 01:25:09  dark264sh
 * no message
 *
 * Revision 1.10  2006/08/29 01:23:01  dark264sh
 * no message
 *
 * Revision 1.9  2006/08/28 12:16:42  dark264sh
 * no message
 *
 * Revision 1.8  2006/08/28 04:04:20  dark264sh
 * no message
 *
 * Revision 1.7  2006/08/28 02:22:59  dark264sh
 * no message
 *
 * Revision 1.6  2006/08/28 02:12:25  dark264sh
 * no message
 *
 * Revision 1.5  2006/08/28 01:29:23  dark264sh
 * no message
 *
 * Revision 1.4  2006/08/28 00:53:49  dark264sh
 * 오타 수정
 *
 * Revision 1.3  2006/08/25 07:14:48  dark264sh
 * no message
 *
 * Revision 1.2  2006/08/24 04:08:23  dark264sh
 * HTTP 기본 Flow 구성
 *
 * Revision 1.1  2006/08/22 01:51:45  dark264sh
 * aqua.stg => aqua.pstg
 *
 * Revision 1.12  2006/08/22 01:44:30  dark264sh
 * no message
 *
 * Revision 1.11  2006/08/22 01:41:29  dark264sh
 * no message
 *
 * Revision 1.10  2006/08/21 09:22:41  dark264sh
 * L4FailCode 설정 함수 추가
 *
 * Revision 1.9  2006/08/21 07:35:34  dark264sh
 * TCP_SESS struct timeval => STIME, MTIME으로 변경
 * structg에서 struct timeval 처리를 못함.
 *
 * Revision 1.8  2006/08/21 06:22:56  dark264sh
 * no message
 *
 * Revision 1.7  2006/08/21 04:32:29  dark264sh
 * no message
 *
 * Revision 1.6  2006/08/21 04:15:02  dark264sh
 * no message
 *
 * Revision 1.5  2006/08/21 01:32:32  dark264sh
 * LOG_COMMON 추가
 *
 * Revision 1.4  2006/08/18 10:18:03  dark264sh
 * no message
 *
 * Revision 1.3  2006/08/16 05:32:03  dark264sh
 * no message
 *
 * Revision 1.2  2006/08/16 05:07:55  dark264sh
 * no message
 *
 * Revision 1.1  2006/08/16 05:07:22  dark264sh
 * INIT
 *
 */
